(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("devtools/client/shared/vendor/react-prop-types"), require("devtools/client/shared/vendor/react-dom-factories"), require("devtools/client/shared/vendor/react"), require("Services"), require("devtools/shared/flags"), require("devtools/client/shared/vendor/react-dom"), require("devtools/client/shared/vendor/lodash"), require("devtools/client/shared/vendor/react-redux"), require("devtools/client/shared/vendor/redux"), require("devtools/client/shared/vendor/immutable"), require("devtools/client/sourceeditor/editor"), require("devtools/client/shared/vendor/WasmParser"), require("devtools/client/shared/vendor/WasmDis"));
	else if(typeof define === 'function' && define.amd)
		define(["devtools/client/shared/vendor/react-prop-types", "devtools/client/shared/vendor/react-dom-factories", "devtools/client/shared/vendor/react", "Services", "devtools/shared/flags", "devtools/client/shared/vendor/react-dom", "devtools/client/shared/vendor/lodash", "devtools/client/shared/vendor/react-redux", "devtools/client/shared/vendor/redux", "devtools/client/shared/vendor/immutable", "devtools/client/sourceeditor/editor", "devtools/client/shared/vendor/WasmParser", "devtools/client/shared/vendor/WasmDis"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("devtools/client/shared/vendor/react-prop-types"), require("devtools/client/shared/vendor/react-dom-factories"), require("devtools/client/shared/vendor/react"), require("Services"), require("devtools/shared/flags"), require("devtools/client/shared/vendor/react-dom"), require("devtools/client/shared/vendor/lodash"), require("devtools/client/shared/vendor/react-redux"), require("devtools/client/shared/vendor/redux"), require("devtools/client/shared/vendor/immutable"), require("devtools/client/sourceeditor/editor"), require("devtools/client/shared/vendor/WasmParser"), require("devtools/client/shared/vendor/WasmDis")) : factory(root["devtools/client/shared/vendor/react-prop-types"], root["devtools/client/shared/vendor/react-dom-factories"], root["devtools/client/shared/vendor/react"], root["Services"], root["devtools/shared/flags"], root["devtools/client/shared/vendor/react-dom"], root["devtools/client/shared/vendor/lodash"], root["devtools/client/shared/vendor/react-redux"], root["devtools/client/shared/vendor/redux"], root["devtools/client/shared/vendor/immutable"], root["devtools/client/sourceeditor/editor"], root["devtools/client/shared/vendor/WasmParser"], root["devtools/client/shared/vendor/WasmDis"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_6__, __WEBPACK_EXTERNAL_MODULE_37__, __WEBPACK_EXTERNAL_MODULE_103__, __WEBPACK_EXTERNAL_MODULE_112__, __WEBPACK_EXTERNAL_MODULE_417__, __WEBPACK_EXTERNAL_MODULE_484__, __WEBPACK_EXTERNAL_MODULE_517__, __WEBPACK_EXTERNAL_MODULE_543__, __WEBPACK_EXTERNAL_MODULE_562__, __WEBPACK_EXTERNAL_MODULE_622__, __WEBPACK_EXTERNAL_MODULE_623__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/assets/build";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 611);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_0__;

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_1__;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// Dependencies
const validProtocols = /(http|https|ftp|data|resource|chrome):/i;

// URL Regex, common idioms:
//
// Lead-in (URL):
// (                     Capture because we need to know if there was a lead-in
//                       character so we can include it as part of the text
//                       preceding the match. We lack look-behind matching.
//  ^|                   The URL can start at the beginning of the string.
//  [\s(,;'"`]           Or whitespace or some punctuation that does not imply
//                       a context which would preclude a URL.
// )
//
// We do not need a trailing look-ahead because our regex's will terminate
// because they run out of characters they can eat.

// What we do not attempt to have the regexp do:
// - Avoid trailing '.' and ')' characters.  We let our greedy match absorb
//   these, but have a separate regex for extra characters to leave off at the
//   end.
//
// The Regex (apart from lead-in/lead-out):
// (                     Begin capture of the URL
//  (?:                  (potential detect beginnings)
//   https?:\/\/|        Start with "http" or "https"
//   www\d{0,3}[.][a-z0-9.\-]{2,249}|
//                      Start with "www", up to 3 numbers, then "." then
//                       something that looks domain-namey.  We differ from the
//                       next case in that we do not constrain the top-level
//                       domain as tightly and do not require a trailing path
//                       indicator of "/".  This is IDN root compatible.
//   [a-z0-9.\-]{2,250}[.][a-z]{2,4}\/
//                       Detect a non-www domain, but requiring a trailing "/"
//                       to indicate a path.  This only detects IDN domains
//                       with a non-IDN root.  This is reasonable in cases where
//                       there is no explicit http/https start us out, but
//                       unreasonable where there is.  Our real fix is the bug
//                       to port the Thunderbird/gecko linkification logic.
//
//                       Domain names can be up to 253 characters long, and are
//                       limited to a-zA-Z0-9 and '-'.  The roots don't have
//                       hyphens unless they are IDN roots.  Root zones can be
//                       found here: http://www.iana.org/domains/root/db
//  )
//  [-\w.!~*'();,/?:@&=+$#%]*
//                       path onwards. We allow the set of characters that
//                       encodeURI does not escape plus the result of escaping
//                       (so also '%')
// )
// eslint-disable-next-line max-len
const urlRegex = /(^|[\s(,;'"`])((?:https?:\/\/|www\d{0,3}[.][a-z0-9.\-]{2,249}|[a-z0-9.\-]{2,250}[.][a-z]{2,4}\/)[-\w.!~*'();,/?:@&=+$#%]*)/im;

// Set of terminators that are likely to have been part of the context rather
// than part of the URL and so should be uneaten. This is '(', ',', ';', plus
// quotes and question end-ing punctuation and the potential permutations with
// parentheses (english-specific).
const uneatLastUrlCharsRegex = /(?:[),;.!?`'"]|[.!?]\)|\)[.!?])$/;

const ELLIPSIS = "\u2026";
const dom = __webpack_require__(1);
const { span } = dom;

/**
 * Returns true if the given object is a grip (see RDP protocol)
 */
function isGrip(object) {
  return object && object.actor;
}

function escapeNewLines(value) {
  return value.replace(/\r/gm, "\\r").replace(/\n/gm, "\\n");
}

// Map from character code to the corresponding escape sequence.  \0
// isn't here because it would require special treatment in some
// situations.  \b, \f, and \v aren't here because they aren't very
// common.  \' isn't here because there's no need, we only
// double-quote strings.
const escapeMap = {
  // Tab.
  9: "\\t",
  // Newline.
  0xa: "\\n",
  // Carriage return.
  0xd: "\\r",
  // Quote.
  0x22: '\\"',
  // Backslash.
  0x5c: "\\\\"
};

// Regexp that matches any character we might possibly want to escape.
// Note that we over-match here, because it's difficult to, say, match
// an unpaired surrogate with a regexp.  The details are worked out by
// the replacement function; see |escapeString|.
const escapeRegexp = new RegExp("[" +
// Quote and backslash.
'"\\\\' +
// Controls.
"\x00-\x1f" +
// More controls.
"\x7f-\x9f" +
// BOM
"\ufeff" +
// Specials, except for the replacement character.
"\ufff0-\ufffc\ufffe\uffff" +
// Surrogates.
"\ud800-\udfff" +
// Mathematical invisibles.
"\u2061-\u2064" +
// Line and paragraph separators.
"\u2028-\u2029" +
// Private use area.
"\ue000-\uf8ff" + "]", "g");

/**
 * Escape a string so that the result is viewable and valid JS.
 * Control characters, other invisibles, invalid characters,
 * backslash, and double quotes are escaped.  The resulting string is
 * surrounded by double quotes.
 *
 * @param {String} str
 *        the input
 * @param {Boolean} escapeWhitespace
 *        if true, TAB, CR, and NL characters will be escaped
 * @return {String} the escaped string
 */
function escapeString(str, escapeWhitespace) {
  return `"${str.replace(escapeRegexp, (match, offset) => {
    const c = match.charCodeAt(0);
    if (c in escapeMap) {
      if (!escapeWhitespace && (c === 9 || c === 0xa || c === 0xd)) {
        return match[0];
      }
      return escapeMap[c];
    }
    if (c >= 0xd800 && c <= 0xdfff) {
      // Find the full code point containing the surrogate, with a
      // special case for a trailing surrogate at the start of the
      // string.
      if (c >= 0xdc00 && offset > 0) {
        --offset;
      }
      const codePoint = str.codePointAt(offset);
      if (codePoint >= 0xd800 && codePoint <= 0xdfff) {
        // Unpaired surrogate.
        return `\\u${codePoint.toString(16)}`;
      } else if (codePoint >= 0xf0000 && codePoint <= 0x10fffd) {
        // Private use area.  Because we visit each pair of a such a
        // character, return the empty string for one half and the
        // real result for the other, to avoid duplication.
        if (c <= 0xdbff) {
          return `\\u{${codePoint.toString(16)}}`;
        }
        return "";
      }
      // Other surrogate characters are passed through.
      return match;
    }
    return `\\u${`0000${c.toString(16)}`.substr(-4)}`;
  })}"`;
}

/**
 * Escape a property name, if needed.  "Escaping" in this context
 * means surrounding the property name with quotes.
 *
 * @param {String}
 *        name the property name
 * @return {String} either the input, or the input surrounded by
 *                  quotes, properly quoted in JS syntax.
 */
function maybeEscapePropertyName(name) {
  // Quote the property name if it needs quoting.  This particular
  // test is an approximation; see
  // https://mathiasbynens.be/notes/javascript-properties.  However,
  // the full solution requires a fair amount of Unicode data, and so
  // let's defer that until either it's important, or the \p regexp
  // syntax lands, see
  // https://github.com/tc39/proposal-regexp-unicode-property-escapes.
  if (!/^\w+$/.test(name)) {
    name = escapeString(name);
  }
  return name;
}

function cropMultipleLines(text, limit) {
  return escapeNewLines(cropString(text, limit));
}

function rawCropString(text, limit, alternativeText = ELLIPSIS) {
  // Crop the string only if a limit is actually specified.
  if (!limit || limit <= 0) {
    return text;
  }

  // Set the limit at least to the length of the alternative text
  // plus one character of the original text.
  if (limit <= alternativeText.length) {
    limit = alternativeText.length + 1;
  }

  const halfLimit = (limit - alternativeText.length) / 2;

  if (text.length > limit) {
    return text.substr(0, Math.ceil(halfLimit)) + alternativeText + text.substr(text.length - Math.floor(halfLimit));
  }

  return text;
}

function cropString(text, limit, alternativeText) {
  return rawCropString(sanitizeString(`${text}`), limit, alternativeText);
}

function sanitizeString(text) {
  // Replace all non-printable characters, except of
  // (horizontal) tab (HT: \x09) and newline (LF: \x0A, CR: \x0D),
  // with unicode replacement character (u+fffd).
  // eslint-disable-next-line no-control-regex
  const re = new RegExp("[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x9F]", "g");
  return text.replace(re, "\ufffd");
}

function parseURLParams(url) {
  url = new URL(url);
  return parseURLEncodedText(url.searchParams);
}

function parseURLEncodedText(text) {
  const params = [];

  // In case the text is empty just return the empty parameters
  if (text == "") {
    return params;
  }

  const searchParams = new URLSearchParams(text);
  const entries = [...searchParams.entries()];
  return entries.map(entry => {
    return {
      name: entry[0],
      value: entry[1]
    };
  });
}

function getFileName(url) {
  const split = splitURLBase(url);
  return split.name;
}

function splitURLBase(url) {
  if (!isDataURL(url)) {
    return splitURLTrue(url);
  }
  return {};
}

function getURLDisplayString(url) {
  return cropString(url);
}

function isDataURL(url) {
  return url && url.substr(0, 5) == "data:";
}

function splitURLTrue(url) {
  const reSplitFile = /(.*?):\/{2,3}([^\/]*)(.*?)([^\/]*?)($|\?.*)/;
  const m = reSplitFile.exec(url);

  if (!m) {
    return {
      name: url,
      path: url
    };
  } else if (m[4] == "" && m[5] == "") {
    return {
      protocol: m[1],
      domain: m[2],
      path: m[3],
      name: m[3] != "/" ? m[3] : m[2]
    };
  }

  return {
    protocol: m[1],
    domain: m[2],
    path: m[2] + m[3],
    name: m[4] + m[5]
  };
}

/**
 * Wrap the provided render() method of a rep in a try/catch block that will
 * render a fallback rep if the render fails.
 */
function wrapRender(renderMethod) {
  const wrappedFunction = function (props) {
    try {
      return renderMethod.call(this, props);
    } catch (e) {
      console.error(e);
      return span({
        className: "objectBox objectBox-failure",
        title: "This object could not be rendered, " + "please file a bug on bugzilla.mozilla.org"
      },
      /* Labels have to be hardcoded for reps, see Bug 1317038. */
      "Invalid object");
    }
  };
  wrappedFunction.propTypes = renderMethod.propTypes;
  return wrappedFunction;
}

/**
 * Get preview items from a Grip.
 *
 * @param {Object} Grip from which we want the preview items
 * @return {Array} Array of the preview items of the grip, or an empty array
 *                 if the grip does not have preview items
 */
function getGripPreviewItems(grip) {
  if (!grip) {
    return [];
  }

  // Promise resolved value Grip
  if (grip.promiseState && grip.promiseState.value) {
    return [grip.promiseState.value];
  }

  // Array Grip
  if (grip.preview && grip.preview.items) {
    return grip.preview.items;
  }

  // Node Grip
  if (grip.preview && grip.preview.childNodes) {
    return grip.preview.childNodes;
  }

  // Set or Map Grip
  if (grip.preview && grip.preview.entries) {
    return grip.preview.entries.reduce((res, entry) => res.concat(entry), []);
  }

  // Event Grip
  if (grip.preview && grip.preview.target) {
    const keys = Object.keys(grip.preview.properties);
    const values = Object.values(grip.preview.properties);
    return [grip.preview.target, ...keys, ...values];
  }

  // RegEx Grip
  if (grip.displayString) {
    return [grip.displayString];
  }

  // Generic Grip
  if (grip.preview && grip.preview.ownProperties) {
    let propertiesValues = Object.values(grip.preview.ownProperties).map(property => property.value || property);

    const propertyKeys = Object.keys(grip.preview.ownProperties);
    propertiesValues = propertiesValues.concat(propertyKeys);

    // ArrayBuffer Grip
    if (grip.preview.safeGetterValues) {
      propertiesValues = propertiesValues.concat(Object.values(grip.preview.safeGetterValues).map(property => property.getterValue || property));
    }

    return propertiesValues;
  }

  return [];
}

/**
 * Get the type of an object.
 *
 * @param {Object} Grip from which we want the type.
 * @param {boolean} noGrip true if the object is not a grip.
 * @return {boolean}
 */
function getGripType(object, noGrip) {
  if (noGrip || Object(object) !== object) {
    return typeof object;
  }
  if (object.type === "object") {
    return object.class;
  }
  return object.type;
}

/**
 * Determines whether a grip is a string containing a URL.
 *
 * @param string grip
 *        The grip, which may contain a URL.
 * @return boolean
 *         Whether the grip is a string containing a URL.
 */
function containsURL(grip) {
  // An URL can't be shorter than 5 char (e.g. "ftp:").
  if (typeof grip !== "string" || grip.length < 5) {
    return false;
  }

  return validProtocols.test(grip);
}

/**
 * Determines whether a string token is a valid URL.
 *
 * @param string token
 *        The token.
 * @return boolean
 *         Whether the token is a URL.
 */
function isURL(token) {
  try {
    if (!validProtocols.test(token)) {
      return false;
    }
    new URL(token);
    return true;
  } catch (e) {
    return false;
  }
}

/**
 * Returns new array in which `char` are interleaved between the original items.
 *
 * @param {Array} items
 * @param {String} char
 * @returns Array
 */
function interleave(items, char) {
  return items.reduce((res, item, index) => {
    if (index !== items.length - 1) {
      return res.concat(item, char);
    }
    return res.concat(item);
  }, []);
}

const ellipsisElement = span({
  key: "more",
  className: "more-ellipsis",
  title: `more${ELLIPSIS}`
}, ELLIPSIS);

module.exports = {
  interleave,
  isGrip,
  isURL,
  cropString,
  containsURL,
  rawCropString,
  sanitizeString,
  escapeString,
  wrapRender,
  cropMultipleLines,
  parseURLParams,
  parseURLEncodedText,
  getFileName,
  getURLDisplayString,
  maybeEscapePropertyName,
  getGripPreviewItems,
  getGripType,
  ellipsisElement,
  ELLIPSIS,
  uneatLastUrlCharsRegex,
  urlRegex
};

/***/ }),
/* 3 */,
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

module.exports = {
  MODE: {
    TINY: Symbol("TINY"),
    SHORT: Symbol("SHORT"),
    LONG: Symbol("LONG")
  }
};

/***/ }),
/* 5 */,
/* 6 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_6__;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

const networkRequest = __webpack_require__(13);
const workerUtils = __webpack_require__(14);

module.exports = {
  networkRequest,
  workerUtils
};

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__(43);

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),
/* 9 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),
/* 10 */,
/* 11 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),
/* 12 */,
/* 13 */
/***/ (function(module, exports) {

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function networkRequest(url, opts) {
  return fetch(url, {
    cache: opts.loadFromCache ? "default" : "no-cache"
  }).then(res => {
    if (res.status >= 200 && res.status < 300) {
      if (res.headers.get("Content-Type") === "application/wasm") {
        return res.arrayBuffer().then(buffer => ({
          content: buffer,
          isDwarf: true
        }));
      }
      return res.text().then(text => ({ content: text }));
    }
    return Promise.reject(`request failed with status ${res.status}`);
  });
}

module.exports = networkRequest;

/***/ }),
/* 14 */
/***/ (function(module, exports) {



function WorkerDispatcher() {
  this.msgId = 1;
  this.worker = null;
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

WorkerDispatcher.prototype = {
  start(url, win = window) {
    this.worker = new win.Worker(url);
    this.worker.onerror = () => {
      console.error(`Error in worker ${url}`);
    };
  },

  stop() {
    if (!this.worker) {
      return;
    }

    this.worker.terminate();
    this.worker = null;
  },

  task(method, { queue = false } = {}) {
    const calls = [];
    const push = args => {
      return new Promise((resolve, reject) => {
        if (queue && calls.length === 0) {
          Promise.resolve().then(flush);
        }

        calls.push([args, resolve, reject]);

        if (!queue) {
          flush();
        }
      });
    };

    const flush = () => {
      const items = calls.slice();
      calls.length = 0;

      if (!this.worker) {
        return;
      }

      const id = this.msgId++;
      this.worker.postMessage({
        id,
        method,
        calls: items.map(item => item[0])
      });

      const listener = ({ data: result }) => {
        if (result.id !== id) {
          return;
        }

        if (!this.worker) {
          return;
        }

        this.worker.removeEventListener("message", listener);

        result.results.forEach((resultData, i) => {
          const [, resolve, reject] = items[i];

          if (resultData.error) {
            reject(resultData.error);
          } else {
            resolve(resultData.response);
          }
        });
      };

      this.worker.addEventListener("message", listener);
    };

    return (...args) => push(args);
  },

  invoke(method, ...args) {
    return this.task(method)(...args);
  }
};

function workerHandler(publicInterface) {
  return function (msg) {
    const { id, method, calls } = msg.data;

    Promise.all(calls.map(args => {
      try {
        const response = publicInterface[method].apply(undefined, args);
        if (response instanceof Promise) {
          return response.then(val => ({ response: val }),
          // Error can't be sent via postMessage, so be sure to
          // convert to string.
          err => ({ error: err.toString() }));
        }
        return { response };
      } catch (error) {
        // Error can't be sent via postMessage, so be sure to convert to
        // string.
        return { error: error.toString() };
      }
    })).then(results => {
      self.postMessage({ id, results });
    });
  };
}

module.exports = {
  WorkerDispatcher,
  workerHandler
};

/***/ }),
/* 15 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 16 */,
/* 17 */,
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(19),
    getRawTag = __webpack_require__(71),
    objectToString = __webpack_require__(72);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(8);

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),
/* 20 */,
/* 21 */,
/* 22 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 23 */,
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

__webpack_require__(458);

// Load all existing rep templates
const Undefined = __webpack_require__(459);
const Null = __webpack_require__(460);
const StringRep = __webpack_require__(25);
const Number = __webpack_require__(461);
const ArrayRep = __webpack_require__(38);
const Obj = __webpack_require__(462);
const SymbolRep = __webpack_require__(463);
const InfinityRep = __webpack_require__(464);
const NaNRep = __webpack_require__(465);
const Accessor = __webpack_require__(466);

// DOM types (grips)
const Accessible = __webpack_require__(467);
const Attribute = __webpack_require__(468);
const BigInt = __webpack_require__(188);
const DateTime = __webpack_require__(469);
const Document = __webpack_require__(470);
const DocumentType = __webpack_require__(471);
const Event = __webpack_require__(472);
const Func = __webpack_require__(189);
const PromiseRep = __webpack_require__(473);
const RegExp = __webpack_require__(474);
const StyleSheet = __webpack_require__(475);
const CommentNode = __webpack_require__(476);
const ElementNode = __webpack_require__(477);
const TextNode = __webpack_require__(478);
const ErrorRep = __webpack_require__(191);
const Window = __webpack_require__(479);
const ObjectWithText = __webpack_require__(480);
const ObjectWithURL = __webpack_require__(481);
const GripArray = __webpack_require__(192);
const GripMap = __webpack_require__(194);
const GripMapEntry = __webpack_require__(195);
const Grip = __webpack_require__(113);

// List of all registered template.
// XXX there should be a way for extensions to register a new
// or modify an existing rep.
const reps = [RegExp, StyleSheet, Event, DateTime, CommentNode, Accessible, ElementNode, TextNode, Attribute, Func, PromiseRep, ArrayRep, Document, DocumentType, Window, ObjectWithText, ObjectWithURL, ErrorRep, GripArray, GripMap, GripMapEntry, Grip, Undefined, Null, StringRep, Number, BigInt, SymbolRep, InfinityRep, NaNRep, Accessor, Obj];

/**
 * Generic rep that is used for rendering native JS types or an object.
 * The right template used for rendering is picked automatically according
 * to the current value type. The value must be passed in as the 'object'
 * property.
 */
const Rep = function (props) {
  const { object, defaultRep } = props;
  const rep = getRep(object, defaultRep, props.noGrip);
  return rep(props);
};

// Helpers

/**
 * Return a rep object that is responsible for rendering given
 * object.
 *
 * @param object {Object} Object to be rendered in the UI. This
 * can be generic JS object as well as a grip (handle to a remote
 * debuggee object).
 *
 * @param defaultRep {React.Component} The default template
 * that should be used to render given object if none is found.
 *
 * @param noGrip {Boolean} If true, will only check reps not made for remote
 *                         objects.
 */
function getRep(object, defaultRep = Grip, noGrip = false) {
  for (let i = 0; i < reps.length; i++) {
    const rep = reps[i];
    try {
      // supportsObject could return weight (not only true/false
      // but a number), which would allow to priorities templates and
      // support better extensibility.
      if (rep.supportsObject(object, noGrip)) {
        return rep.rep;
      }
    } catch (err) {
      console.error(err);
    }
  }

  return defaultRep.rep;
}

module.exports = {
  Rep,
  REPS: {
    Accessible,
    Accessor,
    ArrayRep,
    Attribute,
    BigInt,
    CommentNode,
    DateTime,
    Document,
    DocumentType,
    ElementNode,
    ErrorRep,
    Event,
    Func,
    Grip,
    GripArray,
    GripMap,
    GripMapEntry,
    InfinityRep,
    NaNRep,
    Null,
    Number,
    Obj,
    ObjectWithText,
    ObjectWithURL,
    PromiseRep,
    RegExp,
    Rep,
    StringRep,
    StyleSheet,
    SymbolRep,
    TextNode,
    Undefined,
    Window
  },
  // Exporting for tests
  getRep
};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// Dependencies
const PropTypes = __webpack_require__(0);

const {
  containsURL,
  escapeString,
  getGripType,
  rawCropString,
  sanitizeString,
  wrapRender,
  isGrip,
  ELLIPSIS,
  uneatLastUrlCharsRegex,
  urlRegex
} = __webpack_require__(2);

const dom = __webpack_require__(1);
const { a, span } = dom;

/**
 * Renders a string. String value is enclosed within quotes.
 */
StringRep.propTypes = {
  useQuotes: PropTypes.bool,
  escapeWhitespace: PropTypes.bool,
  style: PropTypes.object,
  cropLimit: PropTypes.number.isRequired,
  member: PropTypes.object,
  object: PropTypes.object.isRequired,
  openLink: PropTypes.func,
  className: PropTypes.string,
  title: PropTypes.string,
  isInContentPage: PropTypes.bool
};

function StringRep(props) {
  const {
    className,
    style,
    cropLimit,
    object,
    useQuotes = true,
    escapeWhitespace = true,
    member,
    openLink,
    title,
    isInContentPage
  } = props;

  let text = object;

  const isLong = isLongString(object);
  const isOpen = member && member.open;
  const shouldCrop = !isOpen && cropLimit && text.length > cropLimit;

  if (isLong) {
    text = maybeCropLongString({
      shouldCrop,
      cropLimit
    }, text);

    const { fullText } = object;
    if (isOpen && fullText) {
      text = fullText;
    }
  }

  text = formatText({
    useQuotes,
    escapeWhitespace
  }, text);

  const config = getElementConfig({
    className,
    style,
    actor: object.actor,
    title
  });

  if (!isLong) {
    if (containsURL(text)) {
      return span(config, ...getLinkifiedElements(text, shouldCrop && cropLimit, openLink, isInContentPage));
    }

    // Cropping of longString has been handled before formatting.
    text = maybeCropString({
      isLong,
      shouldCrop,
      cropLimit
    }, text);
  }

  return span(config, text);
}

function maybeCropLongString(opts, text) {
  const { shouldCrop, cropLimit } = opts;

  const { initial, length } = text;

  text = shouldCrop ? initial.substring(0, cropLimit) : initial;

  if (text.length < length) {
    text += ELLIPSIS;
  }

  return text;
}

function formatText(opts, text) {
  const { useQuotes, escapeWhitespace } = opts;

  return useQuotes ? escapeString(text, escapeWhitespace) : sanitizeString(text);
}

function getElementConfig(opts) {
  const { className, style, actor, title } = opts;

  const config = {};

  if (actor) {
    config["data-link-actor-id"] = actor;
  }

  if (title) {
    config.title = title;
  }

  const classNames = ["objectBox", "objectBox-string"];
  if (className) {
    classNames.push(className);
  }
  config.className = classNames.join(" ");

  if (style) {
    config.style = style;
  }

  return config;
}

function maybeCropString(opts, text) {
  const { shouldCrop, cropLimit } = opts;

  return shouldCrop ? rawCropString(text, cropLimit) : text;
}

/**
 * Get an array of the elements representing the string, cropped if needed,
 * with actual links.
 *
 * @param {String} text: The actual string to linkify.
 * @param {Integer | null} cropLimit
 * @param {Function} openLink: Function handling the link opening.
 * @param {Boolean} isInContentPage: pass true if the reps is rendered in
 *                                   the content page (e.g. in JSONViewer).
 * @returns {Array<String|ReactElement>}
 */
function getLinkifiedElements(text, cropLimit, openLink, isInContentPage) {
  const halfLimit = Math.ceil((cropLimit - ELLIPSIS.length) / 2);
  const startCropIndex = cropLimit ? halfLimit : null;
  const endCropIndex = cropLimit ? text.length - halfLimit : null;

  const items = [];
  let currentIndex = 0;
  let contentStart;
  while (true) {
    const url = urlRegex.exec(text);
    // Pick the regexp with the earlier content; index will always be zero.
    if (!url) {
      break;
    }
    contentStart = url.index + url[1].length;
    if (contentStart > 0) {
      const nonUrlText = text.substring(0, contentStart);
      items.push(getCroppedString(nonUrlText, currentIndex, startCropIndex, endCropIndex));
    }

    // There are some final characters for a URL that are much more likely
    // to have been part of the enclosing text rather than the end of the
    // URL.
    let useUrl = url[2];
    const uneat = uneatLastUrlCharsRegex.exec(useUrl);
    if (uneat) {
      useUrl = useUrl.substring(0, uneat.index);
    }

    currentIndex = currentIndex + contentStart;
    const linkText = getCroppedString(useUrl, currentIndex, startCropIndex, endCropIndex);

    if (linkText) {
      items.push(a({
        className: "url",
        title: useUrl,
        draggable: false,
        // Because we don't want the link to be open in the current
        // panel's frame, we only render the href attribute if `openLink`
        // exists (so we can preventDefault) or if the reps will be
        // displayed in content page (e.g. in the JSONViewer).
        href: openLink || isInContentPage ? useUrl : null,
        target: "_blank",
        onClick: openLink ? e => {
          e.preventDefault();
          openLink(useUrl, e);
        } : null
      }, linkText));
    }

    currentIndex = currentIndex + useUrl.length;
    text = text.substring(url.index + url[1].length + useUrl.length);
  }

  // Clean up any non-URL text at the end of the source string,
  // i.e. not handled in the loop.
  if (text.length > 0) {
    if (currentIndex < endCropIndex) {
      text = getCroppedString(text, currentIndex, startCropIndex, endCropIndex);
    }
    items.push(text);
  }

  return items;
}

/**
 * Returns a cropped substring given an offset, start and end crop indices in a
 * parent string.
 *
 * @param {String} text: The substring to crop.
 * @param {Integer} offset: The offset corresponding to the index at which
 *                          the substring is in the parent string.
 * @param {Integer|null} startCropIndex: the index where the start of the crop
 *                                       should happen in the parent string.
 * @param {Integer|null} endCropIndex: the index where the end of the crop
 *                                     should happen in the parent string
 * @returns {String|null} The cropped substring, or null if the text is
 *                        completly cropped.
 */
function getCroppedString(text, offset = 0, startCropIndex, endCropIndex) {
  if (!startCropIndex) {
    return text;
  }

  const start = offset;
  const end = offset + text.length;

  const shouldBeVisible = !(start >= startCropIndex && end <= endCropIndex);
  if (!shouldBeVisible) {
    return null;
  }

  const shouldCropEnd = start < startCropIndex && end > startCropIndex;
  const shouldCropStart = start < endCropIndex && end > endCropIndex;
  if (shouldCropEnd) {
    const cutIndex = startCropIndex - start;
    return text.substring(0, cutIndex) + ELLIPSIS + (shouldCropStart ? text.substring(endCropIndex - start) : "");
  }

  if (shouldCropStart) {
    // The string should be cropped at the beginning.
    const cutIndex = endCropIndex - start;
    return text.substring(cutIndex);
  }

  return text;
}

function isLongString(object) {
  return object && object.type === "longString";
}

function supportsObject(object, noGrip = false) {
  if (noGrip === false && isGrip(object)) {
    return isLongString(object);
  }

  return getGripType(object, noGrip) == "string";
}

// Exports from this module

module.exports = {
  rep: wrapRender(StringRep),
  supportsObject,
  isLongString
};

/***/ }),
/* 26 */,
/* 27 */,
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(18),
    isObjectLike = __webpack_require__(11);

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */,
/* 35 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 36 */
/***/ (function(module, exports) {

var charenc = {
  // UTF-8 encoding
  utf8: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
    }
  },

  // Binary encoding
  bin: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      for (var bytes = [], i = 0; i < str.length; i++)
        bytes.push(str.charCodeAt(i) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      for (var str = [], i = 0; i < bytes.length; i++)
        str.push(String.fromCharCode(bytes[i]));
      return str.join('');
    }
  }
};

module.exports = charenc;


/***/ }),
/* 37 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_37__;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// Dependencies
const dom = __webpack_require__(1);
const PropTypes = __webpack_require__(0);
const { wrapRender } = __webpack_require__(2);
const { MODE } = __webpack_require__(4);
const { span } = dom;

const ModePropType = PropTypes.oneOf(
// @TODO Change this to Object.values when supported in Node's version of V8
Object.keys(MODE).map(key => MODE[key]));

/**
 * Renders an array. The array is enclosed by left and right bracket
 * and the max number of rendered items depends on the current mode.
 */
ArrayRep.propTypes = {
  mode: ModePropType,
  object: PropTypes.array.isRequired
};

function ArrayRep(props) {
  const { object, mode = MODE.SHORT } = props;

  let items;
  let brackets;
  const needSpace = function (space) {
    return space ? { left: "[ ", right: " ]" } : { left: "[", right: "]" };
  };

  if (mode === MODE.TINY) {
    const isEmpty = object.length === 0;
    if (isEmpty) {
      items = [];
    } else {
      items = [span({
        className: "more-ellipsis",
        title: "more…"
      }, "…")];
    }
    brackets = needSpace(false);
  } else {
    items = arrayIterator(props, object, maxLengthMap.get(mode));
    brackets = needSpace(items.length > 0);
  }

  return span({
    className: "objectBox objectBox-array"
  }, span({
    className: "arrayLeftBracket"
  }, brackets.left), ...items, span({
    className: "arrayRightBracket"
  }, brackets.right));
}

function arrayIterator(props, array, max) {
  const items = [];

  for (let i = 0; i < array.length && i < max; i++) {
    const config = {
      mode: MODE.TINY,
      delim: i == array.length - 1 ? "" : ", "
    };
    let item;

    try {
      item = ItemRep({
        ...props,
        ...config,
        object: array[i]
      });
    } catch (exc) {
      item = ItemRep({
        ...props,
        ...config,
        object: exc
      });
    }
    items.push(item);
  }

  if (array.length > max) {
    items.push(span({
      className: "more-ellipsis",
      title: "more…"
    }, "…"));
  }

  return items;
}

/**
 * Renders array item. Individual values are separated by a comma.
 */
ItemRep.propTypes = {
  object: PropTypes.any.isRequired,
  delim: PropTypes.string.isRequired,
  mode: ModePropType
};

function ItemRep(props) {
  const { Rep } = __webpack_require__(24);

  const { object, delim, mode } = props;
  return span({}, Rep({
    ...props,
    object: object,
    mode: mode
  }), delim);
}

function getLength(object) {
  return object.length;
}

function supportsObject(object, noGrip = false) {
  return noGrip && (Array.isArray(object) || Object.prototype.toString.call(object) === "[object Arguments]");
}

const maxLengthMap = new Map();
maxLengthMap.set(MODE.SHORT, 3);
maxLengthMap.set(MODE.LONG, 10);

// Exports from this module
module.exports = {
  rep: wrapRender(ArrayRep),
  supportsObject,
  maxLengthMap,
  getLength,
  ModePropType
};

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// Dependencies
const PropTypes = __webpack_require__(0);
const { maybeEscapePropertyName, wrapRender } = __webpack_require__(2);
const { MODE } = __webpack_require__(4);

const { span } = __webpack_require__(1);

/**
 * Property for Obj (local JS objects), Grip (remote JS objects)
 * and GripMap (remote JS maps and weakmaps) reps.
 * It's used to render object properties.
 */
PropRep.propTypes = {
  // Property name.
  name: PropTypes.oneOfType([PropTypes.string, PropTypes.object]).isRequired,
  // Equal character rendered between property name and value.
  equal: PropTypes.string,
  // @TODO Change this to Object.values when supported in Node's version of V8
  mode: PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key])),
  onDOMNodeMouseOver: PropTypes.func,
  onDOMNodeMouseOut: PropTypes.func,
  onInspectIconClick: PropTypes.func,
  // Normally a PropRep will quote a property name that isn't valid
  // when unquoted; but this flag can be used to suppress the
  // quoting.
  suppressQuotes: PropTypes.bool
};

/**
 * Function that given a name, a delimiter and an object returns an array
 * of React elements representing an object property (e.g. `name: value`)
 *
 * @param {Object} props
 * @return {Array} Array of React elements.
 */
function PropRep(props) {
  const Grip = __webpack_require__(113);
  const { Rep } = __webpack_require__(24);

  let { name, mode, equal, suppressQuotes } = props;

  let key;
  // The key can be a simple string, for plain objects,
  // or another object for maps and weakmaps.
  if (typeof name === "string") {
    if (!suppressQuotes) {
      name = maybeEscapePropertyName(name);
    }
    key = span({ className: "nodeName" }, name);
  } else {
    key = Rep({
      ...props,
      className: "nodeName",
      object: name,
      mode: mode || MODE.TINY,
      defaultRep: Grip
    });
  }

  return [key, span({
    className: "objectEqual"
  }, equal), Rep({ ...props })];
}

// Exports from this module
module.exports = wrapRender(PropRep);

/***/ }),
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15)))

/***/ }),
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */,
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

var baseToString = __webpack_require__(95);

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


/***/ }),
/* 58 */,
/* 59 */,
/* 60 */,
/* 61 */,
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)(module), __webpack_require__(15)))

/***/ }),
/* 63 */,
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const md5 = __webpack_require__(105);

function originalToGeneratedId(sourceId) {
  if (isGeneratedId(sourceId)) {
    return sourceId;
  }

  const match = sourceId.match(/(.*)\/originalSource/);
  return match ? match[1] : "";
}

const getMd5 = memoize(url => md5(url));

function generatedToOriginalId(generatedId, url) {
  return `${generatedId}/originalSource-${getMd5(url)}`;
}

function isOriginalId(id) {
  return (/\/originalSource/.test(id)
  );
}

function isGeneratedId(id) {
  return !isOriginalId(id);
}

/**
 * Trims the query part or reference identifier of a URL string, if necessary.
 */
function trimUrlQuery(url) {
  const length = url.length;
  const q1 = url.indexOf("?");
  const q2 = url.indexOf("&");
  const q3 = url.indexOf("#");
  const q = Math.min(q1 != -1 ? q1 : length, q2 != -1 ? q2 : length, q3 != -1 ? q3 : length);

  return url.slice(0, q);
}

// Map suffix to content type.
const contentMap = {
  js: "text/javascript",
  jsm: "text/javascript",
  mjs: "text/javascript",
  ts: "text/typescript",
  tsx: "text/typescript-jsx",
  jsx: "text/jsx",
  vue: "text/vue",
  coffee: "text/coffeescript",
  elm: "text/elm",
  cljc: "text/x-clojure",
  cljs: "text/x-clojurescript"
};

/**
 * Returns the content type for the specified URL.  If no specific
 * content type can be determined, "text/plain" is returned.
 *
 * @return String
 *         The content type.
 */
function getContentType(url) {
  url = trimUrlQuery(url);
  const dot = url.lastIndexOf(".");
  if (dot >= 0) {
    const name = url.substring(dot + 1);
    if (name in contentMap) {
      return contentMap[name];
    }
  }
  return "text/plain";
}

function memoize(func) {
  const map = new Map();

  return arg => {
    if (map.has(arg)) {
      return map.get(arg);
    }

    const result = func(arg);
    map.set(arg, result);
    return result;
  };
}

module.exports = {
  originalToGeneratedId,
  generatedToOriginalId,
  isOriginalId,
  isGeneratedId,
  getContentType,
  contentMapForTesting: contentMap
};

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

var EventEmitter = function EventEmitter() {};
module.exports = EventEmitter;

const promise = __webpack_require__(422);

/**
 * Decorate an object with event emitter functionality.
 *
 * @param Object aObjectToDecorate
 *        Bind all public methods of EventEmitter to
 *        the aObjectToDecorate object.
 */
EventEmitter.decorate = function EventEmitter_decorate(aObjectToDecorate) {
  let emitter = new EventEmitter();
  aObjectToDecorate.on = emitter.on.bind(emitter);
  aObjectToDecorate.off = emitter.off.bind(emitter);
  aObjectToDecorate.once = emitter.once.bind(emitter);
  aObjectToDecorate.emit = emitter.emit.bind(emitter);
};

EventEmitter.prototype = {
  /**
   * Connect a listener.
   *
   * @param string aEvent
   *        The event name to which we're connecting.
   * @param function aListener
   *        Called when the event is fired.
   */
  on: function EventEmitter_on(aEvent, aListener) {
    if (!this._eventEmitterListeners) this._eventEmitterListeners = new Map();
    if (!this._eventEmitterListeners.has(aEvent)) {
      this._eventEmitterListeners.set(aEvent, []);
    }
    this._eventEmitterListeners.get(aEvent).push(aListener);
  },

  /**
   * Listen for the next time an event is fired.
   *
   * @param string aEvent
   *        The event name to which we're connecting.
   * @param function aListener
   *        (Optional) Called when the event is fired. Will be called at most
   *        one time.
   * @return promise
   *        A promise which is resolved when the event next happens. The
   *        resolution value of the promise is the first event argument. If
   *        you need access to second or subsequent event arguments (it's rare
   *        that this is needed) then use aListener
   */
  once: function EventEmitter_once(aEvent, aListener) {
    let deferred = promise.defer();

    let handler = (aEvent, aFirstArg, ...aRest) => {
      this.off(aEvent, handler);
      if (aListener) {
        aListener.apply(null, [aEvent, aFirstArg, ...aRest]);
      }
      deferred.resolve(aFirstArg);
    };

    handler._originalListener = aListener;
    this.on(aEvent, handler);

    return deferred.promise;
  },

  /**
   * Remove a previously-registered event listener.  Works for events
   * registered with either on or once.
   *
   * @param string aEvent
   *        The event name whose listener we're disconnecting.
   * @param function aListener
   *        The listener to remove.
   */
  off: function EventEmitter_off(aEvent, aListener) {
    if (!this._eventEmitterListeners) return;
    let listeners = this._eventEmitterListeners.get(aEvent);
    if (listeners) {
      this._eventEmitterListeners.set(aEvent, listeners.filter(l => {
        return l !== aListener && l._originalListener !== aListener;
      }));
    }
  },

  /**
   * Emit an event.  All arguments to this method will
   * be sent to listener functions.
   */
  emit: function EventEmitter_emit(aEvent) {
    if (!this._eventEmitterListeners || !this._eventEmitterListeners.has(aEvent)) {
      return;
    }

    let originalListeners = this._eventEmitterListeners.get(aEvent);
    for (let listener of this._eventEmitterListeners.get(aEvent)) {
      // If the object was destroyed during event emission, stop
      // emitting.
      if (!this._eventEmitterListeners) {
        break;
      }

      // If listeners were removed during emission, make sure the
      // event handler we're going to fire wasn't removed.
      if (originalListeners === this._eventEmitterListeners.get(aEvent) || this._eventEmitterListeners.get(aEvent).some(l => l === listener)) {
        try {
          listener.apply(null, arguments);
        } catch (ex) {
          // Prevent a bad listener from interfering with the others.
          let msg = ex + ": " + ex.stack;
          //console.error(msg);
          console.log(msg);
        }
      }
    }
  }
};

/***/ }),
/* 66 */
/***/ (function(module, exports) {

(function() {
  var AcronymResult, computeScore, emptyAcronymResult, isAcronymFullWord, isMatch, isSeparator, isWordEnd, isWordStart, miss_coeff, pos_bonus, scoreAcronyms, scoreCharacter, scoreConsecutives, scoreExact, scoreExactMatch, scorePattern, scorePosition, scoreSize, tau_size, wm;

  wm = 150;

  pos_bonus = 20;

  tau_size = 150;

  miss_coeff = 0.75;

  exports.score = function(string, query, options) {
    var allowErrors, preparedQuery, score, string_lw;
    preparedQuery = options.preparedQuery, allowErrors = options.allowErrors;
    if (!(allowErrors || isMatch(string, preparedQuery.core_lw, preparedQuery.core_up))) {
      return 0;
    }
    string_lw = string.toLowerCase();
    score = computeScore(string, string_lw, preparedQuery);
    return Math.ceil(score);
  };

  exports.isMatch = isMatch = function(subject, query_lw, query_up) {
    var i, j, m, n, qj_lw, qj_up, si;
    m = subject.length;
    n = query_lw.length;
    if (!m || n > m) {
      return false;
    }
    i = -1;
    j = -1;
    while (++j < n) {
      qj_lw = query_lw.charCodeAt(j);
      qj_up = query_up.charCodeAt(j);
      while (++i < m) {
        si = subject.charCodeAt(i);
        if (si === qj_lw || si === qj_up) {
          break;
        }
      }
      if (i === m) {
        return false;
      }
    }
    return true;
  };

  exports.computeScore = computeScore = function(subject, subject_lw, preparedQuery) {
    var acro, acro_score, align, csc_diag, csc_row, csc_score, csc_should_rebuild, i, j, m, miss_budget, miss_left, n, pos, query, query_lw, record_miss, score, score_diag, score_row, score_up, si_lw, start, sz;
    query = preparedQuery.query;
    query_lw = preparedQuery.query_lw;
    m = subject.length;
    n = query.length;
    acro = scoreAcronyms(subject, subject_lw, query, query_lw);
    acro_score = acro.score;
    if (acro.count === n) {
      return scoreExact(n, m, acro_score, acro.pos);
    }
    pos = subject_lw.indexOf(query_lw);
    if (pos > -1) {
      return scoreExactMatch(subject, subject_lw, query, query_lw, pos, n, m);
    }
    score_row = new Array(n);
    csc_row = new Array(n);
    sz = scoreSize(n, m);
    miss_budget = Math.ceil(miss_coeff * n) + 5;
    miss_left = miss_budget;
    csc_should_rebuild = true;
    j = -1;
    while (++j < n) {
      score_row[j] = 0;
      csc_row[j] = 0;
    }
    i = -1;
    while (++i < m) {
      si_lw = subject_lw[i];
      if (!si_lw.charCodeAt(0) in preparedQuery.charCodes) {
        if (csc_should_rebuild) {
          j = -1;
          while (++j < n) {
            csc_row[j] = 0;
          }
          csc_should_rebuild = false;
        }
        continue;
      }
      score = 0;
      score_diag = 0;
      csc_diag = 0;
      record_miss = true;
      csc_should_rebuild = true;
      j = -1;
      while (++j < n) {
        score_up = score_row[j];
        if (score_up > score) {
          score = score_up;
        }
        csc_score = 0;
        if (query_lw[j] === si_lw) {
          start = isWordStart(i, subject, subject_lw);
          csc_score = csc_diag > 0 ? csc_diag : scoreConsecutives(subject, subject_lw, query, query_lw, i, j, start);
          align = score_diag + scoreCharacter(i, j, start, acro_score, csc_score);
          if (align > score) {
            score = align;
            miss_left = miss_budget;
          } else {
            if (record_miss && --miss_left <= 0) {
              return Math.max(score, score_row[n - 1]) * sz;
            }
            record_miss = false;
          }
        }
        score_diag = score_up;
        csc_diag = csc_row[j];
        csc_row[j] = csc_score;
        score_row[j] = score;
      }
    }
    score = score_row[n - 1];
    return score * sz;
  };

  exports.isWordStart = isWordStart = function(pos, subject, subject_lw) {
    var curr_s, prev_s;
    if (pos === 0) {
      return true;
    }
    curr_s = subject[pos];
    prev_s = subject[pos - 1];
    return isSeparator(prev_s) || (curr_s !== subject_lw[pos] && prev_s === subject_lw[pos - 1]);
  };

  exports.isWordEnd = isWordEnd = function(pos, subject, subject_lw, len) {
    var curr_s, next_s;
    if (pos === len - 1) {
      return true;
    }
    curr_s = subject[pos];
    next_s = subject[pos + 1];
    return isSeparator(next_s) || (curr_s === subject_lw[pos] && next_s !== subject_lw[pos + 1]);
  };

  isSeparator = function(c) {
    return c === ' ' || c === '.' || c === '-' || c === '_' || c === '/' || c === '\\';
  };

  scorePosition = function(pos) {
    var sc;
    if (pos < pos_bonus) {
      sc = pos_bonus - pos;
      return 100 + sc * sc;
    } else {
      return Math.max(100 + pos_bonus - pos, 0);
    }
  };

  exports.scoreSize = scoreSize = function(n, m) {
    return tau_size / (tau_size + Math.abs(m - n));
  };

  scoreExact = function(n, m, quality, pos) {
    return 2 * n * (wm * quality + scorePosition(pos)) * scoreSize(n, m);
  };

  exports.scorePattern = scorePattern = function(count, len, sameCase, start, end) {
    var bonus, sz;
    sz = count;
    bonus = 6;
    if (sameCase === count) {
      bonus += 2;
    }
    if (start) {
      bonus += 3;
    }
    if (end) {
      bonus += 1;
    }
    if (count === len) {
      if (start) {
        if (sameCase === len) {
          sz += 2;
        } else {
          sz += 1;
        }
      }
      if (end) {
        bonus += 1;
      }
    }
    return sameCase + sz * (sz + bonus);
  };

  exports.scoreCharacter = scoreCharacter = function(i, j, start, acro_score, csc_score) {
    var posBonus;
    posBonus = scorePosition(i);
    if (start) {
      return posBonus + wm * ((acro_score > csc_score ? acro_score : csc_score) + 10);
    }
    return posBonus + wm * csc_score;
  };

  exports.scoreConsecutives = scoreConsecutives = function(subject, subject_lw, query, query_lw, i, j, startOfWord) {
    var k, m, mi, n, nj, sameCase, sz;
    m = subject.length;
    n = query.length;
    mi = m - i;
    nj = n - j;
    k = mi < nj ? mi : nj;
    sameCase = 0;
    sz = 0;
    if (query[j] === subject[i]) {
      sameCase++;
    }
    while (++sz < k && query_lw[++j] === subject_lw[++i]) {
      if (query[j] === subject[i]) {
        sameCase++;
      }
    }
    if (sz < k) {
      i--;
    }
    if (sz === 1) {
      return 1 + 2 * sameCase;
    }
    return scorePattern(sz, n, sameCase, startOfWord, isWordEnd(i, subject, subject_lw, m));
  };

  exports.scoreExactMatch = scoreExactMatch = function(subject, subject_lw, query, query_lw, pos, n, m) {
    var end, i, pos2, sameCase, start;
    start = isWordStart(pos, subject, subject_lw);
    if (!start) {
      pos2 = subject_lw.indexOf(query_lw, pos + 1);
      if (pos2 > -1) {
        start = isWordStart(pos2, subject, subject_lw);
        if (start) {
          pos = pos2;
        }
      }
    }
    i = -1;
    sameCase = 0;
    while (++i < n) {
      if (query[pos + i] === subject[i]) {
        sameCase++;
      }
    }
    end = isWordEnd(pos + n - 1, subject, subject_lw, m);
    return scoreExact(n, m, scorePattern(n, n, sameCase, start, end), pos);
  };

  AcronymResult = (function() {
    function AcronymResult(score, pos, count) {
      this.score = score;
      this.pos = pos;
      this.count = count;
    }

    return AcronymResult;

  })();

  emptyAcronymResult = new AcronymResult(0, 0.1, 0);

  exports.scoreAcronyms = scoreAcronyms = function(subject, subject_lw, query, query_lw) {
    var count, fullWord, i, j, m, n, qj_lw, sameCase, score, sepCount, sumPos;
    m = subject.length;
    n = query.length;
    if (!(m > 1 && n > 1)) {
      return emptyAcronymResult;
    }
    count = 0;
    sepCount = 0;
    sumPos = 0;
    sameCase = 0;
    i = -1;
    j = -1;
    while (++j < n) {
      qj_lw = query_lw[j];
      if (isSeparator(qj_lw)) {
        i = subject_lw.indexOf(qj_lw, i + 1);
        if (i > -1) {
          sepCount++;
          continue;
        } else {
          break;
        }
      }
      while (++i < m) {
        if (qj_lw === subject_lw[i] && isWordStart(i, subject, subject_lw)) {
          if (query[j] === subject[i]) {
            sameCase++;
          }
          sumPos += i;
          count++;
          break;
        }
      }
      if (i === m) {
        break;
      }
    }
    if (count < 2) {
      return emptyAcronymResult;
    }
    fullWord = count === n ? isAcronymFullWord(subject, subject_lw, query, count) : false;
    score = scorePattern(count, n, sameCase, true, fullWord);
    return new AcronymResult(score, sumPos / count, count + sepCount);
  };

  isAcronymFullWord = function(subject, subject_lw, query, nbAcronymInQuery) {
    var count, i, m, n;
    m = subject.length;
    n = query.length;
    count = 0;
    if (m > 12 * n) {
      return false;
    }
    i = -1;
    while (++i < m) {
      if (isWordStart(i, subject, subject_lw) && ++count > nbAcronymInQuery) {
        return false;
      }
    }
    return true;
  };

}).call(this);


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg) && arg.length) {
				var inner = classNames.apply(null, arg);
				if (inner) {
					classes.push(inner);
				}
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return classNames;
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {
		window.classNames = classNames;
	}
}());


/***/ }),
/* 68 */,
/* 69 */,
/* 70 */,
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(19);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),
/* 72 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */,
/* 77 */,
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(19),
    arrayMap = __webpack_require__(96),
    isArray = __webpack_require__(9),
    isSymbol = __webpack_require__(28);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


/***/ }),
/* 96 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const flag = __webpack_require__(103);

function isBrowser() {
  return typeof window == "object";
}

function isNode() {
  return process && process.release && process.release.name == 'node';
}

function isDevelopment() {
  if (!isNode() && isBrowser()) {
    const href = window.location ? window.location.href : "";
    return href.match(/^file:/) || href.match(/localhost:/);
  }

  return "production" != "production";
}

function isTesting() {
  return flag.testing;
}

function isFirefoxPanel() {
  return !isDevelopment();
}

function isFirefox() {
  return (/firefox/i.test(navigator.userAgent)
  );
}

module.exports = {
  isDevelopment,
  isTesting,
  isFirefoxPanel,
  isFirefox
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(35)))

/***/ }),
/* 103 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_103__;

/***/ }),
/* 104 */,
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

(function(){
  var crypt = __webpack_require__(106),
      utf8 = __webpack_require__(36).utf8,
      isBuffer = __webpack_require__(107),
      bin = __webpack_require__(36).bin,

  // The core
  md5 = function (message, options) {
    // Convert to byte array
    if (message.constructor == String)
      if (options && options.encoding === 'binary')
        message = bin.stringToBytes(message);
      else
        message = utf8.stringToBytes(message);
    else if (isBuffer(message))
      message = Array.prototype.slice.call(message, 0);
    else if (!Array.isArray(message))
      message = message.toString();
    // else, assume byte array already

    var m = crypt.bytesToWords(message),
        l = message.length * 8,
        a =  1732584193,
        b = -271733879,
        c = -1732584194,
        d =  271733878;

    // Swap endian
    for (var i = 0; i < m.length; i++) {
      m[i] = ((m[i] <<  8) | (m[i] >>> 24)) & 0x00FF00FF |
             ((m[i] << 24) | (m[i] >>>  8)) & 0xFF00FF00;
    }

    // Padding
    m[l >>> 5] |= 0x80 << (l % 32);
    m[(((l + 64) >>> 9) << 4) + 14] = l;

    // Method shortcuts
    var FF = md5._ff,
        GG = md5._gg,
        HH = md5._hh,
        II = md5._ii;

    for (var i = 0; i < m.length; i += 16) {

      var aa = a,
          bb = b,
          cc = c,
          dd = d;

      a = FF(a, b, c, d, m[i+ 0],  7, -680876936);
      d = FF(d, a, b, c, m[i+ 1], 12, -389564586);
      c = FF(c, d, a, b, m[i+ 2], 17,  606105819);
      b = FF(b, c, d, a, m[i+ 3], 22, -1044525330);
      a = FF(a, b, c, d, m[i+ 4],  7, -176418897);
      d = FF(d, a, b, c, m[i+ 5], 12,  1200080426);
      c = FF(c, d, a, b, m[i+ 6], 17, -1473231341);
      b = FF(b, c, d, a, m[i+ 7], 22, -45705983);
      a = FF(a, b, c, d, m[i+ 8],  7,  1770035416);
      d = FF(d, a, b, c, m[i+ 9], 12, -1958414417);
      c = FF(c, d, a, b, m[i+10], 17, -42063);
      b = FF(b, c, d, a, m[i+11], 22, -1990404162);
      a = FF(a, b, c, d, m[i+12],  7,  1804603682);
      d = FF(d, a, b, c, m[i+13], 12, -40341101);
      c = FF(c, d, a, b, m[i+14], 17, -1502002290);
      b = FF(b, c, d, a, m[i+15], 22,  1236535329);

      a = GG(a, b, c, d, m[i+ 1],  5, -165796510);
      d = GG(d, a, b, c, m[i+ 6],  9, -1069501632);
      c = GG(c, d, a, b, m[i+11], 14,  643717713);
      b = GG(b, c, d, a, m[i+ 0], 20, -373897302);
      a = GG(a, b, c, d, m[i+ 5],  5, -701558691);
      d = GG(d, a, b, c, m[i+10],  9,  38016083);
      c = GG(c, d, a, b, m[i+15], 14, -660478335);
      b = GG(b, c, d, a, m[i+ 4], 20, -405537848);
      a = GG(a, b, c, d, m[i+ 9],  5,  568446438);
      d = GG(d, a, b, c, m[i+14],  9, -1019803690);
      c = GG(c, d, a, b, m[i+ 3], 14, -187363961);
      b = GG(b, c, d, a, m[i+ 8], 20,  1163531501);
      a = GG(a, b, c, d, m[i+13],  5, -1444681467);
      d = GG(d, a, b, c, m[i+ 2],  9, -51403784);
      c = GG(c, d, a, b, m[i+ 7], 14,  1735328473);
      b = GG(b, c, d, a, m[i+12], 20, -1926607734);

      a = HH(a, b, c, d, m[i+ 5],  4, -378558);
      d = HH(d, a, b, c, m[i+ 8], 11, -2022574463);
      c = HH(c, d, a, b, m[i+11], 16,  1839030562);
      b = HH(b, c, d, a, m[i+14], 23, -35309556);
      a = HH(a, b, c, d, m[i+ 1],  4, -1530992060);
      d = HH(d, a, b, c, m[i+ 4], 11,  1272893353);
      c = HH(c, d, a, b, m[i+ 7], 16, -155497632);
      b = HH(b, c, d, a, m[i+10], 23, -1094730640);
      a = HH(a, b, c, d, m[i+13],  4,  681279174);
      d = HH(d, a, b, c, m[i+ 0], 11, -358537222);
      c = HH(c, d, a, b, m[i+ 3], 16, -722521979);
      b = HH(b, c, d, a, m[i+ 6], 23,  76029189);
      a = HH(a, b, c, d, m[i+ 9],  4, -640364487);
      d = HH(d, a, b, c, m[i+12], 11, -421815835);
      c = HH(c, d, a, b, m[i+15], 16,  530742520);
      b = HH(b, c, d, a, m[i+ 2], 23, -995338651);

      a = II(a, b, c, d, m[i+ 0],  6, -198630844);
      d = II(d, a, b, c, m[i+ 7], 10,  1126891415);
      c = II(c, d, a, b, m[i+14], 15, -1416354905);
      b = II(b, c, d, a, m[i+ 5], 21, -57434055);
      a = II(a, b, c, d, m[i+12],  6,  1700485571);
      d = II(d, a, b, c, m[i+ 3], 10, -1894986606);
      c = II(c, d, a, b, m[i+10], 15, -1051523);
      b = II(b, c, d, a, m[i+ 1], 21, -2054922799);
      a = II(a, b, c, d, m[i+ 8],  6,  1873313359);
      d = II(d, a, b, c, m[i+15], 10, -30611744);
      c = II(c, d, a, b, m[i+ 6], 15, -1560198380);
      b = II(b, c, d, a, m[i+13], 21,  1309151649);
      a = II(a, b, c, d, m[i+ 4],  6, -145523070);
      d = II(d, a, b, c, m[i+11], 10, -1120210379);
      c = II(c, d, a, b, m[i+ 2], 15,  718787259);
      b = II(b, c, d, a, m[i+ 9], 21, -343485551);

      a = (a + aa) >>> 0;
      b = (b + bb) >>> 0;
      c = (c + cc) >>> 0;
      d = (d + dd) >>> 0;
    }

    return crypt.endian([a, b, c, d]);
  };

  // Auxiliary functions
  md5._ff  = function (a, b, c, d, x, s, t) {
    var n = a + (b & c | ~b & d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._gg  = function (a, b, c, d, x, s, t) {
    var n = a + (b & d | c & ~d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._hh  = function (a, b, c, d, x, s, t) {
    var n = a + (b ^ c ^ d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._ii  = function (a, b, c, d, x, s, t) {
    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };

  // Package private blocksize
  md5._blocksize = 16;
  md5._digestsize = 16;

  module.exports = function (message, options) {
    if (message === undefined || message === null)
      throw new Error('Illegal argument ' + message);

    var digestbytes = crypt.wordsToBytes(md5(message, options));
    return options && options.asBytes ? digestbytes :
        options && options.asString ? bin.bytesToString(digestbytes) :
        crypt.bytesToHex(digestbytes);
  };

})();


/***/ }),
/* 106 */
/***/ (function(module, exports) {

(function() {
  var base64map
      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',

  crypt = {
    // Bit-wise rotation left
    rotl: function(n, b) {
      return (n << b) | (n >>> (32 - b));
    },

    // Bit-wise rotation right
    rotr: function(n, b) {
      return (n << (32 - b)) | (n >>> b);
    },

    // Swap big-endian to little-endian and vice versa
    endian: function(n) {
      // If number given, swap endian
      if (n.constructor == Number) {
        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;
      }

      // Else, assume array and swap all items
      for (var i = 0; i < n.length; i++)
        n[i] = crypt.endian(n[i]);
      return n;
    },

    // Generate an array of any length of random bytes
    randomBytes: function(n) {
      for (var bytes = []; n > 0; n--)
        bytes.push(Math.floor(Math.random() * 256));
      return bytes;
    },

    // Convert a byte array to big-endian 32-bit words
    bytesToWords: function(bytes) {
      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
        words[b >>> 5] |= bytes[i] << (24 - b % 32);
      return words;
    },

    // Convert big-endian 32-bit words to a byte array
    wordsToBytes: function(words) {
      for (var bytes = [], b = 0; b < words.length * 32; b += 8)
        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a hex string
    bytesToHex: function(bytes) {
      for (var hex = [], i = 0; i < bytes.length; i++) {
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 0xF).toString(16));
      }
      return hex.join('');
    },

    // Convert a hex string to a byte array
    hexToBytes: function(hex) {
      for (var bytes = [], c = 0; c < hex.length; c += 2)
        bytes.push(parseInt(hex.substr(c, 2), 16));
      return bytes;
    },

    // Convert a byte array to a base-64 string
    bytesToBase64: function(bytes) {
      for (var base64 = [], i = 0; i < bytes.length; i += 3) {
        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
        for (var j = 0; j < 4; j++)
          if (i * 8 + j * 6 <= bytes.length * 8)
            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));
          else
            base64.push('=');
      }
      return base64.join('');
    },

    // Convert a base-64 string to a byte array
    base64ToBytes: function(base64) {
      // Remove non-base-64 characters
      base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');

      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;
          imod4 = ++i % 4) {
        if (imod4 == 0) continue;
        bytes.push(((base64map.indexOf(base64.charAt(i - 1))
            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))
            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
      }
      return bytes;
    }
  };

  module.exports = crypt;
})();


/***/ }),
/* 107 */
/***/ (function(module, exports) {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _tree = __webpack_require__(109);

var _tree2 = _interopRequireDefault(_tree);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = {
  Tree: _tree2.default
}; /* This Source Code Form is subject to the terms of the Mozilla Public
    * License, v. 2.0. If a copy of the MPL was not distributed with this
    * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _reactDomFactories = __webpack_require__(1);

var _reactDomFactories2 = _interopRequireDefault(_reactDomFactories);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const { Component, createFactory } = _react2.default; /* This Source Code Form is subject to the terms of the Mozilla Public
                                                       * License, v. 2.0. If a copy of the MPL was not distributed with this
                                                       * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

__webpack_require__(110);

// depth
const AUTO_EXPAND_DEPTH = 0;

// Simplied selector targetting elements that can receive the focus,
// full version at https://stackoverflow.com/questions/1599660.
const FOCUSABLE_SELECTOR = ["a[href]:not([tabindex='-1'])", "button:not([disabled]):not([tabindex='-1'])", "iframe:not([tabindex='-1'])", "input:not([disabled]):not([tabindex='-1'])", "select:not([disabled]):not([tabindex='-1'])", "textarea:not([disabled]):not([tabindex='-1'])", "[tabindex]:not([tabindex='-1'])"].join(", ");

/**
 * An arrow that displays whether its node is expanded (▼) or collapsed
 * (▶). When its node has no children, it is hidden.
 */
class ArrowExpander extends Component {
  static get propTypes() {
    return {
      expanded: _propTypes2.default.bool
    };
  }

  shouldComponentUpdate(nextProps, nextState) {
    return this.props.expanded !== nextProps.expanded;
  }

  render() {
    const { expanded } = this.props;

    const classNames = ["arrow"];
    if (expanded) {
      classNames.push("expanded");
    }
    return _reactDomFactories2.default.button({
      className: classNames.join(" ")
    });
  }
}

const treeIndent = _reactDomFactories2.default.span({ className: "tree-indent" }, "\u200B");

class TreeNode extends Component {
  static get propTypes() {
    return {
      id: _propTypes2.default.any.isRequired,
      index: _propTypes2.default.number.isRequired,
      depth: _propTypes2.default.number.isRequired,
      focused: _propTypes2.default.bool.isRequired,
      active: _propTypes2.default.bool.isRequired,
      expanded: _propTypes2.default.bool.isRequired,
      item: _propTypes2.default.any.isRequired,
      isExpandable: _propTypes2.default.bool.isRequired,
      onClick: _propTypes2.default.func,
      shouldItemUpdate: _propTypes2.default.func,
      renderItem: _propTypes2.default.func.isRequired
    };
  }

  constructor(props) {
    super(props);

    this.treeNodeRef = _react2.default.createRef();

    this._onKeyDown = this._onKeyDown.bind(this);
  }

  componentDidMount() {
    // Make sure that none of the focusable elements inside the tree node
    // container are tabbable if the tree node is not active. If the tree node
    // is active and focus is outside its container, focus on the first
    // focusable element inside.
    const elms = this.getFocusableElements();
    if (this.props.active) {
      if (elms.length > 0 && !elms.includes(document.activeElement)) {
        elms[0].focus();
      }
    } else {
      elms.forEach(elm => elm.setAttribute("tabindex", "-1"));
    }
  }

  shouldComponentUpdate(nextProps) {
    return this.props.item !== nextProps.item || this.props.shouldItemUpdate && this.props.shouldItemUpdate(this.props.item, nextProps.item) || this.props.focused !== nextProps.focused || this.props.expanded !== nextProps.expanded;
  }

  /**
   * Get a list of all elements that are focusable with a keyboard inside the
   * tree node.
   */
  getFocusableElements() {
    return this.treeNodeRef.current ? Array.from(this.treeNodeRef.current.querySelectorAll(FOCUSABLE_SELECTOR)) : [];
  }

  /**
   * Wrap and move keyboard focus to first/last focusable element inside the
   * tree node to prevent the focus from escaping the tree node boundaries.
   * element).
   *
   * @param  {DOMNode} current  currently focused element
   * @param  {Boolean} back     direction
   * @return {Boolean}          true there is a newly focused element.
   */
  _wrapMoveFocus(current, back) {
    const elms = this.getFocusableElements();
    let next;

    if (elms.length === 0) {
      return false;
    }

    if (back) {
      if (elms.indexOf(current) === 0) {
        next = elms[elms.length - 1];
        next.focus();
      }
    } else if (elms.indexOf(current) === elms.length - 1) {
      next = elms[0];
      next.focus();
    }

    return !!next;
  }

  _onKeyDown(e) {
    const { target, key, shiftKey } = e;

    if (key !== "Tab") {
      return;
    }

    const focusMoved = this._wrapMoveFocus(target, shiftKey);
    if (focusMoved) {
      // Focus was moved to the begining/end of the list, so we need to prevent
      // the default focus change that would happen here.
      e.preventDefault();
    }

    e.stopPropagation();
  }

  render() {
    const {
      depth,
      id,
      item,
      focused,
      active,
      expanded,
      renderItem,
      isExpandable
    } = this.props;

    const arrow = isExpandable ? ArrowExpanderFactory({
      item,
      expanded
    }) : null;

    let ariaExpanded;
    if (this.props.isExpandable) {
      ariaExpanded = false;
    }
    if (this.props.expanded) {
      ariaExpanded = true;
    }

    const indents = Array.from({ length: depth }).fill(treeIndent);
    const items = indents.concat(renderItem(item, depth, focused, arrow, expanded));

    return _reactDomFactories2.default.div({
      id,
      className: `tree-node${focused ? " focused" : ""}${active ? " active" : ""}`,
      onClick: this.props.onClick,
      onKeyDownCapture: active ? this._onKeyDown : null,
      role: "treeitem",
      ref: this.treeNodeRef,
      "aria-level": depth + 1,
      "aria-expanded": ariaExpanded,
      "data-expandable": this.props.isExpandable
    }, ...items);
  }
}

const ArrowExpanderFactory = createFactory(ArrowExpander);
const TreeNodeFactory = createFactory(TreeNode);

/**
 * Create a function that calls the given function `fn` only once per animation
 * frame.
 *
 * @param {Function} fn
 * @returns {Function}
 */
function oncePerAnimationFrame(fn) {
  let animationId = null;
  let argsToPass = null;
  return function (...args) {
    argsToPass = args;
    if (animationId !== null) {
      return;
    }

    animationId = requestAnimationFrame(() => {
      fn.call(this, ...argsToPass);
      animationId = null;
      argsToPass = null;
    });
  };
}

/**
 * A generic tree component. See propTypes for the public API.
 *
 * This tree component doesn't make any assumptions about the structure of your
 * tree data. Whether children are computed on demand, or stored in an array in
 * the parent's `_children` property, it doesn't matter. We only require the
 * implementation of `getChildren`, `getRoots`, `getParent`, and `isExpanded`
 * functions.
 *
 * This tree component is well tested and reliable. See the tests in ./tests
 * and its usage in the performance and memory panels in mozilla-central.
 *
 * This tree component doesn't make any assumptions about how to render items in
 * the tree. You provide a `renderItem` function, and this component will ensure
 * that only those items whose parents are expanded and which are visible in the
 * viewport are rendered. The `renderItem` function could render the items as a
 * "traditional" tree or as rows in a table or anything else. It doesn't
 * restrict you to only one certain kind of tree.
 *
 * The tree comes with basic styling for the indent, the arrow, as well as
 * hovered and focused styles which can be override in CSS.
 *
 * ### Example Usage
 *
 * Suppose we have some tree data where each item has this form:
 *
 *     {
 *       id: Number,
 *       label: String,
 *       parent: Item or null,
 *       children: Array of child items,
 *       expanded: bool,
 *     }
 *
 * Here is how we could render that data with this component:
 *
 *     class MyTree extends Component {
 *       static get propTypes() {
 *         // The root item of the tree, with the form described above.
 *         return {
 *           root: PropTypes.object.isRequired
 *         };
 *       },
 *
 *       render() {
 *         return Tree({
 *           itemHeight: 20, // px
 *
 *           getRoots: () => [this.props.root],
 *
 *           getParent: item => item.parent,
 *           getChildren: item => item.children,
 *           getKey: item => item.id,
 *           isExpanded: item => item.expanded,
 *
 *           renderItem: (item, depth, isFocused, arrow, isExpanded) => {
 *             let className = "my-tree-item";
 *             if (isFocused) {
 *               className += " focused";
 *             }
 *             return dom.div({
 *               className,
 *             },
 *               arrow,
 *               // And here is the label for this item.
 *               dom.span({ className: "my-tree-item-label" }, item.label)
 *             );
 *           },
 *
 *           onExpand: item => dispatchExpandActionToRedux(item),
 *           onCollapse: item => dispatchCollapseActionToRedux(item),
 *         });
 *       }
 *     }
 */
class Tree extends Component {
  static get propTypes() {
    return {
      // Required props

      // A function to get an item's parent, or null if it is a root.
      //
      // Type: getParent(item: Item) -> Maybe<Item>
      //
      // Example:
      //
      //     // The parent of this item is stored in its `parent` property.
      //     getParent: item => item.parent
      getParent: _propTypes2.default.func.isRequired,

      // A function to get an item's children.
      //
      // Type: getChildren(item: Item) -> [Item]
      //
      // Example:
      //
      //     // This item's children are stored in its `children` property.
      //     getChildren: item => item.children
      getChildren: _propTypes2.default.func.isRequired,

      // A function to check if the tree node for the item should be updated.
      //
      // Type: shouldItemUpdate(prevItem: Item, nextItem: Item) -> Boolean
      //
      // Example:
      //
      //     // This item should be updated if it's type is a long string
      //     shouldItemUpdate: (prevItem, nextItem) =>
      //       nextItem.type === "longstring"
      shouldItemUpdate: _propTypes2.default.func,

      // A function which takes an item and ArrowExpander component instance and
      // returns a component, or text, or anything else that React considers
      // renderable.
      //
      // Type: renderItem(item: Item,
      //                  depth: Number,
      //                  isFocused: Boolean,
      //                  arrow: ReactComponent,
      //                  isExpanded: Boolean) -> ReactRenderable
      //
      // Example:
      //
      //     renderItem: (item, depth, isFocused, arrow, isExpanded) => {
      //       let className = "my-tree-item";
      //       if (isFocused) {
      //         className += " focused";
      //       }
      //       return dom.div(
      //         {
      //           className,
      //           style: { marginLeft: depth * 10 + "px" }
      //         },
      //         arrow,
      //         dom.span({ className: "my-tree-item-label" }, item.label)
      //       );
      //     },
      renderItem: _propTypes2.default.func.isRequired,

      // A function which returns the roots of the tree (forest).
      //
      // Type: getRoots() -> [Item]
      //
      // Example:
      //
      //     // In this case, we only have one top level, root item. You could
      //     // return multiple items if you have many top level items in your
      //     // tree.
      //     getRoots: () => [this.props.rootOfMyTree]
      getRoots: _propTypes2.default.func.isRequired,

      // A function to get a unique key for the given item. This helps speed up
      // React's rendering a *TON*.
      //
      // Type: getKey(item: Item) -> String
      //
      // Example:
      //
      //     getKey: item => `my-tree-item-${item.uniqueId}`
      getKey: _propTypes2.default.func.isRequired,

      // A function to get whether an item is expanded or not. If an item is not
      // expanded, then it must be collapsed.
      //
      // Type: isExpanded(item: Item) -> Boolean
      //
      // Example:
      //
      //     isExpanded: item => item.expanded,
      isExpanded: _propTypes2.default.func.isRequired,

      // Optional props

      // The currently focused item, if any such item exists.
      focused: _propTypes2.default.any,

      // Handle when a new item is focused.
      onFocus: _propTypes2.default.func,

      // The depth to which we should automatically expand new items.
      autoExpandDepth: _propTypes2.default.number,
      // Should auto expand all new items or just the new items under the first
      // root item.
      autoExpandAll: _propTypes2.default.bool,

      // Auto expand a node only if number of its children
      // are less than autoExpandNodeChildrenLimit
      autoExpandNodeChildrenLimit: _propTypes2.default.number,

      // Note: the two properties below are mutually exclusive. Only one of the
      // label properties is necessary.
      // ID of an element whose textual content serves as an accessible label
      // for a tree.
      labelledby: _propTypes2.default.string,
      // Accessibility label for a tree widget.
      label: _propTypes2.default.string,

      // Optional event handlers for when items are expanded or collapsed.
      // Useful for dispatching redux events and updating application state,
      // maybe lazily loading subtrees from a worker, etc.
      //
      // Type:
      //     onExpand(item: Item)
      //     onCollapse(item: Item)
      //
      // Example:
      //
      //     onExpand: item => dispatchExpandActionToRedux(item)
      onExpand: _propTypes2.default.func,
      onCollapse: _propTypes2.default.func,
      // The currently active (keyboard) item, if any such item exists.
      active: _propTypes2.default.any,
      // Optional event handler called with the current focused node when the
      // Enter key is pressed. Can be useful to allow further keyboard actions
      // within the tree node.
      onActivate: _propTypes2.default.func,
      isExpandable: _propTypes2.default.func,
      // Additional classes to add to the root element.
      className: _propTypes2.default.string,
      // style object to be applied to the root element.
      style: _propTypes2.default.object,
      // Prevents blur when Tree loses focus
      preventBlur: _propTypes2.default.bool
    };
  }

  static get defaultProps() {
    return {
      autoExpandDepth: AUTO_EXPAND_DEPTH,
      autoExpandAll: true
    };
  }

  constructor(props) {
    super(props);

    this.state = {
      seen: new Set()
    };

    this.treeRef = _react2.default.createRef();

    this._onExpand = oncePerAnimationFrame(this._onExpand).bind(this);
    this._onCollapse = oncePerAnimationFrame(this._onCollapse).bind(this);
    this._focusPrevNode = oncePerAnimationFrame(this._focusPrevNode).bind(this);
    this._focusNextNode = oncePerAnimationFrame(this._focusNextNode).bind(this);
    this._focusParentNode = oncePerAnimationFrame(this._focusParentNode).bind(this);
    this._focusFirstNode = oncePerAnimationFrame(this._focusFirstNode).bind(this);
    this._focusLastNode = oncePerAnimationFrame(this._focusLastNode).bind(this);

    this._autoExpand = this._autoExpand.bind(this);
    this._preventArrowKeyScrolling = this._preventArrowKeyScrolling.bind(this);
    this._preventEvent = this._preventEvent.bind(this);
    this._dfs = this._dfs.bind(this);
    this._dfsFromRoots = this._dfsFromRoots.bind(this);
    this._focus = this._focus.bind(this);
    this._activate = this._activate.bind(this);
    this._scrollNodeIntoView = this._scrollNodeIntoView.bind(this);
    this._onBlur = this._onBlur.bind(this);
    this._onKeyDown = this._onKeyDown.bind(this);
    this._nodeIsExpandable = this._nodeIsExpandable.bind(this);
  }

  componentDidMount() {
    this._autoExpand();
    if (this.props.focused) {
      this._scrollNodeIntoView(this.props.focused);
    }
  }

  componentWillReceiveProps(nextProps) {
    this._autoExpand();
  }

  componentDidUpdate(prevProps, prevState) {
    if (this.props.focused && prevProps.focused !== this.props.focused) {
      this._scrollNodeIntoView(this.props.focused);
    }
  }

  _autoExpand() {
    const { autoExpandDepth, autoExpandNodeChildrenLimit } = this.props;
    if (!autoExpandDepth) {
      return;
    }

    // Automatically expand the first autoExpandDepth levels for new items. Do
    // not use the usual DFS infrastructure because we don't want to ignore
    // collapsed nodes.
    const autoExpand = (item, currentDepth) => {
      if (currentDepth >= autoExpandDepth || this.state.seen.has(item)) {
        return;
      }

      const children = this.props.getChildren(item);
      if (autoExpandNodeChildrenLimit && children.length > autoExpandNodeChildrenLimit) {
        return;
      }

      this.props.onExpand(item);
      this.state.seen.add(item);

      const length = children.length;
      for (let i = 0; i < length; i++) {
        autoExpand(children[i], currentDepth + 1);
      }
    };

    const roots = this.props.getRoots();
    const length = roots.length;
    if (this.props.autoExpandAll) {
      for (let i = 0; i < length; i++) {
        autoExpand(roots[i], 0);
      }
    } else if (length != 0) {
      autoExpand(roots[0], 0);
    }
  }

  _preventArrowKeyScrolling(e) {
    switch (e.key) {
      case "ArrowUp":
      case "ArrowDown":
      case "ArrowLeft":
      case "ArrowRight":
        this._preventEvent(e);
        break;
    }
  }

  _preventEvent(e) {
    e.preventDefault();
    e.stopPropagation();
    if (e.nativeEvent) {
      if (e.nativeEvent.preventDefault) {
        e.nativeEvent.preventDefault();
      }
      if (e.nativeEvent.stopPropagation) {
        e.nativeEvent.stopPropagation();
      }
    }
  }

  /**
   * Perform a pre-order depth-first search from item.
   */
  _dfs(item, maxDepth = Infinity, traversal = [], _depth = 0) {
    traversal.push({ item, depth: _depth });

    if (!this.props.isExpanded(item)) {
      return traversal;
    }

    const nextDepth = _depth + 1;

    if (nextDepth > maxDepth) {
      return traversal;
    }

    const children = this.props.getChildren(item);
    const length = children.length;
    for (let i = 0; i < length; i++) {
      this._dfs(children[i], maxDepth, traversal, nextDepth);
    }

    return traversal;
  }

  /**
   * Perform a pre-order depth-first search over the whole forest.
   */
  _dfsFromRoots(maxDepth = Infinity) {
    const traversal = [];

    const roots = this.props.getRoots();
    const length = roots.length;
    for (let i = 0; i < length; i++) {
      this._dfs(roots[i], maxDepth, traversal);
    }

    return traversal;
  }

  /**
   * Expands current row.
   *
   * @param {Object} item
   * @param {Boolean} expandAllChildren
   */
  _onExpand(item, expandAllChildren) {
    if (this.props.onExpand) {
      this.props.onExpand(item);

      if (expandAllChildren) {
        const children = this._dfs(item);
        const length = children.length;
        for (let i = 0; i < length; i++) {
          this.props.onExpand(children[i].item);
        }
      }
    }
  }

  /**
   * Collapses current row.
   *
   * @param {Object} item
   */
  _onCollapse(item) {
    if (this.props.onCollapse) {
      this.props.onCollapse(item);
    }
  }

  /**
   * Sets the passed in item to be the focused item.
   *
   * @param {Object|undefined} item
   *        The item to be focused, or undefined to focus no item.
   *
   * @param {Object|undefined} options
   *        An options object which can contain:
   *          - dir: "up" or "down" to indicate if we should scroll the element
   *                 to the top or the bottom of the scrollable container when
   *                 the element is off canvas.
   */
  _focus(item, options = {}) {
    const { preventAutoScroll } = options;
    if (item && !preventAutoScroll) {
      this._scrollNodeIntoView(item, options);
    }

    if (this.props.active != undefined) {
      this._activate(undefined);
      if (this.treeRef.current !== document.activeElement) {
        this.treeRef.current.focus();
      }
    }

    if (this.props.onFocus) {
      this.props.onFocus(item);
    }
  }

  /**
   * Sets the passed in item to be the active item.
   *
   * @param {Object|undefined} item
   *        The item to be activated, or undefined to activate no item.
   */
  _activate(item) {
    if (this.props.onActivate) {
      this.props.onActivate(item);
    }
  }

  /**
   * Sets the passed in item to be the focused item.
   *
   * @param {Object|undefined} item
   *        The item to be scrolled to.
   *
   * @param {Object|undefined} options
   *        An options object which can contain:
   *          - dir: "up" or "down" to indicate if we should scroll the element
   *                 to the top or the bottom of the scrollable container when
   *                 the element is off canvas.
   */
  _scrollNodeIntoView(item, options = {}) {
    if (item !== undefined) {
      const treeElement = this.treeRef.current;
      const element = document.getElementById(this.props.getKey(item));

      if (element) {
        const { top, bottom } = element.getBoundingClientRect();
        const closestScrolledParent = node => {
          if (node == null) {
            return null;
          }

          if (node.scrollHeight > node.clientHeight) {
            return node;
          }
          return closestScrolledParent(node.parentNode);
        };
        const scrolledParent = closestScrolledParent(treeElement);
        const scrolledParentRect = scrolledParent ? scrolledParent.getBoundingClientRect() : null;
        const isVisible = !scrolledParent || top >= scrolledParentRect.top && bottom <= scrolledParentRect.bottom;

        if (!isVisible) {
          const { alignTo } = options;
          const scrollToTop = alignTo ? alignTo === "top" : !scrolledParentRect || top < scrolledParentRect.top;
          element.scrollIntoView(scrollToTop);
        }
      }
    }
  }

  /**
   * Sets the state to have no focused item.
   */
  _onBlur(e) {
    if (this.props.active != undefined) {
      const { relatedTarget } = e;
      if (!this.treeRef.current.contains(relatedTarget)) {
        this._activate(undefined);
      }
    } else if (!this.props.preventBlur) {
      this._focus(undefined);
    }
  }

  /**
   * Handles key down events in the tree's container.
   *
   * @param {Event} e
   */
  // eslint-disable-next-line complexity
  _onKeyDown(e) {
    if (this.props.focused == null) {
      return;
    }

    // Allow parent nodes to use navigation arrows with modifiers.
    if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) {
      return;
    }

    this._preventArrowKeyScrolling(e);

    switch (e.key) {
      case "ArrowUp":
        this._focusPrevNode();
        return;

      case "ArrowDown":
        this._focusNextNode();
        return;

      case "ArrowLeft":
        if (this.props.isExpanded(this.props.focused) && this._nodeIsExpandable(this.props.focused)) {
          this._onCollapse(this.props.focused);
        } else {
          this._focusParentNode();
        }
        return;

      case "ArrowRight":
        if (this._nodeIsExpandable(this.props.focused) && !this.props.isExpanded(this.props.focused)) {
          this._onExpand(this.props.focused);
        } else {
          this._focusNextNode();
        }
        return;

      case "Home":
        this._focusFirstNode();
        return;

      case "End":
        this._focusLastNode();
        return;

      case "Enter":
      case " ":
        if (this.treeRef.current === document.activeElement) {
          this._preventEvent(e);
          if (this.props.active !== this.props.focused) {
            this._activate(this.props.focused);
          }
        }
        return;

      case "Escape":
        this._preventEvent(e);
        if (this.props.active != undefined) {
          this._activate(undefined);
        }

        if (this.treeRef.current !== document.activeElement) {
          this.treeRef.current.focus();
        }
    }
  }

  /**
   * Sets the previous node relative to the currently focused item, to focused.
   */
  _focusPrevNode() {
    // Start a depth first search and keep going until we reach the currently
    // focused node. Focus the previous node in the DFS, if it exists. If it
    // doesn't exist, we're at the first node already.

    let prev;

    const traversal = this._dfsFromRoots();
    const length = traversal.length;
    for (let i = 0; i < length; i++) {
      const item = traversal[i].item;
      if (item === this.props.focused) {
        break;
      }
      prev = item;
    }
    if (prev === undefined) {
      return;
    }

    this._focus(prev, { alignTo: "top" });
  }

  /**
   * Handles the down arrow key which will focus either the next child
   * or sibling row.
   */
  _focusNextNode() {
    // Start a depth first search and keep going until we reach the currently
    // focused node. Focus the next node in the DFS, if it exists. If it
    // doesn't exist, we're at the last node already.
    const traversal = this._dfsFromRoots();
    const length = traversal.length;
    let i = 0;

    while (i < length) {
      if (traversal[i].item === this.props.focused) {
        break;
      }
      i++;
    }

    if (i + 1 < traversal.length) {
      this._focus(traversal[i + 1].item, { alignTo: "bottom" });
    }
  }

  /**
   * Handles the left arrow key, going back up to the current rows'
   * parent row.
   */
  _focusParentNode() {
    const parent = this.props.getParent(this.props.focused);
    if (!parent) {
      this._focusPrevNode(this.props.focused);
      return;
    }

    this._focus(parent, { alignTo: "top" });
  }

  _focusFirstNode() {
    const traversal = this._dfsFromRoots();
    this._focus(traversal[0].item, { alignTo: "top" });
  }

  _focusLastNode() {
    const traversal = this._dfsFromRoots();
    const lastIndex = traversal.length - 1;
    this._focus(traversal[lastIndex].item, { alignTo: "bottom" });
  }

  _nodeIsExpandable(item) {
    return this.props.isExpandable ? this.props.isExpandable(item) : !!this.props.getChildren(item).length;
  }

  render() {
    const traversal = this._dfsFromRoots();
    const { active, focused } = this.props;

    const nodes = traversal.map((v, i) => {
      const { item, depth } = traversal[i];
      const key = this.props.getKey(item, i);
      return TreeNodeFactory({
        // We make a key unique depending on whether the tree node is in active
        // or inactive state to make sure that it is actually replaced and the
        // tabbable state is reset.
        key: `${key}-${active === item ? "active" : "inactive"}`,
        id: key,
        index: i,
        item,
        depth,
        shouldItemUpdate: this.props.shouldItemUpdate,
        renderItem: this.props.renderItem,
        focused: focused === item,
        active: active === item,
        expanded: this.props.isExpanded(item),
        isExpandable: this._nodeIsExpandable(item),
        onExpand: this._onExpand,
        onCollapse: this._onCollapse,
        onClick: e => {
          // We can stop the propagation since click handler on the node can be
          // created in `renderItem`.
          e.stopPropagation();

          // Since the user just clicked the node, there's no need to check if
          // it should be scrolled into view.
          this._focus(item, { preventAutoScroll: true });
          if (this.props.isExpanded(item)) {
            this.props.onCollapse(item, e.altKey);
          } else {
            this.props.onExpand(item, e.altKey);
          }

          // Focus should always remain on the tree container itself.
          this.treeRef.current.focus();
        }
      });
    });

    const style = Object.assign({}, this.props.style || {});

    return _reactDomFactories2.default.div({
      className: `tree ${this.props.className ? this.props.className : ""}`,
      ref: this.treeRef,
      role: "tree",
      tabIndex: "0",
      onKeyDown: this._onKeyDown,
      onKeyPress: this._preventArrowKeyScrolling,
      onKeyUp: this._preventArrowKeyScrolling,
      onFocus: ({ nativeEvent }) => {
        if (focused || !nativeEvent || !this.treeRef.current) {
          return;
        }

        const { explicitOriginalTarget } = nativeEvent;
        // Only set default focus to the first tree node if the focus came
        // from outside the tree (e.g. by tabbing to the tree from other
        // external elements).
        if (explicitOriginalTarget !== this.treeRef.current && !this.treeRef.current.contains(explicitOriginalTarget)) {
          this._focus(traversal[0].item);
        }
      },
      onBlur: this._onBlur,
      "aria-label": this.props.label,
      "aria-labelledby": this.props.labelledby,
      "aria-activedescendant": focused && this.props.getKey(focused),
      style
    }, nodes);
  }
}

exports.default = Tree;

/***/ }),
/* 110 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

(function() {
  var computeScore, countDir, file_coeff, getExtension, getExtensionScore, isMatch, scorePath, scoreSize, tau_depth, _ref;

  _ref = __webpack_require__(66), isMatch = _ref.isMatch, computeScore = _ref.computeScore, scoreSize = _ref.scoreSize;

  tau_depth = 20;

  file_coeff = 2.5;

  exports.score = function(string, query, options) {
    var allowErrors, preparedQuery, score, string_lw;
    preparedQuery = options.preparedQuery, allowErrors = options.allowErrors;
    if (!(allowErrors || isMatch(string, preparedQuery.core_lw, preparedQuery.core_up))) {
      return 0;
    }
    string_lw = string.toLowerCase();
    score = computeScore(string, string_lw, preparedQuery);
    score = scorePath(string, string_lw, score, options);
    return Math.ceil(score);
  };

  scorePath = function(subject, subject_lw, fullPathScore, options) {
    var alpha, basePathScore, basePos, depth, end, extAdjust, fileLength, pathSeparator, preparedQuery, useExtensionBonus;
    if (fullPathScore === 0) {
      return 0;
    }
    preparedQuery = options.preparedQuery, useExtensionBonus = options.useExtensionBonus, pathSeparator = options.pathSeparator;
    end = subject.length - 1;
    while (subject[end] === pathSeparator) {
      end--;
    }
    basePos = subject.lastIndexOf(pathSeparator, end);
    fileLength = end - basePos;
    extAdjust = 1.0;
    if (useExtensionBonus) {
      extAdjust += getExtensionScore(subject_lw, preparedQuery.ext, basePos, end, 2);
      fullPathScore *= extAdjust;
    }
    if (basePos === -1) {
      return fullPathScore;
    }
    depth = preparedQuery.depth;
    while (basePos > -1 && depth-- > 0) {
      basePos = subject.lastIndexOf(pathSeparator, basePos - 1);
    }
    basePathScore = basePos === -1 ? fullPathScore : extAdjust * computeScore(subject.slice(basePos + 1, end + 1), subject_lw.slice(basePos + 1, end + 1), preparedQuery);
    alpha = 0.5 * tau_depth / (tau_depth + countDir(subject, end + 1, pathSeparator));
    return alpha * basePathScore + (1 - alpha) * fullPathScore * scoreSize(0, file_coeff * fileLength);
  };

  exports.countDir = countDir = function(path, end, pathSeparator) {
    var count, i;
    if (end < 1) {
      return 0;
    }
    count = 0;
    i = -1;
    while (++i < end && path[i] === pathSeparator) {
      continue;
    }
    while (++i < end) {
      if (path[i] === pathSeparator) {
        count++;
        while (++i < end && path[i] === pathSeparator) {
          continue;
        }
      }
    }
    return count;
  };

  exports.getExtension = getExtension = function(str) {
    var pos;
    pos = str.lastIndexOf(".");
    if (pos < 0) {
      return "";
    } else {
      return str.substr(pos + 1);
    }
  };

  getExtensionScore = function(candidate, ext, startPos, endPos, maxDepth) {
    var m, matched, n, pos;
    if (!ext.length) {
      return 0;
    }
    pos = candidate.lastIndexOf(".", endPos);
    if (!(pos > startPos)) {
      return 0;
    }
    n = ext.length;
    m = endPos - pos;
    if (m < n) {
      n = m;
      m = ext.length;
    }
    pos++;
    matched = -1;
    while (++matched < n) {
      if (candidate[pos + matched] !== ext[matched]) {
        break;
      }
    }
    if (matched === 0 && maxDepth > 0) {
      return 0.9 * getExtensionScore(candidate, ext, startPos, pos - 2, maxDepth - 1);
    }
    return matched / m;
  };

}).call(this);


/***/ }),
/* 112 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_112__;

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// ReactJS
const PropTypes = __webpack_require__(0);

// Dependencies
const { interleave, isGrip, wrapRender } = __webpack_require__(2);
const PropRep = __webpack_require__(39);
const { MODE } = __webpack_require__(4);

const dom = __webpack_require__(1);
const { span } = dom;

/**
 * Renders generic grip. Grip is client representation
 * of remote JS object and is used as an input object
 * for this rep component.
 */
GripRep.propTypes = {
  object: PropTypes.object.isRequired,
  // @TODO Change this to Object.values when supported in Node's version of V8
  mode: PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key])),
  isInterestingProp: PropTypes.func,
  title: PropTypes.string,
  onDOMNodeMouseOver: PropTypes.func,
  onDOMNodeMouseOut: PropTypes.func,
  onInspectIconClick: PropTypes.func,
  noGrip: PropTypes.bool
};

const DEFAULT_TITLE = "Object";

function GripRep(props) {
  const { mode = MODE.SHORT, object } = props;

  const config = {
    "data-link-actor-id": object.actor,
    className: "objectBox objectBox-object"
  };

  if (mode === MODE.TINY) {
    const propertiesLength = getPropertiesLength(object);

    const tinyModeItems = [];
    if (getTitle(props, object) !== DEFAULT_TITLE) {
      tinyModeItems.push(getTitleElement(props, object));
    } else {
      tinyModeItems.push(span({
        className: "objectLeftBrace"
      }, "{"), propertiesLength > 0 ? span({
        key: "more",
        className: "more-ellipsis",
        title: "more…"
      }, "…") : null, span({
        className: "objectRightBrace"
      }, "}"));
    }

    return span(config, ...tinyModeItems);
  }

  const propsArray = safePropIterator(props, object, maxLengthMap.get(mode));

  return span(config, getTitleElement(props, object), span({
    className: "objectLeftBrace"
  }, " { "), ...interleave(propsArray, ", "), span({
    className: "objectRightBrace"
  }, " }"));
}

function getTitleElement(props, object) {
  return span({
    className: "objectTitle"
  }, getTitle(props, object));
}

function getTitle(props, object) {
  return props.title || object.class || DEFAULT_TITLE;
}

function getPropertiesLength(object) {
  let propertiesLength = object.preview && object.preview.ownPropertiesLength ? object.preview.ownPropertiesLength : object.ownPropertyLength;

  if (object.preview && object.preview.safeGetterValues) {
    propertiesLength += Object.keys(object.preview.safeGetterValues).length;
  }

  if (object.preview && object.preview.ownSymbols) {
    propertiesLength += object.preview.ownSymbolsLength;
  }

  return propertiesLength;
}

function safePropIterator(props, object, max) {
  max = typeof max === "undefined" ? maxLengthMap.get(MODE.SHORT) : max;
  try {
    return propIterator(props, object, max);
  } catch (err) {
    console.error(err);
  }
  return [];
}

function propIterator(props, object, max) {
  if (object.preview && Object.keys(object.preview).includes("wrappedValue")) {
    const { Rep } = __webpack_require__(24);

    return [Rep({
      object: object.preview.wrappedValue,
      mode: props.mode || MODE.TINY,
      defaultRep: Grip
    })];
  }

  // Property filter. Show only interesting properties to the user.
  const isInterestingProp = props.isInterestingProp || ((type, value) => {
    return type == "boolean" || type == "number" || type == "string" && value.length != 0;
  });

  let properties = object.preview ? object.preview.ownProperties || {} : {};

  const propertiesLength = getPropertiesLength(object);

  if (object.preview && object.preview.safeGetterValues) {
    properties = { ...properties, ...object.preview.safeGetterValues };
  }

  let indexes = getPropIndexes(properties, max, isInterestingProp);
  if (indexes.length < max && indexes.length < propertiesLength) {
    // There are not enough props yet.
    // Then add uninteresting props to display them.
    indexes = indexes.concat(getPropIndexes(properties, max - indexes.length, (t, value, name) => {
      return !isInterestingProp(t, value, name);
    }));
  }

  // The server synthesizes some property names for a Proxy, like
  // <target> and <handler>; we don't want to quote these because,
  // as synthetic properties, they appear more natural when
  // unquoted.
  const suppressQuotes = object.class === "Proxy";
  const propsArray = getProps(props, properties, indexes, suppressQuotes);

  // Show symbols.
  if (object.preview && object.preview.ownSymbols) {
    const { ownSymbols } = object.preview;
    const length = max - indexes.length;

    const symbolsProps = ownSymbols.slice(0, length).map(symbolItem => {
      return PropRep({
        ...props,
        mode: MODE.TINY,
        name: symbolItem,
        object: symbolItem.descriptor.value,
        equal: ": ",
        defaultRep: Grip,
        title: null,
        suppressQuotes
      });
    });

    propsArray.push(...symbolsProps);
  }

  if (Object.keys(properties).length > max || propertiesLength > max ||
  // When the object has non-enumerable properties, we don't have them in the
  // packet, but we might want to show there's something in the object.
  propertiesLength > propsArray.length) {
    // There are some undisplayed props. Then display "more...".
    propsArray.push(span({
      key: "more",
      className: "more-ellipsis",
      title: "more…"
    }, "…"));
  }

  return propsArray;
}

/**
 * Get props ordered by index.
 *
 * @param {Object} componentProps Grip Component props.
 * @param {Object} properties Properties of the object the Grip describes.
 * @param {Array} indexes Indexes of properties.
 * @param {Boolean} suppressQuotes true if we should suppress quotes
 *                  on property names.
 * @return {Array} Props.
 */
function getProps(componentProps, properties, indexes, suppressQuotes) {
  // Make indexes ordered by ascending.
  indexes.sort(function (a, b) {
    return a - b;
  });

  const propertiesKeys = Object.keys(properties);
  return indexes.map(i => {
    const name = propertiesKeys[i];
    const value = getPropValue(properties[name]);

    return PropRep({
      ...componentProps,
      mode: MODE.TINY,
      name,
      object: value,
      equal: ": ",
      defaultRep: Grip,
      title: null,
      suppressQuotes
    });
  });
}

/**
 * Get the indexes of props in the object.
 *
 * @param {Object} properties Props object.
 * @param {Number} max The maximum length of indexes array.
 * @param {Function} filter Filter the props you want.
 * @return {Array} Indexes of interesting props in the object.
 */
function getPropIndexes(properties, max, filter) {
  const indexes = [];

  try {
    let i = 0;
    for (const name in properties) {
      if (indexes.length >= max) {
        return indexes;
      }

      // Type is specified in grip's "class" field and for primitive
      // values use typeof.
      const value = getPropValue(properties[name]);
      let type = value.class || typeof value;
      type = type.toLowerCase();

      if (filter(type, value, name)) {
        indexes.push(i);
      }
      i++;
    }
  } catch (err) {
    console.error(err);
  }
  return indexes;
}

/**
 * Get the actual value of a property.
 *
 * @param {Object} property
 * @return {Object} Value of the property.
 */
function getPropValue(property) {
  let value = property;
  if (typeof property === "object") {
    const keys = Object.keys(property);
    if (keys.includes("value")) {
      value = property.value;
    } else if (keys.includes("getterValue")) {
      value = property.getterValue;
    }
  }
  return value;
}

// Registration
function supportsObject(object, noGrip = false) {
  if (noGrip === true || !isGrip(object)) {
    return false;
  }

  if (object.class === "DeadObject") {
    return true;
  }

  return object.preview ? typeof object.preview.ownProperties !== "undefined" : typeof object.ownPropertyLength !== "undefined";
}

const maxLengthMap = new Map();
maxLengthMap.set(MODE.SHORT, 3);
maxLengthMap.set(MODE.LONG, 10);

// Grip is used in propIterator and has to be defined here.
const Grip = {
  rep: wrapRender(GripRep),
  supportsObject,
  maxLengthMap
};

// Exports from this module
module.exports = Grip;

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const { maybeEscapePropertyName } = __webpack_require__(2);
const ArrayRep = __webpack_require__(38);
const GripArrayRep = __webpack_require__(192);
const GripMap = __webpack_require__(194);
const GripMapEntryRep = __webpack_require__(195);
const ErrorRep = __webpack_require__(191);
const BigIntRep = __webpack_require__(188);
const { isLongString } = __webpack_require__(25);

const MAX_NUMERICAL_PROPERTIES = 100;

const NODE_TYPES = {
  BUCKET: Symbol("[n…m]"),
  DEFAULT_PROPERTIES: Symbol("<default properties>"),
  ENTRIES: Symbol("<entries>"),
  GET: Symbol("<get>"),
  GRIP: Symbol("GRIP"),
  MAP_ENTRY_KEY: Symbol("<key>"),
  MAP_ENTRY_VALUE: Symbol("<value>"),
  PROMISE_REASON: Symbol("<reason>"),
  PROMISE_STATE: Symbol("<state>"),
  PROMISE_VALUE: Symbol("<value>"),
  PROXY_HANDLER: Symbol("<handler>"),
  PROXY_TARGET: Symbol("<target>"),
  SET: Symbol("<set>"),
  PROTOTYPE: Symbol("<prototype>"),
  BLOCK: Symbol("☲")
};

let WINDOW_PROPERTIES = {};

if (typeof window === "object") {
  WINDOW_PROPERTIES = Object.getOwnPropertyNames(window);
}

function getType(item) {
  return item.type;
}

function getValue(item) {
  if (nodeHasValue(item)) {
    return item.contents.value;
  }

  if (nodeHasGetterValue(item)) {
    return item.contents.getterValue;
  }

  if (nodeHasAccessors(item)) {
    return item.contents;
  }

  return undefined;
}

function getActor(item, roots) {
  const isRoot = isNodeRoot(item, roots);
  const value = getValue(item);
  return isRoot || !value ? null : value.actor;
}

function isNodeRoot(item, roots) {
  const gripItem = getClosestGripNode(item);
  const value = getValue(gripItem);

  return value && roots.some(root => {
    const rootValue = getValue(root);
    return rootValue && rootValue.actor === value.actor;
  });
}

function nodeIsBucket(item) {
  return getType(item) === NODE_TYPES.BUCKET;
}

function nodeIsEntries(item) {
  return getType(item) === NODE_TYPES.ENTRIES;
}

function nodeIsMapEntry(item) {
  return GripMapEntryRep.supportsObject(getValue(item));
}

function nodeHasChildren(item) {
  return Array.isArray(item.contents);
}

function nodeHasValue(item) {
  return item && item.contents && item.contents.hasOwnProperty("value");
}

function nodeHasGetterValue(item) {
  return item && item.contents && item.contents.hasOwnProperty("getterValue");
}

function nodeIsObject(item) {
  const value = getValue(item);
  return value && value.type === "object";
}

function nodeIsArrayLike(item) {
  const value = getValue(item);
  return GripArrayRep.supportsObject(value) || ArrayRep.supportsObject(value);
}

function nodeIsFunction(item) {
  const value = getValue(item);
  return value && value.class === "Function";
}

function nodeIsOptimizedOut(item) {
  const value = getValue(item);
  return !nodeHasChildren(item) && value && value.optimizedOut;
}

function nodeIsUninitializedBinding(item) {
  const value = getValue(item);
  return value && value.uninitialized;
}

// Used to check if an item represents a binding that exists in a sourcemap's
// original file content, but does not match up with a binding found in the
// generated code.
function nodeIsUnmappedBinding(item) {
  const value = getValue(item);
  return value && value.unmapped;
}

// Used to check if an item represents a binding that exists in the debugger's
// parser result, but does not match up with a binding returned by the
// debugger server.
function nodeIsUnscopedBinding(item) {
  const value = getValue(item);
  return value && value.unscoped;
}

function nodeIsMissingArguments(item) {
  const value = getValue(item);
  return !nodeHasChildren(item) && value && value.missingArguments;
}

function nodeHasProperties(item) {
  return !nodeHasChildren(item) && nodeIsObject(item);
}

function nodeIsPrimitive(item) {
  return nodeIsBigInt(item) || !nodeHasChildren(item) && !nodeHasProperties(item) && !nodeIsEntries(item) && !nodeIsMapEntry(item) && !nodeHasAccessors(item) && !nodeIsBucket(item) && !nodeIsLongString(item);
}

function nodeIsDefaultProperties(item) {
  return getType(item) === NODE_TYPES.DEFAULT_PROPERTIES;
}

function isDefaultWindowProperty(name) {
  return WINDOW_PROPERTIES.includes(name);
}

function nodeIsPromise(item) {
  const value = getValue(item);
  if (!value) {
    return false;
  }

  return value.class == "Promise";
}

function nodeIsProxy(item) {
  const value = getValue(item);
  if (!value) {
    return false;
  }

  return value.class == "Proxy";
}

function nodeIsPrototype(item) {
  return getType(item) === NODE_TYPES.PROTOTYPE;
}

function nodeIsWindow(item) {
  const value = getValue(item);
  if (!value) {
    return false;
  }

  return value.class == "Window";
}

function nodeIsGetter(item) {
  return getType(item) === NODE_TYPES.GET;
}

function nodeIsSetter(item) {
  return getType(item) === NODE_TYPES.SET;
}

function nodeIsBlock(item) {
  return getType(item) === NODE_TYPES.BLOCK;
}

function nodeIsError(item) {
  return ErrorRep.supportsObject(getValue(item));
}

function nodeIsLongString(item) {
  return isLongString(getValue(item));
}

function nodeIsBigInt(item) {
  return BigIntRep.supportsObject(getValue(item));
}

function nodeHasFullText(item) {
  const value = getValue(item);
  return nodeIsLongString(item) && value.hasOwnProperty("fullText");
}

function nodeHasGetter(item) {
  const getter = getNodeGetter(item);
  return getter && getter.type !== "undefined";
}

function nodeHasSetter(item) {
  const setter = getNodeSetter(item);
  return setter && setter.type !== "undefined";
}

function nodeHasAccessors(item) {
  return nodeHasGetter(item) || nodeHasSetter(item);
}

function nodeSupportsNumericalBucketing(item) {
  // We exclude elements with entries since it's the <entries> node
  // itself that can have buckets.
  return nodeIsArrayLike(item) && !nodeHasEntries(item) || nodeIsEntries(item) || nodeIsBucket(item);
}

function nodeHasEntries(item) {
  const value = getValue(item);
  if (!value) {
    return false;
  }

  return value.class === "Map" || value.class === "Set" || value.class === "WeakMap" || value.class === "WeakSet" || value.class === "Storage";
}

function nodeHasAllEntriesInPreview(item) {
  const { preview } = getValue(item) || {};
  if (!preview) {
    return false;
  }

  const { entries, items, length, size } = preview;

  if (!entries && !items) {
    return false;
  }

  return entries ? entries.length === size : items.length === length;
}

function nodeNeedsNumericalBuckets(item) {
  return nodeSupportsNumericalBucketing(item) && getNumericalPropertiesCount(item) > MAX_NUMERICAL_PROPERTIES;
}

function makeNodesForPromiseProperties(item) {
  const {
    promiseState: { reason, value, state }
  } = getValue(item);

  const properties = [];

  if (state) {
    properties.push(createNode({
      parent: item,
      name: "<state>",
      contents: { value: state },
      type: NODE_TYPES.PROMISE_STATE
    }));
  }

  if (reason) {
    properties.push(createNode({
      parent: item,
      name: "<reason>",
      contents: { value: reason },
      type: NODE_TYPES.PROMISE_REASON
    }));
  }

  if (value) {
    properties.push(createNode({
      parent: item,
      name: "<value>",
      contents: { value: value },
      type: NODE_TYPES.PROMISE_VALUE
    }));
  }

  return properties;
}

function makeNodesForProxyProperties(item) {
  const { proxyHandler, proxyTarget } = getValue(item);

  return [createNode({
    parent: item,
    name: "<target>",
    contents: { value: proxyTarget },
    type: NODE_TYPES.PROXY_TARGET
  }), createNode({
    parent: item,
    name: "<handler>",
    contents: { value: proxyHandler },
    type: NODE_TYPES.PROXY_HANDLER
  })];
}

function makeNodesForEntries(item) {
  const nodeName = "<entries>";
  const entriesPath = "<entries>";

  if (nodeHasAllEntriesInPreview(item)) {
    let entriesNodes = [];
    const { preview } = getValue(item);
    if (preview.entries) {
      entriesNodes = preview.entries.map(([key, value], index) => {
        return createNode({
          parent: item,
          name: index,
          path: `${entriesPath}/${index}`,
          contents: { value: GripMapEntryRep.createGripMapEntry(key, value) }
        });
      });
    } else if (preview.items) {
      entriesNodes = preview.items.map((value, index) => {
        return createNode({
          parent: item,
          name: index,
          path: `${entriesPath}/${index}`,
          contents: { value }
        });
      });
    }
    return createNode({
      parent: item,
      name: nodeName,
      contents: entriesNodes,
      type: NODE_TYPES.ENTRIES
    });
  }
  return createNode({
    parent: item,
    name: nodeName,
    contents: null,
    type: NODE_TYPES.ENTRIES
  });
}

function makeNodesForMapEntry(item) {
  const nodeValue = getValue(item);
  if (!nodeValue || !nodeValue.preview) {
    return [];
  }

  const { key, value } = nodeValue.preview;

  return [createNode({
    parent: item,
    name: "<key>",
    contents: { value: key },
    type: NODE_TYPES.MAP_ENTRY_KEY
  }), createNode({
    parent: item,
    name: "<value>",
    contents: { value },
    type: NODE_TYPES.MAP_ENTRY_VALUE
  })];
}

function getNodeGetter(item) {
  return item && item.contents ? item.contents.get : undefined;
}

function getNodeSetter(item) {
  return item && item.contents ? item.contents.set : undefined;
}

function sortProperties(properties) {
  return properties.sort((a, b) => {
    // Sort numbers in ascending order and sort strings lexicographically
    const aInt = parseInt(a, 10);
    const bInt = parseInt(b, 10);

    if (isNaN(aInt) || isNaN(bInt)) {
      return a > b ? 1 : -1;
    }

    return aInt - bInt;
  });
}

function makeNumericalBuckets(parent) {
  const numProperties = getNumericalPropertiesCount(parent);

  // We want to have at most a hundred slices.
  const bucketSize = 10 ** Math.max(2, Math.ceil(Math.log10(numProperties)) - 2);
  const numBuckets = Math.ceil(numProperties / bucketSize);

  const buckets = [];
  for (let i = 1; i <= numBuckets; i++) {
    const minKey = (i - 1) * bucketSize;
    const maxKey = Math.min(i * bucketSize - 1, numProperties - 1);
    const startIndex = nodeIsBucket(parent) ? parent.meta.startIndex : 0;
    const minIndex = startIndex + minKey;
    const maxIndex = startIndex + maxKey;
    const bucketName = `[${minIndex}…${maxIndex}]`;

    buckets.push(createNode({
      parent,
      name: bucketName,
      contents: null,
      type: NODE_TYPES.BUCKET,
      meta: {
        startIndex: minIndex,
        endIndex: maxIndex
      }
    }));
  }
  return buckets;
}

function makeDefaultPropsBucket(propertiesNames, parent, ownProperties) {
  const userPropertiesNames = [];
  const defaultProperties = [];

  propertiesNames.forEach(name => {
    if (isDefaultWindowProperty(name)) {
      defaultProperties.push(name);
    } else {
      userPropertiesNames.push(name);
    }
  });

  const nodes = makeNodesForOwnProps(userPropertiesNames, parent, ownProperties);

  if (defaultProperties.length > 0) {
    const defaultPropertiesNode = createNode({
      parent,
      name: "<default properties>",
      contents: null,
      type: NODE_TYPES.DEFAULT_PROPERTIES
    });

    const defaultNodes = defaultProperties.map((name, index) => createNode({
      parent: defaultPropertiesNode,
      name: maybeEscapePropertyName(name),
      path: `${index}/${name}`,
      contents: ownProperties[name]
    }));
    nodes.push(setNodeChildren(defaultPropertiesNode, defaultNodes));
  }
  return nodes;
}

function makeNodesForOwnProps(propertiesNames, parent, ownProperties) {
  return propertiesNames.map(name => createNode({
    parent,
    name: maybeEscapePropertyName(name),
    contents: ownProperties[name]
  }));
}

function makeNodesForProperties(objProps, parent) {
  const {
    ownProperties = {},
    ownSymbols,
    prototype,
    safeGetterValues
  } = objProps;

  const parentValue = getValue(parent);

  const allProperties = { ...ownProperties, ...safeGetterValues };

  // Ignore properties that are neither non-concrete nor getters/setters.
  const propertiesNames = sortProperties(Object.keys(allProperties)).filter(name => {
    if (!allProperties[name]) {
      return false;
    }

    const properties = Object.getOwnPropertyNames(allProperties[name]);
    return properties.some(property => ["value", "getterValue", "get", "set"].includes(property));
  });

  let nodes = [];
  if (parentValue && parentValue.class == "Window") {
    nodes = makeDefaultPropsBucket(propertiesNames, parent, allProperties);
  } else {
    nodes = makeNodesForOwnProps(propertiesNames, parent, allProperties);
  }

  if (Array.isArray(ownSymbols)) {
    ownSymbols.forEach((ownSymbol, index) => {
      nodes.push(createNode({
        parent,
        name: ownSymbol.name,
        path: `symbol-${index}`,
        contents: ownSymbol.descriptor || null
      }));
    }, this);
  }

  if (nodeIsPromise(parent)) {
    nodes.push(...makeNodesForPromiseProperties(parent));
  }

  if (nodeHasEntries(parent)) {
    nodes.push(makeNodesForEntries(parent));
  }

  // Add accessor nodes if needed
  for (const name of propertiesNames) {
    const property = allProperties[name];
    if (property.get && property.get.type !== "undefined") {
      nodes.push(createGetterNode({ parent, property, name }));
    }

    if (property.set && property.set.type !== "undefined") {
      nodes.push(createSetterNode({ parent, property, name }));
    }
  }

  // Add the prototype if it exists and is not null
  if (prototype && prototype.type !== "null") {
    nodes.push(makeNodeForPrototype(objProps, parent));
  }

  return nodes;
}

function setNodeFullText(loadedProps, node) {
  if (nodeHasFullText(node) || !nodeIsLongString(node)) {
    return node;
  }

  const { fullText } = loadedProps;
  if (nodeHasValue(node)) {
    node.contents.value.fullText = fullText;
  } else if (nodeHasGetterValue(node)) {
    node.contents.getterValue.fullText = fullText;
  }

  return node;
}

function makeNodeForPrototype(objProps, parent) {
  const { prototype } = objProps || {};

  // Add the prototype if it exists and is not null
  if (prototype && prototype.type !== "null") {
    return createNode({
      parent,
      name: "<prototype>",
      contents: { value: prototype },
      type: NODE_TYPES.PROTOTYPE
    });
  }

  return null;
}

function createNode(options) {
  const {
    parent,
    name,
    path,
    contents,
    type = NODE_TYPES.GRIP,
    meta
  } = options;

  if (contents === undefined) {
    return null;
  }

  // The path is important to uniquely identify the item in the entire
  // tree. This helps debugging & optimizes React's rendering of large
  // lists. The path will be separated by property name, wrapped in a Symbol
  // to avoid name clashing,
  // i.e. `{ foo: { bar: { baz: 5 }}}` will have a path of Symbol(`foo/bar/baz`)
  // for the inner object.
  return {
    parent,
    name,
    path: parent ? Symbol(`${getSymbolDescriptor(parent.path)}/${path || name}`) : Symbol(path || name),
    contents,
    type,
    meta
  };
}

function createGetterNode({ parent, property, name }) {
  return createNode({
    parent,
    name: `<get ${name}()>`,
    contents: { value: property.get },
    type: NODE_TYPES.GET
  });
}

function createSetterNode({ parent, property, name }) {
  return createNode({
    parent,
    name: `<set ${name}()>`,
    contents: { value: property.set },
    type: NODE_TYPES.SET
  });
}

function getSymbolDescriptor(symbol) {
  return symbol.toString().replace(/^(Symbol\()(.*)(\))$/, "$2");
}

function setNodeChildren(node, children) {
  node.contents = children;
  return node;
}

function getEvaluatedItem(item, evaluations) {
  if (!evaluations.has(item.path)) {
    return item;
  }

  return {
    ...item,
    contents: evaluations.get(item.path)
  };
}

function getChildrenWithEvaluations(options) {
  const { item, loadedProperties, cachedNodes, evaluations } = options;

  const children = getChildren({
    loadedProperties,
    cachedNodes,
    item
  });

  if (Array.isArray(children)) {
    return children.map(i => getEvaluatedItem(i, evaluations));
  }

  if (children) {
    return getEvaluatedItem(children, evaluations);
  }

  return [];
}

function getChildren(options) {
  const { cachedNodes, item, loadedProperties = new Map() } = options;

  const key = item.path;
  if (cachedNodes && cachedNodes.has(key)) {
    return cachedNodes.get(key);
  }

  const loadedProps = loadedProperties.get(key);
  const hasLoadedProps = loadedProperties.has(key);

  // Because we are dynamically creating the tree as the user
  // expands it (not precalculated tree structure), we cache child
  // arrays. This not only helps performance, but is necessary
  // because the expanded state depends on instances of nodes
  // being the same across renders. If we didn't do this, each
  // node would be a new instance every render.
  // If the node needs properties, we only add children to
  // the cache if the properties are loaded.
  const addToCache = children => {
    if (cachedNodes) {
      cachedNodes.set(item.path, children);
    }
    return children;
  };

  // Nodes can either have children already, or be an object with
  // properties that we need to go and fetch.
  if (nodeHasChildren(item)) {
    return addToCache(item.contents);
  }

  if (nodeIsMapEntry(item)) {
    return addToCache(makeNodesForMapEntry(item));
  }

  if (nodeIsProxy(item)) {
    return addToCache(makeNodesForProxyProperties(item));
  }

  if (nodeIsLongString(item) && hasLoadedProps) {
    // Set longString object's fullText to fetched one.
    return addToCache(setNodeFullText(loadedProps, item));
  }

  if (nodeNeedsNumericalBuckets(item) && hasLoadedProps) {
    // Even if we have numerical buckets, we should have loaded non indexed
    // properties.
    const bucketNodes = makeNumericalBuckets(item);
    return addToCache(bucketNodes.concat(makeNodesForProperties(loadedProps, item)));
  }

  if (!nodeIsEntries(item) && !nodeIsBucket(item) && !nodeHasProperties(item)) {
    return [];
  }

  if (!hasLoadedProps) {
    return [];
  }

  return addToCache(makeNodesForProperties(loadedProps, item));
}

function getParent(item) {
  return item.parent;
}

function getNumericalPropertiesCount(item) {
  if (nodeIsBucket(item)) {
    return item.meta.endIndex - item.meta.startIndex + 1;
  }

  const value = getValue(getClosestGripNode(item));
  if (!value) {
    return 0;
  }

  if (GripArrayRep.supportsObject(value)) {
    return GripArrayRep.getLength(value);
  }

  if (GripMap.supportsObject(value)) {
    return GripMap.getLength(value);
  }

  // TODO: We can also have numerical properties on Objects, but at the
  // moment we don't have a way to distinguish them from non-indexed properties,
  // as they are all computed in a ownPropertiesLength property.

  return 0;
}

function getClosestGripNode(item) {
  const type = getType(item);
  if (type !== NODE_TYPES.BUCKET && type !== NODE_TYPES.DEFAULT_PROPERTIES && type !== NODE_TYPES.ENTRIES) {
    return item;
  }

  const parent = getParent(item);
  if (!parent) {
    return null;
  }

  return getClosestGripNode(parent);
}

function getClosestNonBucketNode(item) {
  const type = getType(item);

  if (type !== NODE_TYPES.BUCKET) {
    return item;
  }

  const parent = getParent(item);
  if (!parent) {
    return null;
  }

  return getClosestNonBucketNode(parent);
}

function getParentGripNode(item) {
  const parentNode = getParent(item);
  if (!parentNode) {
    return null;
  }

  return getClosestGripNode(parentNode);
}

function getParentGripValue(item) {
  const parentGripNode = getParentGripNode(item);
  if (!parentGripNode) {
    return null;
  }

  return getValue(parentGripNode);
}

function getNonPrototypeParentGripValue(item) {
  const parentGripNode = getParentGripNode(item);
  if (!parentGripNode) {
    return null;
  }

  if (getType(parentGripNode) === NODE_TYPES.PROTOTYPE) {
    return getNonPrototypeParentGripValue(parentGripNode);
  }

  return getValue(parentGripNode);
}

module.exports = {
  createNode,
  createGetterNode,
  createSetterNode,
  getActor,
  getChildren,
  getChildrenWithEvaluations,
  getClosestGripNode,
  getClosestNonBucketNode,
  getParent,
  getParentGripValue,
  getNonPrototypeParentGripValue,
  getNumericalPropertiesCount,
  getValue,
  makeNodesForEntries,
  makeNodesForPromiseProperties,
  makeNodesForProperties,
  makeNumericalBuckets,
  nodeHasAccessors,
  nodeHasAllEntriesInPreview,
  nodeHasChildren,
  nodeHasEntries,
  nodeHasProperties,
  nodeHasGetter,
  nodeHasSetter,
  nodeIsBlock,
  nodeIsBucket,
  nodeIsDefaultProperties,
  nodeIsEntries,
  nodeIsError,
  nodeIsLongString,
  nodeHasFullText,
  nodeIsFunction,
  nodeIsGetter,
  nodeIsMapEntry,
  nodeIsMissingArguments,
  nodeIsObject,
  nodeIsOptimizedOut,
  nodeIsPrimitive,
  nodeIsPromise,
  nodeIsPrototype,
  nodeIsProxy,
  nodeIsSetter,
  nodeIsUninitializedBinding,
  nodeIsUnmappedBinding,
  nodeIsUnscopedBinding,
  nodeIsWindow,
  nodeNeedsNumericalBuckets,
  nodeSupportsNumericalBucketing,
  setNodeChildren,
  sortProperties,
  NODE_TYPES
};

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function initialState() {
  return {
    expandedPaths: new Set(),
    loadedProperties: new Map(),
    evaluations: new Map(),
    actors: new Set()
  };
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function reducer(state = initialState(), action = {}) {
  const { type, data } = action;

  const cloneState = overrides => ({ ...state, ...overrides });

  if (type === "NODE_EXPAND") {
    return cloneState({
      expandedPaths: new Set(state.expandedPaths).add(data.node.path)
    });
  }

  if (type === "NODE_COLLAPSE") {
    const expandedPaths = new Set(state.expandedPaths);
    expandedPaths.delete(data.node.path);
    return cloneState({ expandedPaths });
  }

  if (type === "NODE_PROPERTIES_LOADED") {
    return cloneState({
      actors: data.actor ? new Set(state.actors || []).add(data.actor) : state.actors,
      loadedProperties: new Map(state.loadedProperties).set(data.node.path, action.data.properties)
    });
  }

  if (type === "ROOTS_CHANGED") {
    return cloneState();
  }

  if (type === "GETTER_INVOKED") {
    return cloneState({
      actors: data.actor ? new Set(state.actors || []).add(data.result.from) : state.actors,
      evaluations: new Map(state.evaluations).set(data.node.path, {
        getterValue: data.result && data.result.value && (data.result.value.return || data.result.value.throw)
      })
    });
  }

  // NOTE: we clear the state on resume because otherwise the scopes pane
  // would be out of date. Bug 1514760
  if (type === "RESUME" || type == "NAVIGATE") {
    return initialState();
  }

  return state;
}

function getObjectInspectorState(state) {
  return state.objectInspector;
}

function getExpandedPaths(state) {
  return getObjectInspectorState(state).expandedPaths;
}

function getExpandedPathKeys(state) {
  return [...getExpandedPaths(state).keys()];
}

function getActors(state) {
  return getObjectInspectorState(state).actors;
}

function getLoadedProperties(state) {
  return getObjectInspectorState(state).loadedProperties;
}

function getLoadedPropertyKeys(state) {
  return [...getLoadedProperties(state).keys()];
}

function getEvaluations(state) {
  return getObjectInspectorState(state).evaluations;
}

const selectors = {
  getActors,
  getEvaluations,
  getExpandedPathKeys,
  getExpandedPaths,
  getLoadedProperties,
  getLoadedPropertyKeys
};

Object.defineProperty(module.exports, "__esModule", {
  value: true
});
module.exports = selectors;
module.exports.default = reducer;

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const client = __webpack_require__(197);
const loadProperties = __webpack_require__(196);
const node = __webpack_require__(114);
const { nodeIsError, nodeIsPrimitive } = node;
const selection = __webpack_require__(488);

const { MODE } = __webpack_require__(4);
const {
  REPS: { Rep, Grip }
} = __webpack_require__(24);


function shouldRenderRootsInReps(roots) {
  if (roots.length > 1) {
    return false;
  }

  const root = roots[0];
  const name = root && root.name;
  return (name === null || typeof name === "undefined") && (nodeIsPrimitive(root) || nodeIsError(root));
}

function renderRep(item, props) {
  return Rep({
    ...props,
    object: node.getValue(item),
    mode: props.mode || MODE.TINY,
    defaultRep: Grip
  });
}

module.exports = {
  client,
  loadProperties,
  node,
  renderRep,
  selection,
  shouldRenderRootsInReps
};

/***/ }),
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */,
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */,
/* 179 */,
/* 180 */,
/* 181 */,
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stopSourceMapWorker = exports.startSourceMapWorker = exports.isOriginalId = exports.isGeneratedId = exports.generatedToOriginalId = exports.originalToGeneratedId = exports.getOriginalStackFrames = exports.hasMappedSource = exports.clearSourceMaps = exports.applySourceMap = exports.getOriginalSourceText = exports.getLocationScopes = exports.getFileGeneratedRange = exports.getGeneratedRangesForOriginal = exports.getOriginalLocations = exports.getOriginalLocation = exports.getAllGeneratedLocations = exports.getGeneratedLocation = exports.getGeneratedRanges = exports.getOriginalRanges = exports.hasOriginalURL = exports.getOriginalURLs = exports.setAssetRootURL = exports.dispatcher = undefined;

var _utils = __webpack_require__(64);

Object.defineProperty(exports, "originalToGeneratedId", {
  enumerable: true,
  get: function () {
    return _utils.originalToGeneratedId;
  }
});
Object.defineProperty(exports, "generatedToOriginalId", {
  enumerable: true,
  get: function () {
    return _utils.generatedToOriginalId;
  }
});
Object.defineProperty(exports, "isGeneratedId", {
  enumerable: true,
  get: function () {
    return _utils.isGeneratedId;
  }
});
Object.defineProperty(exports, "isOriginalId", {
  enumerable: true,
  get: function () {
    return _utils.isOriginalId;
  }
});

var _devtoolsSourceMap = __webpack_require__(182);

var self = _interopRequireWildcard(_devtoolsSourceMap);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const {
  workerUtils: { WorkerDispatcher }
} = __webpack_require__(7);

const dispatcher = exports.dispatcher = new WorkerDispatcher();

const _getGeneratedRanges = dispatcher.task("getGeneratedRanges", {
  queue: true
});

const _getGeneratedLocation = dispatcher.task("getGeneratedLocation", {
  queue: true
});
const _getAllGeneratedLocations = dispatcher.task("getAllGeneratedLocations", {
  queue: true
});

const _getOriginalLocation = dispatcher.task("getOriginalLocation", {
  queue: true
});

const setAssetRootURL = exports.setAssetRootURL = async assetRoot => dispatcher.invoke("setAssetRootURL", assetRoot);

const getOriginalURLs = exports.getOriginalURLs = async generatedSource => dispatcher.invoke("getOriginalURLs", generatedSource);

const hasOriginalURL = exports.hasOriginalURL = async url => dispatcher.invoke("hasOriginalURL", url);

const getOriginalRanges = exports.getOriginalRanges = async (sourceId, url) => dispatcher.invoke("getOriginalRanges", sourceId, url);
const getGeneratedRanges = exports.getGeneratedRanges = async (location, originalSource) => _getGeneratedRanges(location, originalSource);

const getGeneratedLocation = exports.getGeneratedLocation = async (location, originalSource) => _getGeneratedLocation(location, originalSource);

const getAllGeneratedLocations = exports.getAllGeneratedLocations = async (location, originalSource) => _getAllGeneratedLocations(location, originalSource);

const getOriginalLocation = exports.getOriginalLocation = async (location, options = {}) => _getOriginalLocation(location, options);

const getOriginalLocations = exports.getOriginalLocations = async (sourceId, locations, options = {}) => dispatcher.invoke("getOriginalLocations", locations, options);

const getGeneratedRangesForOriginal = exports.getGeneratedRangesForOriginal = async (sourceId, url, mergeUnmappedRegions) => dispatcher.invoke("getGeneratedRangesForOriginal", sourceId, url, mergeUnmappedRegions);

const getFileGeneratedRange = exports.getFileGeneratedRange = async originalSource => dispatcher.invoke("getFileGeneratedRange", originalSource);

const getLocationScopes = exports.getLocationScopes = dispatcher.task("getLocationScopes");

const getOriginalSourceText = exports.getOriginalSourceText = async originalSource => dispatcher.invoke("getOriginalSourceText", originalSource);

const applySourceMap = exports.applySourceMap = async (generatedId, url, code, mappings) => dispatcher.invoke("applySourceMap", generatedId, url, code, mappings);

const clearSourceMaps = exports.clearSourceMaps = async () => dispatcher.invoke("clearSourceMaps");

const hasMappedSource = exports.hasMappedSource = async location => dispatcher.invoke("hasMappedSource", location);

const getOriginalStackFrames = exports.getOriginalStackFrames = async generatedLocation => dispatcher.invoke("getOriginalStackFrames", generatedLocation);

const startSourceMapWorker = exports.startSourceMapWorker = (url, assetRoot) => {
  dispatcher.start(url);
  setAssetRootURL(assetRoot);
};
const stopSourceMapWorker = exports.stopSourceMapWorker = dispatcher.stop.bind(dispatcher);

exports.default = self;

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

const Menu = __webpack_require__(421);
const MenuItem = __webpack_require__(423);
const { PrefsHelper } = __webpack_require__(424);
const KeyShortcuts = __webpack_require__(425);
const { ZoomKeys } = __webpack_require__(426);
const EventEmitter = __webpack_require__(65);
const asyncStorage = __webpack_require__(427);
const SourceUtils = __webpack_require__(428);
const Telemetry = __webpack_require__(429);
const { getUnicodeHostname, getUnicodeUrlPath, getUnicodeUrl } = __webpack_require__(430);

module.exports = {
  KeyShortcuts,
  Menu,
  MenuItem,
  PrefsHelper,
  ZoomKeys,
  asyncStorage,
  EventEmitter,
  SourceUtils,
  Telemetry,
  getUnicodeHostname,
  getUnicodeUrlPath,
  getUnicodeUrl
};

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

(function() {
  var Query, coreChars, countDir, getCharCodes, getExtension, opt_char_re, truncatedUpperCase, _ref;

  _ref = __webpack_require__(111), countDir = _ref.countDir, getExtension = _ref.getExtension;

  module.exports = Query = (function() {
    function Query(query, _arg) {
      var optCharRegEx, pathSeparator, _ref1;
      _ref1 = _arg != null ? _arg : {}, optCharRegEx = _ref1.optCharRegEx, pathSeparator = _ref1.pathSeparator;
      if (!(query && query.length)) {
        return null;
      }
      this.query = query;
      this.query_lw = query.toLowerCase();
      this.core = coreChars(query, optCharRegEx);
      this.core_lw = this.core.toLowerCase();
      this.core_up = truncatedUpperCase(this.core);
      this.depth = countDir(query, query.length, pathSeparator);
      this.ext = getExtension(this.query_lw);
      this.charCodes = getCharCodes(this.query_lw);
    }

    return Query;

  })();

  opt_char_re = /[ _\-:\/\\]/g;

  coreChars = function(query, optCharRegEx) {
    if (optCharRegEx == null) {
      optCharRegEx = opt_char_re;
    }
    return query.replace(optCharRegEx, '');
  };

  truncatedUpperCase = function(str) {
    var char, upper, _i, _len;
    upper = "";
    for (_i = 0, _len = str.length; _i < _len; _i++) {
      char = str[_i];
      upper += char.toUpperCase()[0];
    }
    return upper;
  };

  getCharCodes = function(str) {
    var charCodes, i, len;
    len = str.length;
    i = -1;
    charCodes = [];
    while (++i < len) {
      charCodes[str.charCodeAt(i)] = true;
    }
    return charCodes;
  };

}).call(this);


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _tab = __webpack_require__(186);

var _tab2 = _interopRequireDefault(_tab);

var _tabList = __webpack_require__(441);

var _tabList2 = _interopRequireDefault(_tabList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TabList = function (_React$Component) {
  _inherits(TabList, _React$Component);

  function TabList(props) {
    _classCallCheck(this, TabList);

    var _this = _possibleConstructorReturn(this, (TabList.__proto__ || Object.getPrototypeOf(TabList)).call(this, props));

    var childrenCount = _react2.default.Children.count(props.children);

    _this.handleKeyPress = _this.handleKeyPress.bind(_this);
    _this.tabRefs = new Array(childrenCount).fill(0).map(function () {
      return _react2.default.createRef();
    });
    _this.handlers = _this.getHandlers(props.vertical);
    return _this;
  }

  _createClass(TabList, [{
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      if (prevProps.activeIndex !== this.props.activeIndex) {
        this.tabRefs[this.props.activeIndex].current.focus();
      }
    }
  }, {
    key: 'getHandlers',
    value: function getHandlers(vertical) {
      if (vertical) {
        return {
          ArrowDown: this.next.bind(this),
          ArrowUp: this.previous.bind(this)
        };
      }
      return {
        ArrowLeft: this.previous.bind(this),
        ArrowRight: this.next.bind(this)
      };
    }
  }, {
    key: 'wrapIndex',
    value: function wrapIndex(index) {
      var count = _react2.default.Children.count(this.props.children);
      return (index + count) % count;
    }
  }, {
    key: 'handleKeyPress',
    value: function handleKeyPress(event) {
      var handler = this.handlers[event.key];
      if (handler) {
        handler();
      }
    }
  }, {
    key: 'previous',
    value: function previous() {
      var newIndex = this.wrapIndex(this.props.activeIndex - 1);
      this.props.onActivateTab(newIndex);
    }
  }, {
    key: 'next',
    value: function next() {
      var newIndex = this.wrapIndex(this.props.activeIndex + 1);
      this.props.onActivateTab(newIndex);
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          accessibleId = _props.accessibleId,
          activeIndex = _props.activeIndex,
          children = _props.children,
          className = _props.className,
          onActivateTab = _props.onActivateTab;


      return _react2.default.createElement(
        'ul',
        { className: className, onKeyUp: this.handleKeyPress, role: 'tablist' },
        _react2.default.Children.map(children, function (child, index) {
          if (child.type !== _tab2.default) {
            throw new Error('Direct children of a <TabList> must be a <Tab>');
          }

          var active = index === activeIndex;
          var tabRef = _this2.tabRefs[index];

          return _react2.default.cloneElement(child, {
            accessibleId: active ? accessibleId : undefined,
            active: active,
            tabRef: tabRef,
            onActivate: function onActivate() {
              return onActivateTab(index);
            }
          });
        })
      );
    }
  }]);

  return TabList;
}(_react2.default.Component);

exports.default = TabList;


TabList.propTypes = {
  accessibleId: _propTypes2.default.string,
  activeIndex: _propTypes2.default.number,
  children: _propTypes2.default.node,
  className: _propTypes2.default.string,
  onActivateTab: _propTypes2.default.func,
  vertical: _propTypes2.default.bool
};

TabList.defaultProps = {
  accessibleId: undefined,
  activeIndex: 0,
  children: null,
  className: _tabList2.default.container,
  onActivateTab: function onActivateTab() {},
  vertical: false
};

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Tab;

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _ref2 = __webpack_require__(439);

var _ref3 = _interopRequireDefault(_ref2);

var _tab = __webpack_require__(440);

var _tab2 = _interopRequireDefault(_tab);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Tab(_ref) {
  var accessibleId = _ref.accessibleId,
      active = _ref.active,
      children = _ref.children,
      className = _ref.className,
      onActivate = _ref.onActivate,
      tabRef = _ref.tabRef;

  return _react2.default.createElement(
    'li',
    {
      'aria-selected': active,
      className: className,
      id: accessibleId,
      onClick: onActivate,
      onKeyDown: function onKeyDown() {},
      ref: tabRef,
      role: 'tab',
      tabIndex: active ? 0 : undefined
    },
    children
  );
}

Tab.propTypes = {
  accessibleId: _propTypes2.default.string,
  active: _propTypes2.default.bool,
  children: _propTypes2.default.node.isRequired,
  className: _propTypes2.default.string,
  onActivate: _propTypes2.default.func,
  tabRef: _ref3.default
};

Tab.defaultProps = {
  accessibleId: undefined,
  active: false,
  className: _tab2.default.container,
  onActivate: undefined,
  tabRef: undefined
};

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = TabPanels;

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function TabPanels(_ref) {
  var accessibleId = _ref.accessibleId,
      activeIndex = _ref.activeIndex,
      children = _ref.children,
      className = _ref.className,
      hasFocusableContent = _ref.hasFocusableContent;

  return _react2.default.createElement(
    'div',
    {
      'aria-labelledby': accessibleId,
      role: 'tabpanel',
      className: className,
      tabIndex: hasFocusableContent ? undefined : 0
    },
    _react2.default.Children.toArray(children)[activeIndex]
  );
}

TabPanels.propTypes = {
  accessibleId: _propTypes2.default.string,
  activeIndex: _propTypes2.default.number,
  children: _propTypes2.default.node.isRequired,
  className: _propTypes2.default.string,
  hasFocusableContent: _propTypes2.default.bool.isRequired
};

TabPanels.defaultProps = {
  accessibleId: undefined,
  activeIndex: 0,
  className: null
};

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// Dependencies
const PropTypes = __webpack_require__(0);

const { getGripType, wrapRender } = __webpack_require__(2);

const dom = __webpack_require__(1);
const { span } = dom;

/**
 * Renders a number
 */
BigInt.propTypes = {
  object: PropTypes.oneOfType([PropTypes.object, PropTypes.number, PropTypes.bool]).isRequired
};

function BigInt(props) {
  const { text } = props.object;

  return span({ className: "objectBox objectBox-number" }, `${text}n`);
}

function supportsObject(object, noGrip = false) {
  return getGripType(object, noGrip) === "BigInt";
}

// Exports from this module

module.exports = {
  rep: wrapRender(BigInt),
  supportsObject
};

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// ReactJS
const PropTypes = __webpack_require__(0);

// Reps
const { getGripType, isGrip, cropString, wrapRender } = __webpack_require__(2);
const { MODE } = __webpack_require__(4);

const dom = __webpack_require__(1);
const { span } = dom;

const IGNORED_SOURCE_URLS = ["debugger eval code"];

/**
 * This component represents a template for Function objects.
 */
FunctionRep.propTypes = {
  object: PropTypes.object.isRequired,
  parameterNames: PropTypes.array,
  onViewSourceInDebugger: PropTypes.func
};

function FunctionRep(props) {
  const { object: grip, onViewSourceInDebugger, recordTelemetryEvent } = props;

  let jumpToDefinitionButton;
  if (onViewSourceInDebugger && grip.location && grip.location.url && !IGNORED_SOURCE_URLS.includes(grip.location.url)) {
    jumpToDefinitionButton = dom.button({
      className: "jump-definition",
      draggable: false,
      title: "Jump to definition",
      onClick: e => {
        // Stop the event propagation so we don't trigger ObjectInspector
        // expand/collapse.
        e.stopPropagation();
        if (recordTelemetryEvent) {
          recordTelemetryEvent("jump_to_definition");
        }
        onViewSourceInDebugger(grip.location);
      }
    });
  }

  return span({
    "data-link-actor-id": grip.actor,
    className: "objectBox objectBox-function",
    // Set dir="ltr" to prevent function parentheses from
    // appearing in the wrong direction
    dir: "ltr"
  }, getTitle(grip, props), getFunctionName(grip, props), "(", ...renderParams(props), ")", jumpToDefinitionButton);
}

function getTitle(grip, props) {
  const { mode } = props;

  if (mode === MODE.TINY && !grip.isGenerator && !grip.isAsync) {
    return null;
  }

  let title = mode === MODE.TINY ? "" : "function ";

  if (grip.isGenerator) {
    title = mode === MODE.TINY ? "* " : "function* ";
  }

  if (grip.isAsync) {
    title = `${"async" + " "}${title}`;
  }

  return span({
    className: "objectTitle"
  }, title);
}

/**
 * Returns a ReactElement representing the function name.
 *
 * @param {Object} grip : Function grip
 * @param {Object} props: Function rep props
 */
function getFunctionName(grip, props = {}) {
  let { functionName } = props;
  let name;

  if (functionName) {
    const end = functionName.length - 1;
    functionName = functionName.startsWith('"') && functionName.endsWith('"') ? functionName.substring(1, end) : functionName;
  }

  if (grip.displayName != undefined && functionName != undefined && grip.displayName != functionName) {
    name = `${functionName}:${grip.displayName}`;
  } else {
    name = cleanFunctionName(grip.userDisplayName || grip.displayName || grip.name || props.functionName || "");
  }

  return cropString(name, 100);
}

const objectProperty = /([\w\d\$]+)$/;
const arrayProperty = /\[(.*?)\]$/;
const functionProperty = /([\w\d]+)[\/\.<]*?$/;
const annonymousProperty = /([\w\d]+)\(\^\)$/;

/**
 * Decodes an anonymous naming scheme that
 * spider monkey implements based on "Naming Anonymous JavaScript Functions"
 * http://johnjbarton.github.io/nonymous/index.html
 *
 * @param {String} name : Function name to clean up
 * @returns String
 */
function cleanFunctionName(name) {
  for (const reg of [objectProperty, arrayProperty, functionProperty, annonymousProperty]) {
    const match = reg.exec(name);
    if (match) {
      return match[1];
    }
  }

  return name;
}

function renderParams(props) {
  const { parameterNames = [] } = props;

  return parameterNames.filter(param => param).reduce((res, param, index, arr) => {
    res.push(span({ className: "param" }, param));
    if (index < arr.length - 1) {
      res.push(span({ className: "delimiter" }, ", "));
    }
    return res;
  }, []);
}

// Registration
function supportsObject(grip, noGrip = false) {
  const type = getGripType(grip, noGrip);
  if (noGrip === true || !isGrip(grip)) {
    return type == "function";
  }

  return type == "Function";
}

// Exports from this module

module.exports = {
  rep: wrapRender(FunctionRep),
  supportsObject,
  cleanFunctionName,
  // exported for testing purpose.
  getFunctionName
};

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

module.exports = {
  ELEMENT_NODE: 1,
  ATTRIBUTE_NODE: 2,
  TEXT_NODE: 3,
  CDATA_SECTION_NODE: 4,
  ENTITY_REFERENCE_NODE: 5,
  ENTITY_NODE: 6,
  PROCESSING_INSTRUCTION_NODE: 7,
  COMMENT_NODE: 8,
  DOCUMENT_NODE: 9,
  DOCUMENT_TYPE_NODE: 10,
  DOCUMENT_FRAGMENT_NODE: 11,
  NOTATION_NODE: 12,

  // DocumentPosition
  DOCUMENT_POSITION_DISCONNECTED: 0x01,
  DOCUMENT_POSITION_PRECEDING: 0x02,
  DOCUMENT_POSITION_FOLLOWING: 0x04,
  DOCUMENT_POSITION_CONTAINS: 0x08,
  DOCUMENT_POSITION_CONTAINED_BY: 0x10,
  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 0x20
};

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// ReactJS
const PropTypes = __webpack_require__(0);
// Utils
const { getGripType, isGrip, wrapRender } = __webpack_require__(2);
const { cleanFunctionName } = __webpack_require__(189);
const { isLongString } = __webpack_require__(25);
const { MODE } = __webpack_require__(4);

const dom = __webpack_require__(1);
const { span } = dom;
const IGNORED_SOURCE_URLS = ["debugger eval code"];

/**
 * Renders Error objects.
 */
ErrorRep.propTypes = {
  object: PropTypes.object.isRequired,
  // @TODO Change this to Object.values when supported in Node's version of V8
  mode: PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key])),
  // An optional function that will be used to render the Error stacktrace.
  renderStacktrace: PropTypes.func
};

function ErrorRep(props) {
  const object = props.object;
  const preview = object.preview;

  let name;
  if (preview && preview.name && preview.kind) {
    switch (preview.kind) {
      case "Error":
        name = preview.name;
        break;
      case "DOMException":
        name = preview.kind;
        break;
      default:
        throw new Error("Unknown preview kind for the Error rep.");
    }
  } else {
    name = "Error";
  }

  const content = [];

  if (props.mode === MODE.TINY) {
    content.push(name);
  } else {
    content.push(`${name}: "${preview.message}"`);
  }

  if (preview.stack && props.mode !== MODE.TINY) {
    const stacktrace = props.renderStacktrace ? props.renderStacktrace(parseStackString(preview.stack)) : getStacktraceElements(props, preview);
    content.push(stacktrace);
  }

  return span({
    "data-link-actor-id": object.actor,
    className: "objectBox-stackTrace"
  }, content);
}

/**
 * Returns a React element reprensenting the Error stacktrace, i.e.
 * transform error.stack from:
 *
 * semicolon@debugger eval code:1:109
 * jkl@debugger eval code:1:63
 * asdf@debugger eval code:1:28
 * @debugger eval code:1:227
 *
 * Into a column layout:
 *
 * semicolon  (<anonymous>:8:10)
 * jkl        (<anonymous>:5:10)
 * asdf       (<anonymous>:2:10)
 *            (<anonymous>:11:1)
 */
function getStacktraceElements(props, preview) {
  const stack = [];
  if (!preview.stack) {
    return stack;
  }

  parseStackString(preview.stack).forEach((frame, index, frames) => {
    let onLocationClick;
    const {
      filename,
      lineNumber,
      columnNumber,
      functionName,
      location
    } = frame;

    if (props.onViewSourceInDebugger && !IGNORED_SOURCE_URLS.includes(filename)) {
      onLocationClick = e => {
        // Don't trigger ObjectInspector expand/collapse.
        e.stopPropagation();
        props.onViewSourceInDebugger({
          url: filename,
          line: lineNumber,
          column: columnNumber
        });
      };
    }

    stack.push("\t", span({
      key: `fn${index}`,
      className: "objectBox-stackTrace-fn"
    }, cleanFunctionName(functionName)), " ", span({
      key: `location${index}`,
      className: "objectBox-stackTrace-location",
      onClick: onLocationClick,
      title: onLocationClick ? `View source in debugger → ${location}` : undefined
    }, location), "\n");
  });

  return span({
    key: "stack",
    className: "objectBox-stackTrace-grid"
  }, stack);
}

/**
 * Parse a string that should represent a stack trace and returns an array of
 * the frames. The shape of the frames are extremely important as they can then
 * be processed here or in the toolbox by other components.
 * @param {String} stack
 * @returns {Array} Array of frames, which are object with the following shape:
 *                  - {String} filename
 *                  - {String} functionName
 *                  - {String} location
 *                  - {Number} columnNumber
 *                  - {Number} lineNumber
 */
function parseStackString(stack) {
  const res = [];
  if (!stack) {
    return res;
  }

  const isStacktraceALongString = isLongString(stack);
  const stackString = isStacktraceALongString ? stack.initial : stack;

  stackString.split("\n").forEach((frame, index, frames) => {
    if (!frame) {
      // Skip any blank lines
      return;
    }

    // If the stacktrace is a longString, don't include the last frame in the
    // array, since it is certainly incomplete.
    // Can be removed when https://bugzilla.mozilla.org/show_bug.cgi?id=1448833
    // is fixed.
    if (isStacktraceALongString && index === frames.length - 1) {
      return;
    }

    let functionName;
    let location;

    // Given the input: "functionName@scriptLocation:2:100"
    // Result: [
    //   "functionName@scriptLocation:2:100",
    //   "functionName",
    //   "scriptLocation:2:100"
    // ]
    const result = frame.match(/^(.*)@(.*)$/);
    if (result && result.length === 3) {
      functionName = result[1];

      // If the resource was loaded by base-loader.js, the location looks like:
      // resource://devtools/shared/base-loader.js -> resource://path/to/file.js .
      // What's needed is only the last part after " -> ".
      location = result[2].split(" -> ").pop();
    }

    if (!functionName) {
      functionName = "<anonymous>";
    }

    // Given the input: "scriptLocation:2:100"
    // Result:
    // ["scriptLocation:2:100", "scriptLocation", "2", "100"]
    const locationParts = location ? location.match(/^(.*):(\d+):(\d+)$/) : null;

    if (location && locationParts) {
      const [, filename, line, column] = locationParts;
      res.push({
        filename,
        functionName,
        location,
        columnNumber: Number(column),
        lineNumber: Number(line)
      });
    }
  });

  return res;
}

// Registration
function supportsObject(object, noGrip = false) {
  if (noGrip === true || !isGrip(object)) {
    return false;
  }
  return object.preview && getGripType(object, noGrip) === "Error" || object.class === "DOMException";
}

// Exports from this module
module.exports = {
  rep: wrapRender(ErrorRep),
  supportsObject
};

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// Dependencies
const PropTypes = __webpack_require__(0);

const { lengthBubble } = __webpack_require__(193);
const {
  interleave,
  getGripType,
  isGrip,
  wrapRender,
  ellipsisElement
} = __webpack_require__(2);
const { MODE } = __webpack_require__(4);

const dom = __webpack_require__(1);
const { span } = dom;
const { ModePropType } = __webpack_require__(38);
const DEFAULT_TITLE = "Array";

/**
 * Renders an array. The array is enclosed by left and right bracket
 * and the max number of rendered items depends on the current mode.
 */
GripArray.propTypes = {
  object: PropTypes.object.isRequired,
  // @TODO Change this to Object.values when supported in Node's version of V8
  mode: ModePropType,
  provider: PropTypes.object,
  onDOMNodeMouseOver: PropTypes.func,
  onDOMNodeMouseOut: PropTypes.func,
  onInspectIconClick: PropTypes.func
};

function GripArray(props) {
  const { object, mode = MODE.SHORT } = props;

  let brackets;
  const needSpace = function (space) {
    return space ? { left: "[ ", right: " ]" } : { left: "[", right: "]" };
  };

  const config = {
    "data-link-actor-id": object.actor,
    className: "objectBox objectBox-array"
  };

  const title = getTitle(props, object);

  if (mode === MODE.TINY) {
    const isEmpty = getLength(object) === 0;

    // Omit bracketed ellipsis for non-empty non-Array arraylikes (f.e: Sets).
    if (!isEmpty && object.class !== "Array") {
      return span(config, title);
    }

    brackets = needSpace(false);
    return span(config, title, span({
      className: "arrayLeftBracket"
    }, brackets.left), isEmpty ? null : ellipsisElement, span({
      className: "arrayRightBracket"
    }, brackets.right));
  }

  const max = maxLengthMap.get(mode);
  const items = arrayIterator(props, object, max);
  brackets = needSpace(items.length > 0);

  return span({
    "data-link-actor-id": object.actor,
    className: "objectBox objectBox-array"
  }, title, span({
    className: "arrayLeftBracket"
  }, brackets.left), ...interleave(items, ", "), span({
    className: "arrayRightBracket"
  }, brackets.right), span({
    className: "arrayProperties",
    role: "group"
  }));
}

function getLength(grip) {
  if (!grip.preview) {
    return 0;
  }

  return grip.preview.length || grip.preview.childNodesLength || 0;
}

function getTitle(props, object) {
  const objectLength = getLength(object);
  const isEmpty = objectLength === 0;

  let title = props.title || object.class || DEFAULT_TITLE;

  const length = lengthBubble({
    object,
    mode: props.mode,
    maxLengthMap,
    getLength
  });

  if (props.mode === MODE.TINY) {
    if (isEmpty) {
      if (object.class === DEFAULT_TITLE) {
        return null;
      }

      return span({ className: "objectTitle" }, `${title} `);
    }

    let trailingSpace;
    if (object.class === DEFAULT_TITLE) {
      title = null;
      trailingSpace = " ";
    }

    return span({ className: "objectTitle" }, title, length, trailingSpace);
  }

  return span({ className: "objectTitle" }, title, length, " ");
}

function getPreviewItems(grip) {
  if (!grip.preview) {
    return null;
  }

  return grip.preview.items || grip.preview.childNodes || [];
}

function arrayIterator(props, grip, max) {
  const { Rep } = __webpack_require__(24);

  let items = [];
  const gripLength = getLength(grip);

  if (!gripLength) {
    return items;
  }

  const previewItems = getPreviewItems(grip);
  const provider = props.provider;

  let emptySlots = 0;
  let foldedEmptySlots = 0;
  items = previewItems.reduce((res, itemGrip) => {
    if (res.length >= max) {
      return res;
    }

    let object;
    try {
      if (!provider && itemGrip === null) {
        emptySlots++;
        return res;
      }

      object = provider ? provider.getValue(itemGrip) : itemGrip;
    } catch (exc) {
      object = exc;
    }

    if (emptySlots > 0) {
      res.push(getEmptySlotsElement(emptySlots));
      foldedEmptySlots = foldedEmptySlots + emptySlots - 1;
      emptySlots = 0;
    }

    if (res.length < max) {
      res.push(Rep({
        ...props,
        object,
        mode: MODE.TINY,
        // Do not propagate title to array items reps
        title: undefined
      }));
    }

    return res;
  }, []);

  // Handle trailing empty slots if there are some.
  if (items.length < max && emptySlots > 0) {
    items.push(getEmptySlotsElement(emptySlots));
    foldedEmptySlots = foldedEmptySlots + emptySlots - 1;
  }

  const itemsShown = items.length + foldedEmptySlots;
  if (gripLength > itemsShown) {
    items.push(ellipsisElement);
  }

  return items;
}

function getEmptySlotsElement(number) {
  // TODO: Use l10N - See https://github.com/firefox-devtools/reps/issues/141
  return `<${number} empty slot${number > 1 ? "s" : ""}>`;
}

function supportsObject(grip, noGrip = false) {
  if (noGrip === true || !isGrip(grip)) {
    return false;
  }

  return grip.preview && (grip.preview.kind == "ArrayLike" || getGripType(grip, noGrip) === "DocumentFragment");
}

const maxLengthMap = new Map();
maxLengthMap.set(MODE.SHORT, 3);
maxLengthMap.set(MODE.LONG, 10);

// Exports from this module
module.exports = {
  rep: wrapRender(GripArray),
  supportsObject,
  maxLengthMap,
  getLength
};

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const PropTypes = __webpack_require__(0);

const { wrapRender } = __webpack_require__(2);
const { MODE } = __webpack_require__(4);
const { ModePropType } = __webpack_require__(38);

const dom = __webpack_require__(1);
const { span } = dom;

GripLengthBubble.propTypes = {
  object: PropTypes.object.isRequired,
  maxLengthMap: PropTypes.instanceOf(Map).isRequired,
  getLength: PropTypes.func.isRequired,
  mode: ModePropType,
  visibilityThreshold: PropTypes.number
};

function GripLengthBubble(props) {
  const {
    object,
    mode = MODE.SHORT,
    visibilityThreshold = 2,
    maxLengthMap,
    getLength,
    showZeroLength = false
  } = props;

  const length = getLength(object);
  const isEmpty = length === 0;
  const isObvious = [MODE.SHORT, MODE.LONG].includes(mode) && length > 0 && length <= maxLengthMap.get(mode) && length <= visibilityThreshold;
  if (isEmpty && !showZeroLength || isObvious) {
    return "";
  }

  return span({
    className: "objectLengthBubble"
  }, `(${length})`);
}

module.exports = {
  lengthBubble: wrapRender(GripLengthBubble)
};

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// Dependencies

const { lengthBubble } = __webpack_require__(193);
const PropTypes = __webpack_require__(0);
const {
  interleave,
  isGrip,
  wrapRender,
  ellipsisElement
} = __webpack_require__(2);
const PropRep = __webpack_require__(39);
const { MODE } = __webpack_require__(4);
const { ModePropType } = __webpack_require__(38);

const { span } = __webpack_require__(1);

/**
 * Renders an map. A map is represented by a list of its
 * entries enclosed in curly brackets.
 */
GripMap.propTypes = {
  object: PropTypes.object,
  // @TODO Change this to Object.values when supported in Node's version of V8
  mode: ModePropType,
  isInterestingEntry: PropTypes.func,
  onDOMNodeMouseOver: PropTypes.func,
  onDOMNodeMouseOut: PropTypes.func,
  onInspectIconClick: PropTypes.func,
  title: PropTypes.string
};

function GripMap(props) {
  const { mode, object } = props;

  const config = {
    "data-link-actor-id": object.actor,
    className: "objectBox objectBox-object"
  };

  const title = getTitle(props, object);
  const isEmpty = getLength(object) === 0;

  if (isEmpty || mode === MODE.TINY) {
    return span(config, title);
  }

  const propsArray = safeEntriesIterator(props, object, maxLengthMap.get(mode));

  return span(config, title, span({
    className: "objectLeftBrace"
  }, " { "), ...interleave(propsArray, ", "), span({
    className: "objectRightBrace"
  }, " }"));
}

function getTitle(props, object) {
  const title = props.title || (object && object.class ? object.class : "Map");
  return span({
    className: "objectTitle"
  }, title, lengthBubble({
    object,
    mode: props.mode,
    maxLengthMap,
    getLength,
    showZeroLength: true
  }));
}

function safeEntriesIterator(props, object, max) {
  max = typeof max === "undefined" ? 3 : max;
  try {
    return entriesIterator(props, object, max);
  } catch (err) {
    console.error(err);
  }
  return [];
}

function entriesIterator(props, object, max) {
  // Entry filter. Show only interesting entries to the user.
  const isInterestingEntry = props.isInterestingEntry || ((type, value) => {
    return type == "boolean" || type == "number" || type == "string" && value.length != 0;
  });

  const mapEntries = object.preview && object.preview.entries ? object.preview.entries : [];

  let indexes = getEntriesIndexes(mapEntries, max, isInterestingEntry);
  if (indexes.length < max && indexes.length < mapEntries.length) {
    // There are not enough entries yet, so we add uninteresting entries.
    indexes = indexes.concat(getEntriesIndexes(mapEntries, max - indexes.length, (t, value, name) => {
      return !isInterestingEntry(t, value, name);
    }));
  }

  const entries = getEntries(props, mapEntries, indexes);
  if (entries.length < getLength(object)) {
    // There are some undisplayed entries. Then display "…".
    entries.push(ellipsisElement);
  }

  return entries;
}

/**
 * Get entries ordered by index.
 *
 * @param {Object} props Component props.
 * @param {Array} entries Entries array.
 * @param {Array} indexes Indexes of entries.
 * @return {Array} Array of PropRep.
 */
function getEntries(props, entries, indexes) {
  const { onDOMNodeMouseOver, onDOMNodeMouseOut, onInspectIconClick } = props;

  // Make indexes ordered by ascending.
  indexes.sort(function (a, b) {
    return a - b;
  });

  return indexes.map((index, i) => {
    const [key, entryValue] = entries[index];
    const value = entryValue.value !== undefined ? entryValue.value : entryValue;

    return PropRep({
      name: key,
      equal: " \u2192 ",
      object: value,
      mode: MODE.TINY,
      onDOMNodeMouseOver,
      onDOMNodeMouseOut,
      onInspectIconClick
    });
  });
}

/**
 * Get the indexes of entries in the map.
 *
 * @param {Array} entries Entries array.
 * @param {Number} max The maximum length of indexes array.
 * @param {Function} filter Filter the entry you want.
 * @return {Array} Indexes of filtered entries in the map.
 */
function getEntriesIndexes(entries, max, filter) {
  return entries.reduce((indexes, [key, entry], i) => {
    if (indexes.length < max) {
      const value = entry && entry.value !== undefined ? entry.value : entry;
      // Type is specified in grip's "class" field and for primitive
      // values use typeof.
      const type = (value && value.class ? value.class : typeof value).toLowerCase();

      if (filter(type, value, key)) {
        indexes.push(i);
      }
    }

    return indexes;
  }, []);
}

function getLength(grip) {
  return grip.preview.size || 0;
}

function supportsObject(grip, noGrip = false) {
  if (noGrip === true || !isGrip(grip)) {
    return false;
  }
  return grip.preview && grip.preview.kind == "MapLike";
}

const maxLengthMap = new Map();
maxLengthMap.set(MODE.SHORT, 3);
maxLengthMap.set(MODE.LONG, 10);

// Exports from this module
module.exports = {
  rep: wrapRender(GripMap),
  supportsObject,
  maxLengthMap,
  getLength
};

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// Dependencies
const PropTypes = __webpack_require__(0);
// Shortcuts
const dom = __webpack_require__(1);
const { span } = dom;
const { wrapRender } = __webpack_require__(2);
const PropRep = __webpack_require__(39);
const { MODE } = __webpack_require__(4);
/**
 * Renders an map entry. A map entry is represented by its key,
 * a column and its value.
 */
GripMapEntry.propTypes = {
  object: PropTypes.object,
  // @TODO Change this to Object.values when supported in Node's version of V8
  mode: PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key])),
  onDOMNodeMouseOver: PropTypes.func,
  onDOMNodeMouseOut: PropTypes.func,
  onInspectIconClick: PropTypes.func
};

function GripMapEntry(props) {
  const { object } = props;

  const { key, value } = object.preview;

  return span({
    className: "objectBox objectBox-map-entry"
  }, PropRep({
    ...props,
    name: key,
    object: value,
    equal: " \u2192 ",
    title: null,
    suppressQuotes: false
  }));
}

function supportsObject(grip, noGrip = false) {
  if (noGrip === true) {
    return false;
  }
  return grip && (grip.type === "mapEntry" || grip.type === "storageEntry") && grip.preview;
}

function createGripMapEntry(key, value) {
  return {
    type: "mapEntry",
    preview: {
      key,
      value
    }
  };
}

// Exports from this module
module.exports = {
  rep: wrapRender(GripMapEntry),
  createGripMapEntry,
  supportsObject
};

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const {
  enumEntries,
  enumIndexedProperties,
  enumNonIndexedProperties,
  getPrototype,
  enumSymbols,
  getFullText
} = __webpack_require__(197);

const {
  getClosestGripNode,
  getClosestNonBucketNode,
  getValue,
  nodeHasAccessors,
  nodeHasAllEntriesInPreview,
  nodeHasProperties,
  nodeIsBucket,
  nodeIsDefaultProperties,
  nodeIsEntries,
  nodeIsMapEntry,
  nodeIsPrimitive,
  nodeIsProxy,
  nodeNeedsNumericalBuckets,
  nodeIsLongString
} = __webpack_require__(114);

function loadItemProperties(item, createObjectClient, createLongStringClient, loadedProperties) {
  const gripItem = getClosestGripNode(item);
  const value = getValue(gripItem);

  const [start, end] = item.meta ? [item.meta.startIndex, item.meta.endIndex] : [];

  const promises = [];
  let objectClient;
  const getObjectClient = () => objectClient || createObjectClient(value);

  if (shouldLoadItemIndexedProperties(item, loadedProperties)) {
    promises.push(enumIndexedProperties(getObjectClient(), start, end));
  }

  if (shouldLoadItemNonIndexedProperties(item, loadedProperties)) {
    promises.push(enumNonIndexedProperties(getObjectClient(), start, end));
  }

  if (shouldLoadItemEntries(item, loadedProperties)) {
    promises.push(enumEntries(getObjectClient(), start, end));
  }

  if (shouldLoadItemPrototype(item, loadedProperties)) {
    promises.push(getPrototype(getObjectClient()));
  }

  if (shouldLoadItemSymbols(item, loadedProperties)) {
    promises.push(enumSymbols(getObjectClient(), start, end));
  }

  if (shouldLoadItemFullText(item, loadedProperties)) {
    promises.push(getFullText(createLongStringClient(value), item));
  }

  return Promise.all(promises).then(mergeResponses);
}

function mergeResponses(responses) {
  const data = {};

  for (const response of responses) {
    if (response.hasOwnProperty("ownProperties")) {
      data.ownProperties = { ...data.ownProperties, ...response.ownProperties };
    }

    if (response.ownSymbols && response.ownSymbols.length > 0) {
      data.ownSymbols = response.ownSymbols;
    }

    if (response.prototype) {
      data.prototype = response.prototype;
    }

    if (response.fullText) {
      data.fullText = response.fullText;
    }
  }

  return data;
}

function shouldLoadItemIndexedProperties(item, loadedProperties = new Map()) {
  const gripItem = getClosestGripNode(item);
  const value = getValue(gripItem);

  return value && nodeHasProperties(gripItem) && !loadedProperties.has(item.path) && !nodeIsProxy(item) && !nodeNeedsNumericalBuckets(item) && !nodeIsEntries(getClosestNonBucketNode(item)) &&
  // The data is loaded when expanding the window node.
  !nodeIsDefaultProperties(item);
}

function shouldLoadItemNonIndexedProperties(item, loadedProperties = new Map()) {
  const gripItem = getClosestGripNode(item);
  const value = getValue(gripItem);

  return value && nodeHasProperties(gripItem) && !loadedProperties.has(item.path) && !nodeIsProxy(item) && !nodeIsEntries(getClosestNonBucketNode(item)) && !nodeIsBucket(item) &&
  // The data is loaded when expanding the window node.
  !nodeIsDefaultProperties(item);
}

function shouldLoadItemEntries(item, loadedProperties = new Map()) {
  const gripItem = getClosestGripNode(item);
  const value = getValue(gripItem);

  return value && nodeIsEntries(getClosestNonBucketNode(item)) && !nodeHasAllEntriesInPreview(gripItem) && !loadedProperties.has(item.path) && !nodeNeedsNumericalBuckets(item);
}

function shouldLoadItemPrototype(item, loadedProperties = new Map()) {
  const value = getValue(item);

  return value && !loadedProperties.has(item.path) && !nodeIsBucket(item) && !nodeIsMapEntry(item) && !nodeIsEntries(item) && !nodeIsDefaultProperties(item) && !nodeHasAccessors(item) && !nodeIsPrimitive(item) && !nodeIsLongString(item);
}

function shouldLoadItemSymbols(item, loadedProperties = new Map()) {
  const value = getValue(item);

  return value && !loadedProperties.has(item.path) && !nodeIsBucket(item) && !nodeIsMapEntry(item) && !nodeIsEntries(item) && !nodeIsDefaultProperties(item) && !nodeHasAccessors(item) && !nodeIsPrimitive(item) && !nodeIsLongString(item) && !nodeIsProxy(item);
}

function shouldLoadItemFullText(item, loadedProperties = new Map()) {
  return !loadedProperties.has(item.path) && nodeIsLongString(item);
}

module.exports = {
  loadItemProperties,
  mergeResponses,
  shouldLoadItemEntries,
  shouldLoadItemIndexedProperties,
  shouldLoadItemNonIndexedProperties,
  shouldLoadItemPrototype,
  shouldLoadItemSymbols,
  shouldLoadItemFullText
};

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { getValue, nodeHasFullText } = __webpack_require__(114); /* This Source Code Form is subject to the terms of the Mozilla Public
                                                                 * License, v. 2.0. If a copy of the MPL was not distributed with this
                                                                 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

async function enumIndexedProperties(objectClient, start, end) {
  try {
    const { iterator } = await objectClient.enumProperties({
      ignoreNonIndexedProperties: true
    });
    const response = await iteratorSlice(iterator, start, end);
    return response;
  } catch (e) {
    console.error("Error in enumIndexedProperties", e);
    return {};
  }
}

async function enumNonIndexedProperties(objectClient, start, end) {
  try {
    const { iterator } = await objectClient.enumProperties({
      ignoreIndexedProperties: true
    });
    const response = await iteratorSlice(iterator, start, end);
    return response;
  } catch (e) {
    console.error("Error in enumNonIndexedProperties", e);
    return {};
  }
}

async function enumEntries(objectClient, start, end) {
  try {
    const { iterator } = await objectClient.enumEntries();
    const response = await iteratorSlice(iterator, start, end);
    return response;
  } catch (e) {
    console.error("Error in enumEntries", e);
    return {};
  }
}

async function enumSymbols(objectClient, start, end) {
  try {
    const { iterator } = await objectClient.enumSymbols();
    const response = await iteratorSlice(iterator, start, end);
    return response;
  } catch (e) {
    console.error("Error in enumSymbols", e);
    return {};
  }
}

async function getPrototype(objectClient) {
  if (typeof objectClient.getPrototype !== "function") {
    console.error("objectClient.getPrototype is not a function");
    return Promise.resolve({});
  }
  return objectClient.getPrototype();
}

async function getFullText(longStringClient, item) {
  const { initial, fullText, length } = getValue(item);

  // Return fullText property if it exists so that it can be added to the
  // loadedProperties map.
  if (nodeHasFullText(item)) {
    return Promise.resolve({ fullText });
  }

  return new Promise((resolve, reject) => {
    longStringClient.substring(initial.length, length, response => {
      if (response.error) {
        console.error("LongStringClient.substring", `${response.error}: ${response.message}`);
        reject({});
        return;
      }

      resolve({
        fullText: initial + response.substring
      });
    });
  });
}

function iteratorSlice(iterator, start, end) {
  start = start || 0;
  const count = end ? end - start + 1 : iterator.count;

  if (count === 0) {
    return Promise.resolve({});
  }
  return iterator.slice(start, count);
}

module.exports = {
  enumEntries,
  enumIndexedProperties,
  enumNonIndexedProperties,
  enumSymbols,
  getPrototype,
  getFullText
};

/***/ }),
/* 198 */,
/* 199 */,
/* 200 */,
/* 201 */,
/* 202 */,
/* 203 */,
/* 204 */,
/* 205 */,
/* 206 */,
/* 207 */,
/* 208 */,
/* 209 */,
/* 210 */,
/* 211 */,
/* 212 */,
/* 213 */,
/* 214 */,
/* 215 */,
/* 216 */,
/* 217 */,
/* 218 */,
/* 219 */,
/* 220 */,
/* 221 */,
/* 222 */,
/* 223 */,
/* 224 */,
/* 225 */,
/* 226 */,
/* 227 */,
/* 228 */,
/* 229 */,
/* 230 */,
/* 231 */,
/* 232 */,
/* 233 */,
/* 234 */,
/* 235 */,
/* 236 */,
/* 237 */,
/* 238 */,
/* 239 */,
/* 240 */,
/* 241 */,
/* 242 */,
/* 243 */,
/* 244 */,
/* 245 */,
/* 246 */,
/* 247 */,
/* 248 */,
/* 249 */,
/* 250 */,
/* 251 */,
/* 252 */,
/* 253 */,
/* 254 */,
/* 255 */,
/* 256 */,
/* 257 */,
/* 258 */,
/* 259 */,
/* 260 */,
/* 261 */,
/* 262 */,
/* 263 */,
/* 264 */,
/* 265 */,
/* 266 */,
/* 267 */,
/* 268 */,
/* 269 */,
/* 270 */,
/* 271 */,
/* 272 */,
/* 273 */,
/* 274 */,
/* 275 */,
/* 276 */,
/* 277 */,
/* 278 */,
/* 279 */,
/* 280 */,
/* 281 */,
/* 282 */,
/* 283 */,
/* 284 */,
/* 285 */,
/* 286 */,
/* 287 */,
/* 288 */,
/* 289 */,
/* 290 */,
/* 291 */,
/* 292 */,
/* 293 */,
/* 294 */,
/* 295 */,
/* 296 */,
/* 297 */,
/* 298 */,
/* 299 */,
/* 300 */,
/* 301 */,
/* 302 */,
/* 303 */,
/* 304 */,
/* 305 */,
/* 306 */,
/* 307 */,
/* 308 */,
/* 309 */,
/* 310 */,
/* 311 */,
/* 312 */,
/* 313 */,
/* 314 */,
/* 315 */,
/* 316 */,
/* 317 */,
/* 318 */,
/* 319 */,
/* 320 */,
/* 321 */,
/* 322 */,
/* 323 */,
/* 324 */,
/* 325 */,
/* 326 */,
/* 327 */,
/* 328 */,
/* 329 */,
/* 330 */,
/* 331 */,
/* 332 */,
/* 333 */,
/* 334 */,
/* 335 */,
/* 336 */,
/* 337 */,
/* 338 */,
/* 339 */,
/* 340 */,
/* 341 */,
/* 342 */,
/* 343 */,
/* 344 */,
/* 345 */,
/* 346 */,
/* 347 */,
/* 348 */,
/* 349 */,
/* 350 */,
/* 351 */,
/* 352 */,
/* 353 */,
/* 354 */,
/* 355 */,
/* 356 */,
/* 357 */,
/* 358 */,
/* 359 */,
/* 360 */,
/* 361 */,
/* 362 */,
/* 363 */,
/* 364 */,
/* 365 */,
/* 366 */,
/* 367 */,
/* 368 */,
/* 369 */,
/* 370 */,
/* 371 */,
/* 372 */,
/* 373 */,
/* 374 */,
/* 375 */,
/* 376 */,
/* 377 */,
/* 378 */,
/* 379 */,
/* 380 */,
/* 381 */,
/* 382 */,
/* 383 */,
/* 384 */,
/* 385 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assert;

var _devtoolsEnvironment = __webpack_require__(102);

function assert(condition, message) {
  if ((0, _devtoolsEnvironment.isDevelopment)() && !condition) {
    throw new Error(`Assertion failure: ${message}`);
  }
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/***/ }),
/* 386 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = buildQuery;

var _escapeRegExp = __webpack_require__(387);

var _escapeRegExp2 = _interopRequireDefault(_escapeRegExp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Ignore doing outline matches for less than 3 whitespaces
 *
 * @memberof utils/source-search
 * @static
 */
function ignoreWhiteSpace(str) {
  return (/^\s{0,2}$/.test(str) ? "(?!\\s*.*)" : str
  );
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function wholeMatch(query, wholeWord) {
  if (query === "" || !wholeWord) {
    return query;
  }

  return `\\b${query}\\b`;
}

function buildFlags(caseSensitive, isGlobal) {
  if (caseSensitive && isGlobal) {
    return "g";
  }

  if (!caseSensitive && isGlobal) {
    return "gi";
  }

  if (!caseSensitive && !isGlobal) {
    return "i";
  }
}

function buildQuery(originalQuery, modifiers, { isGlobal = false, ignoreSpaces = false }) {
  const { caseSensitive, regexMatch, wholeWord } = modifiers;

  if (originalQuery === "") {
    return new RegExp(originalQuery);
  }

  let query = originalQuery;
  if (ignoreSpaces) {
    query = ignoreWhiteSpace(query);
  }

  if (!regexMatch) {
    query = (0, _escapeRegExp2.default)(query);
  }

  query = wholeMatch(query, wholeWord);
  const flags = buildFlags(caseSensitive, isGlobal);

  if (flags) {
    return new RegExp(query, flags);
  }

  return new RegExp(query);
}

/***/ }),
/* 387 */
/***/ (function(module, exports, __webpack_require__) {

var toString = __webpack_require__(57);

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
    reHasRegExpChar = RegExp(reRegExpChar.source);

/**
 * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
 * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escapeRegExp('[lodash](https://lodash.com/)');
 * // => '\[lodash\]\(https://lodash\.com/\)'
 */
function escapeRegExp(string) {
  string = toString(string);
  return (string && reHasRegExpChar.test(string))
    ? string.replace(reRegExpChar, '\\$&')
    : string;
}

module.exports = escapeRegExp;


/***/ }),
/* 388 */,
/* 389 */,
/* 390 */,
/* 391 */,
/* 392 */,
/* 393 */,
/* 394 */,
/* 395 */,
/* 396 */,
/* 397 */,
/* 398 */,
/* 399 */,
/* 400 */,
/* 401 */,
/* 402 */,
/* 403 */,
/* 404 */,
/* 405 */,
/* 406 */,
/* 407 */,
/* 408 */,
/* 409 */,
/* 410 */,
/* 411 */,
/* 412 */,
/* 413 */,
/* 414 */,
/* 415 */,
/* 416 */,
/* 417 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_417__;

/***/ }),
/* 418 */,
/* 419 */,
/* 420 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

const { Menu, MenuItem } = __webpack_require__(183);

function inToolbox() {
  try {
    return window.parent.document.documentURI == "about:devtools-toolbox";
  } catch (e) {
    // If `window` is not available, it's very likely that we are in the toolbox.
    return true;
  }
}

if (!inToolbox()) {
  __webpack_require__(431);
}

function createPopup(doc) {
  let popup = doc.createElement("menupopup");
  popup.className = "landing-popup";
  if (popup.openPopupAtScreen) {
    return popup;
  }

  function preventDefault(e) {
    e.preventDefault();
    e.returnValue = false;
  }

  let mask = document.querySelector("#contextmenu-mask");
  if (!mask) {
    mask = doc.createElement("div");
    mask.id = "contextmenu-mask";
    document.body.appendChild(mask);
  }

  mask.onclick = () => popup.hidePopup();

  popup.openPopupAtScreen = function (clientX, clientY) {
    this.style.setProperty("left", `${clientX}px`);
    this.style.setProperty("top", `${clientY}px`);
    mask = document.querySelector("#contextmenu-mask");
    window.onwheel = preventDefault;
    mask.classList.add("show");
    this.dispatchEvent(new Event("popupshown"));
    this.popupshown;
  };

  popup.hidePopup = function () {
    this.remove();
    mask = document.querySelector("#contextmenu-mask");
    mask.classList.remove("show");
    window.onwheel = null;
  };

  return popup;
}

if (!inToolbox()) {
  Menu.prototype.createPopup = createPopup;
}

function onShown(menu, popup) {
  popup.childNodes.forEach((menuItemNode, i) => {
    let item = menu.items[i];

    if (!item.disabled && item.visible) {
      menuItemNode.onclick = () => {
        item.click();
        popup.hidePopup();
      };

      showSubMenu(item.submenu, menuItemNode, popup);
    }
  });
}

function showMenu(evt, items) {
  if (items.length === 0) {
    return;
  }

  let menu = new Menu();
  items.filter(item => item.visible === undefined || item.visible === true).forEach(item => {
    let menuItem = new MenuItem(item);
    menuItem.submenu = createSubMenu(item.submenu);
    menu.append(menuItem);
  });

  if (inToolbox()) {
    menu.popup(evt.screenX, evt.screenY, { doc: window.parent.document });
    return;
  }

  menu.on("open", (_, popup) => onShown(menu, popup));
  menu.popup(evt.clientX, evt.clientY, { doc: document });
}

function createSubMenu(subItems) {
  if (subItems) {
    let subMenu = new Menu();
    subItems.forEach(subItem => {
      subMenu.append(new MenuItem(subItem));
    });
    return subMenu;
  }
  return null;
}

function showSubMenu(subMenu, menuItemNode, popup) {
  if (subMenu) {
    let subMenuNode = menuItemNode.querySelector("menupopup");
    let { top } = menuItemNode.getBoundingClientRect();
    let { left, width } = popup.getBoundingClientRect();
    subMenuNode.style.setProperty("left", `${left + width - 1}px`);
    subMenuNode.style.setProperty("top", `${top}px`);

    let subMenuItemNodes = menuItemNode.querySelector("menupopup:not(.landing-popup)").childNodes;
    subMenuItemNodes.forEach((subMenuItemNode, j) => {
      let subMenuItem = subMenu.items.filter(item => item.visible === undefined || item.visible === true)[j];
      if (!subMenuItem.disabled && subMenuItem.visible) {
        subMenuItemNode.onclick = () => {
          subMenuItem.click();
          popup.hidePopup();
        };
      }
    });
  }
}

function buildMenu(items) {
  return items.map(itm => {
    const hide = typeof itm.hidden === "function" ? itm.hidden() : itm.hidden;
    return hide ? null : itm.item;
  }).filter(itm => itm !== null);
}

module.exports = {
  showMenu,
  buildMenu
};

/***/ }),
/* 421 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _devtoolsServices = __webpack_require__(37);

var _devtoolsServices2 = _interopRequireDefault(_devtoolsServices);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const { appinfo } = _devtoolsServices2.default; /* This Source Code Form is subject to the terms of the Mozilla Public
                                                 * License, v. 2.0. If a copy of the MPL was not distributed with this
                                                 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

const isMacOS = appinfo.OS === "Darwin";

const EventEmitter = __webpack_require__(65);

/**
 * Formats key for use in tooltips
 * For macOS we use the following unicode
 *
 * cmd ⌘ = \u2318
 * shift ⇧ – \u21E7
 * option (alt) ⌥ \u2325
 *
 * For Win/Lin this replaces CommandOrControl or CmdOrCtrl with Ctrl
 *
 * @static
 */
function formatKeyShortcut(shortcut) {
  if (isMacOS) {
    return shortcut.replace(/Shift\+/g, "\u21E7").replace(/Command\+|Cmd\+/g, "\u2318").replace(/CommandOrControl\+|CmdOrCtrl\+/g, "\u2318").replace(/Alt\+/g, "\u2325");
  }
  return shortcut.replace(/CommandOrControl\+|CmdOrCtrl\+/g, `${L10N.getStr("ctrl")}+`).replace(/Shift\+/g, "Shift+");
}

function inToolbox() {
  try {
    return window.parent.document.documentURI == "about:devtools-toolbox";
  } catch (e) {
    // If `window` is not available, it's very likely that we are in the toolbox.
    return true;
  }
}

/**
 * A partial implementation of the Menu API provided by electron:
 * https://github.com/electron/electron/blob/master/docs/api/menu.md.
 *
 * Extra features:
 *  - Emits an 'open' and 'close' event when the menu is opened/closed

 * @param String id (non standard)
 *        Needed so tests can confirm the XUL implementation is working
 */
function Menu({ id = null } = {}) {
  this.menuitems = [];
  this.id = id;

  Object.defineProperty(this, "items", {
    get() {
      return this.menuitems;
    }
  });

  EventEmitter.decorate(this);
}

/**
 * Add an item to the end of the Menu
 *
 * @param {MenuItem} menuItem
 */
Menu.prototype.append = function (menuItem) {
  this.menuitems.push(menuItem);
};

/**
 * Add an item to a specified position in the menu
 *
 * @param {int} pos
 * @param {MenuItem} menuItem
 */
Menu.prototype.insert = function (pos, menuItem) {
  throw Error("Not implemented");
};

/**
 * Show the Menu at a specified location on the screen
 *
 * Missing features:
 *   - browserWindow - BrowserWindow (optional) - Default is null.
 *   - positioningItem Number - (optional) OS X
 *
 * @param {int} screenX
 * @param {int} screenY
 * @param Toolbox toolbox (non standard)
 *        Needed so we in which window to inject XUL
 */
Menu.prototype.popup = function (screenX, screenY, toolbox) {
  let doc = toolbox.doc;
  let popupset = doc.querySelector("popupset");
  if (!popupset) {
    popupset = doc.createXULElement("popupset");
    doc.documentElement.appendChild(popupset);
  }
  // See bug 1285229, on Windows, opening the same popup multiple times in a
  // row ends up duplicating the popup. The newly inserted popup doesn't
  // dismiss the old one. So remove any previously displayed popup before
  // opening a new one.
  let popup = popupset.querySelector("menupopup[menu-api=\"true\"]");
  if (popup) {
    popup.hidePopup();
  }

  popup = this.createPopup(doc);
  popup.setAttribute("menu-api", "true");

  if (this.id) {
    popup.id = this.id;
  }
  this._createMenuItems(popup);

  // Remove the menu from the DOM once it's hidden.
  popup.addEventListener("popuphidden", e => {
    if (e.target === popup) {
      popup.remove();
      this.emit("close", popup);
    }
  });

  popup.addEventListener("popupshown", e => {
    if (e.target === popup) {
      this.emit("open", popup);
    }
  });

  popupset.appendChild(popup);
  popup.openPopupAtScreen(screenX, screenY, true);
};

Menu.prototype.createPopup = function (doc) {
  return doc.createElement("menupopup");
};

Menu.prototype._createMenuItems = function (parent) {
  let doc = parent.ownerDocument;
  this.menuitems.forEach(item => {
    if (!item.visible) {
      return;
    }

    if (item.submenu) {
      let menupopup = doc.createElement("menupopup");
      item.submenu._createMenuItems(menupopup);

      let menuitem = doc.createElement("menuitem");
      menuitem.setAttribute("label", item.label);
      if (!inToolbox()) {
        menuitem.textContent = item.label;
      }

      let menu = doc.createElement("menu");
      menu.appendChild(menuitem);
      menu.appendChild(menupopup);
      if (item.disabled) {
        menu.setAttribute("disabled", "true");
      }
      if (item.accesskey) {
        menu.setAttribute("accesskey", item.accesskey);
      }
      if (item.id) {
        menu.id = item.id;
      }
      if (item.accelerator) {
        menuitem.setAttribute("acceltext", formatKeyShortcut(item.accelerator));
      }
      parent.appendChild(menu);
    } else if (item.type === "separator") {
      let menusep = doc.createElement("menuseparator");
      parent.appendChild(menusep);
    } else {
      let menuitem = doc.createElement("menuitem");
      menuitem.setAttribute("label", item.label);

      if (!inToolbox()) {
        menuitem.textContent = item.label;
      }

      menuitem.addEventListener("command", () => item.click());

      if (item.type === "checkbox") {
        menuitem.setAttribute("type", "checkbox");
      }
      if (item.type === "radio") {
        menuitem.setAttribute("type", "radio");
      }
      if (item.disabled) {
        menuitem.setAttribute("disabled", "true");
      }
      if (item.checked) {
        menuitem.setAttribute("checked", "true");
      }
      if (item.accesskey) {
        menuitem.setAttribute("accesskey", item.accesskey);
      }
      if (item.id) {
        menuitem.id = item.id;
      }
      if (item.accelerator) {
        menuitem.setAttribute("acceltext", formatKeyShortcut(item.accelerator));
      }
      parent.appendChild(menuitem);
    }
  });
};

Menu.setApplicationMenu = () => {
  throw Error("Not implemented");
};

Menu.sendActionToFirstResponder = () => {
  throw Error("Not implemented");
};

Menu.buildFromTemplate = () => {
  throw Error("Not implemented");
};

module.exports = Menu;

/***/ }),
/* 422 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

/*
 * A sham for https://dxr.mozilla.org/mozilla-central/source/toolkit/modules/Promise.jsm
 */

/**
 * Promise.jsm is mostly the Promise web API with a `defer` method. Just drop this in here,
 * and use the native web API (although building with webpack/babel, it may replace this
 * with it's own version if we want to target environments that do not have `Promise`.
 */

let p = typeof window != "undefined" ? window.Promise : Promise;
p.defer = function defer() {
  var resolve, reject;
  var promise = new Promise(function () {
    resolve = arguments[0];
    reject = arguments[1];
  });
  return {
    resolve: resolve,
    reject: reject,
    promise: promise
  };
};

module.exports = p;

/***/ }),
/* 423 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

/**
 * A partial implementation of the MenuItem API provided by electron:
 * https://github.com/electron/electron/blob/master/docs/api/menu-item.md.
 *
 * Missing features:
 *   - id String - Unique within a single menu. If defined then it can be used
 *                 as a reference to this item by the position attribute.
 *   - role String - Define the action of the menu item; when specified the
 *                   click property will be ignored
 *   - sublabel String
 *   - icon NativeImage
 *   - position String - This field allows fine-grained definition of the
 *                       specific location within a given menu.
 *
 * Implemented features:
 *  @param Object options
 *    Function click
 *      Will be called with click(menuItem, browserWindow) when the menu item
 *       is clicked
 *    String type
 *      Can be normal, separator, submenu, checkbox or radio
 *    String label
 *    Boolean enabled
 *      If false, the menu item will be greyed out and unclickable.
 *    Boolean checked
 *      Should only be specified for checkbox or radio type menu items.
 *    Menu submenu
 *      Should be specified for submenu type menu items. If submenu is specified,
 *      the type: 'submenu' can be omitted. If the value is not a Menu then it
 *      will be automatically converted to one using Menu.buildFromTemplate.
 *    Boolean visible
 *      If false, the menu item will be entirely hidden.
 *    String accelerator
 *      If specified, will be used as accelerator text for MenuItem
 */
function MenuItem({
  accesskey = null,
  checked = false,
  click = () => {},
  disabled = false,
  label = "",
  id = null,
  submenu = null,
  type = "normal",
  visible = true,
  accelerator = ""
} = {}) {
  this.accesskey = accesskey;
  this.checked = checked;
  this.click = click;
  this.disabled = disabled;
  this.id = id;
  this.label = label;
  this.submenu = submenu;
  this.type = type;
  this.visible = visible;
  this.accelerator = accelerator;
}

module.exports = MenuItem;

/***/ }),
/* 424 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

const Services = __webpack_require__(37);
const EventEmitter = __webpack_require__(65);

/**
 * Shortcuts for lazily accessing and setting various preferences.
 * Usage:
 *   let prefs = new Prefs("root.path.to.branch", {
 *     myIntPref: ["Int", "leaf.path.to.my-int-pref"],
 *     myCharPref: ["Char", "leaf.path.to.my-char-pref"],
 *     myJsonPref: ["Json", "leaf.path.to.my-json-pref"],
 *     myFloatPref: ["Float", "leaf.path.to.my-float-pref"]
 *     ...
 *   });
 *
 * Get/set:
 *   prefs.myCharPref = "foo";
 *   let aux = prefs.myCharPref;
 *
 * Observe:
 *   prefs.registerObserver();
 *   prefs.on("pref-changed", (prefName, prefValue) => {
 *     ...
 *   });
 *
 * @param string prefsRoot
 *        The root path to the required preferences branch.
 * @param object prefsBlueprint
 *        An object containing { accessorName: [prefType, prefName, prefDefault] } keys.
 */
function PrefsHelper(prefsRoot = "", prefsBlueprint = {}) {
  EventEmitter.decorate(this);

  let cache = new Map();

  for (let accessorName in prefsBlueprint) {
    let [prefType, prefName, prefDefault] = prefsBlueprint[accessorName];
    map(this, cache, accessorName, prefType, prefsRoot, prefName, prefDefault);
  }

  let observer = makeObserver(this, cache, prefsRoot, prefsBlueprint);
  this.registerObserver = () => observer.register();
  this.unregisterObserver = () => observer.unregister();
}

/**
 * Helper method for getting a pref value.
 *
 * @param Map cache
 * @param string prefType
 * @param string prefsRoot
 * @param string prefName
 * @return any
 */
function get(cache, prefType, prefsRoot, prefName) {
  let cachedPref = cache.get(prefName);
  if (cachedPref !== undefined) {
    return cachedPref;
  }
  let value = Services.prefs["get" + prefType + "Pref"]([prefsRoot, prefName].join("."));
  cache.set(prefName, value);
  return value;
}

/**
 * Helper method for setting a pref value.
 *
 * @param Map cache
 * @param string prefType
 * @param string prefsRoot
 * @param string prefName
 * @param any value
 */
function set(cache, prefType, prefsRoot, prefName, value) {
  Services.prefs["set" + prefType + "Pref"]([prefsRoot, prefName].join("."), value);
  cache.set(prefName, value);
}

/**
 * Maps a property name to a pref, defining lazy getters and setters.
 * Supported types are "Bool", "Char", "Int", "Float" (sugar around "Char"
 * type and casting), and "Json" (which is basically just sugar for "Char"
 * using the standard JSON serializer).
 *
 * @param PrefsHelper self
 * @param Map cache
 * @param string accessorName
 * @param string prefType
 * @param string prefsRoot
 * @param string prefName
 * @param string prefDefault
 * @param array serializer [optional]
 */
function map(self, cache, accessorName, prefType, prefsRoot, prefName, prefDefault, serializer = { in: e => e, out: e => e }) {
  if (prefName in self) {
    throw new Error(`Can't use ${prefName} because it overrides a property` + "on the instance.");
  }
  if (prefType == "Json") {
    map(self, cache, accessorName, "String", prefsRoot, prefName, prefDefault, {
      in: JSON.parse,
      out: JSON.stringify
    });
    return;
  }
  if (prefType == "Float") {
    map(self, cache, accessorName, "Char", prefsRoot, prefName, prefDefault, {
      in: Number.parseFloat,
      out: n => n + ""
    });
    return;
  }

  Object.defineProperty(self, accessorName, {
    get: () => {
      try {
        return serializer.in(get(cache, prefType, prefsRoot, prefName));
      } catch (e) {
        if (typeof prefDefault !== 'undefined') {
          return prefDefault;
        }
        throw e;
      }
    },
    set: e => set(cache, prefType, prefsRoot, prefName, serializer.out(e))
  });
}

/**
 * Finds the accessor for the provided pref, based on the blueprint object
 * used in the constructor.
 *
 * @param PrefsHelper self
 * @param object prefsBlueprint
 * @return string
 */
function accessorNameForPref(somePrefName, prefsBlueprint) {
  for (let accessorName in prefsBlueprint) {
    let [, prefName] = prefsBlueprint[accessorName];
    if (somePrefName == prefName) {
      return accessorName;
    }
  }
  return "";
}

/**
 * Creates a pref observer for `self`.
 *
 * @param PrefsHelper self
 * @param Map cache
 * @param string prefsRoot
 * @param object prefsBlueprint
 * @return object
 */
function makeObserver(self, cache, prefsRoot, prefsBlueprint) {
  return {
    register: function () {
      this._branch = Services.prefs.getBranch(prefsRoot + ".");
      this._branch.addObserver("", this);
    },
    unregister: function () {
      this._branch.removeObserver("", this);
    },
    observe: function (subject, topic, prefName) {
      // If this particular pref isn't handled by the blueprint object,
      // even though it's in the specified branch, ignore it.
      let accessorName = accessorNameForPref(prefName, prefsBlueprint);
      if (!(accessorName in self)) {
        return;
      }
      cache.delete(prefName);
      self.emit("pref-changed", accessorName, self[accessorName]);
    }
  };
}

exports.PrefsHelper = PrefsHelper;

/***/ }),
/* 425 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

const { appinfo } = __webpack_require__(37);
const EventEmitter = __webpack_require__(65);
const isOSX = appinfo.OS === "Darwin";

// List of electron keys mapped to DOM API (DOM_VK_*) key code
const ElectronKeysMapping = {
  "F1": "DOM_VK_F1",
  "F2": "DOM_VK_F2",
  "F3": "DOM_VK_F3",
  "F4": "DOM_VK_F4",
  "F5": "DOM_VK_F5",
  "F6": "DOM_VK_F6",
  "F7": "DOM_VK_F7",
  "F8": "DOM_VK_F8",
  "F9": "DOM_VK_F9",
  "F10": "DOM_VK_F10",
  "F11": "DOM_VK_F11",
  "F12": "DOM_VK_F12",
  "F13": "DOM_VK_F13",
  "F14": "DOM_VK_F14",
  "F15": "DOM_VK_F15",
  "F16": "DOM_VK_F16",
  "F17": "DOM_VK_F17",
  "F18": "DOM_VK_F18",
  "F19": "DOM_VK_F19",
  "F20": "DOM_VK_F20",
  "F21": "DOM_VK_F21",
  "F22": "DOM_VK_F22",
  "F23": "DOM_VK_F23",
  "F24": "DOM_VK_F24",
  "Space": "DOM_VK_SPACE",
  "Backspace": "DOM_VK_BACK_SPACE",
  "Delete": "DOM_VK_DELETE",
  "Insert": "DOM_VK_INSERT",
  "Return": "DOM_VK_RETURN",
  "Enter": "DOM_VK_RETURN",
  "Up": "DOM_VK_UP",
  "Down": "DOM_VK_DOWN",
  "Left": "DOM_VK_LEFT",
  "Right": "DOM_VK_RIGHT",
  "Home": "DOM_VK_HOME",
  "End": "DOM_VK_END",
  "PageUp": "DOM_VK_PAGE_UP",
  "PageDown": "DOM_VK_PAGE_DOWN",
  "Escape": "DOM_VK_ESCAPE",
  "Esc": "DOM_VK_ESCAPE",
  "Tab": "DOM_VK_TAB",
  "VolumeUp": "DOM_VK_VOLUME_UP",
  "VolumeDown": "DOM_VK_VOLUME_DOWN",
  "VolumeMute": "DOM_VK_VOLUME_MUTE",
  "PrintScreen": "DOM_VK_PRINTSCREEN"
};

/**
 * Helper to listen for keyboard events decribed in .properties file.
 *
 * let shortcuts = new KeyShortcuts({
 *   window
 * });
 * shortcuts.on("Ctrl+F", event => {
 *   // `event` is the KeyboardEvent which relates to the key shortcuts
 * });
 *
 * @param DOMWindow window
 *        The window object of the document to listen events from.
 * @param DOMElement target
 *        Optional DOM Element on which we should listen events from.
 *        If omitted, we listen for all events fired on `window`.
 */
function KeyShortcuts({ window, target }) {
  this.window = window;
  this.target = target || window;
  this.keys = new Map();
  this.eventEmitter = new EventEmitter();
  this.target.addEventListener("keydown", this);
}

/*
 * Parse an electron-like key string and return a normalized object which
 * allow efficient match on DOM key event. The normalized object matches DOM
 * API.
 *
 * @param DOMWindow window
 *        Any DOM Window object, just to fetch its `KeyboardEvent` object
 * @param String str
 *        The shortcut string to parse, following this document:
 *        https://github.com/electron/electron/blob/master/docs/api/accelerator.md
 */
KeyShortcuts.parseElectronKey = function (window, str) {
  let modifiers = str.split("+");
  let key = modifiers.pop();

  let shortcut = {
    ctrl: false,
    meta: false,
    alt: false,
    shift: false,
    // Set for character keys
    key: undefined,
    // Set for non-character keys
    keyCode: undefined
  };
  for (let mod of modifiers) {
    if (mod === "Alt") {
      shortcut.alt = true;
    } else if (["Command", "Cmd"].includes(mod)) {
      shortcut.meta = true;
    } else if (["CommandOrControl", "CmdOrCtrl"].includes(mod)) {
      if (isOSX) {
        shortcut.meta = true;
      } else {
        shortcut.ctrl = true;
      }
    } else if (["Control", "Ctrl"].includes(mod)) {
      shortcut.ctrl = true;
    } else if (mod === "Shift") {
      shortcut.shift = true;
    } else {
      console.error("Unsupported modifier:", mod, "from key:", str);
      return null;
    }
  }

  // Plus is a special case. It's a character key and shouldn't be matched
  // against a keycode as it is only accessible via Shift/Capslock
  if (key === "Plus") {
    key = "+";
  }

  if (typeof key === "string" && key.length === 1) {
    // Match any single character
    shortcut.key = key.toLowerCase();
  } else if (key in ElectronKeysMapping) {
    // Maps the others manually to DOM API DOM_VK_*
    key = ElectronKeysMapping[key];
    shortcut.keyCode = window.KeyboardEvent[key];
    // Used only to stringify the shortcut
    shortcut.keyCodeString = key;
    shortcut.key = key;
  } else {
    console.error("Unsupported key:", key);
    return null;
  }

  return shortcut;
};

KeyShortcuts.stringify = function (shortcut) {
  let list = [];
  if (shortcut.alt) {
    list.push("Alt");
  }
  if (shortcut.ctrl) {
    list.push("Ctrl");
  }
  if (shortcut.meta) {
    list.push("Cmd");
  }
  if (shortcut.shift) {
    list.push("Shift");
  }
  let key;
  if (shortcut.key) {
    key = shortcut.key.toUpperCase();
  } else {
    key = shortcut.keyCodeString;
  }
  list.push(key);
  return list.join("+");
};

KeyShortcuts.prototype = {
  destroy() {
    this.target.removeEventListener("keydown", this);
    this.keys.clear();
  },

  doesEventMatchShortcut(event, shortcut) {
    if (shortcut.meta != event.metaKey) {
      return false;
    }
    if (shortcut.ctrl != event.ctrlKey) {
      return false;
    }
    if (shortcut.alt != event.altKey) {
      return false;
    }
    // Shift is a special modifier, it may implicitely be required if the
    // expected key is a special character accessible via shift.
    if (shortcut.shift != event.shiftKey && event.key && event.key.match(/[a-zA-Z]/)) {
      return false;
    }
    if (shortcut.keyCode) {
      return event.keyCode == shortcut.keyCode;
    } else if (event.key in ElectronKeysMapping) {
      return ElectronKeysMapping[event.key] === shortcut.key;
    }

    // get the key from the keyCode if key is not provided.
    let key = event.key || String.fromCharCode(event.keyCode);

    // For character keys, we match if the final character is the expected one.
    // But for digits we also accept indirect match to please azerty keyboard,
    // which requires Shift to be pressed to get digits.
    return key.toLowerCase() == shortcut.key || shortcut.key.match(/^[0-9]$/) && event.keyCode == shortcut.key.charCodeAt(0);
  },

  handleEvent(event) {
    for (let [key, shortcut] of this.keys) {
      if (this.doesEventMatchShortcut(event, shortcut)) {
        this.eventEmitter.emit(key, event);
      }
    }
  },

  on(key, listener) {
    if (typeof listener !== "function") {
      throw new Error("KeyShortcuts.on() expects a function as " + "second argument");
    }
    if (!this.keys.has(key)) {
      let shortcut = KeyShortcuts.parseElectronKey(this.window, key);
      // The key string is wrong and we were unable to compute the key shortcut
      if (!shortcut) {
        return;
      }
      this.keys.set(key, shortcut);
    }
    this.eventEmitter.on(key, listener);
  },

  off(key, listener) {
    this.eventEmitter.off(key, listener);
  }
};
module.exports = KeyShortcuts;

/***/ }),
/* 426 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */



/**
 * Empty shim for "devtools/client/shared/zoom-keys" module
 *
 * Based on nsIMarkupDocumentViewer.fullZoom API
 * https://developer.mozilla.org/en-US/Firefox/Releases/3/Full_page_zoom
 */

exports.register = function (window) {};

/***/ }),
/* 427 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 *
 * Adapted from https://github.com/mozilla-b2g/gaia/blob/f09993563fb5fec4393eb71816ce76cb00463190/shared/js/async_storage.js
 * (converted to use Promises instead of callbacks).
 *
 * This file defines an asynchronous version of the localStorage API, backed by
 * an IndexedDB database.  It creates a global asyncStorage object that has
 * methods like the localStorage object.
 *
 * To store a value use setItem:
 *
 *   asyncStorage.setItem("key", "value");
 *
 * This returns a promise in case you want confirmation that the value has been stored.
 *
 *  asyncStorage.setItem("key", "newvalue").then(function() {
 *    console.log("new value stored");
 *  });
 *
 * To read a value, call getItem(), but note that you must wait for a promise
 * resolution for the value to be retrieved.
 *
 *  asyncStorage.getItem("key").then(function(value) {
 *    console.log("The value of key is:", value);
 *  });
 *
 * Note that unlike localStorage, asyncStorage does not allow you to store and
 * retrieve values by setting and querying properties directly. You cannot just
 * write asyncStorage.key; you have to explicitly call setItem() or getItem().
 *
 * removeItem(), clear(), length(), and key() are like the same-named methods of
 * localStorage, and all return a promise.
 *
 * The asynchronous nature of getItem() makes it tricky to retrieve multiple
 * values. But unlike localStorage, asyncStorage does not require the values you
 * store to be strings.  So if you need to save multiple values and want to
 * retrieve them together, in a single asynchronous operation, just group the
 * values into a single object. The properties of this object may not include
 * DOM elements, but they may include things like Blobs and typed arrays.
 *
 */



const DBNAME = "devtools-async-storage";
const DBVERSION = 1;
const STORENAME = "keyvaluepairs";
var db = null;

function withStore(type, onsuccess, onerror) {
  if (db) {
    const transaction = db.transaction(STORENAME, type);
    const store = transaction.objectStore(STORENAME);
    onsuccess(store);
  } else {
    const openreq = indexedDB.open(DBNAME, DBVERSION);
    openreq.onerror = function withStoreOnError() {
      onerror();
    };
    openreq.onupgradeneeded = function withStoreOnUpgradeNeeded() {
      // First time setup: create an empty object store
      openreq.result.createObjectStore(STORENAME);
    };
    openreq.onsuccess = function withStoreOnSuccess() {
      db = openreq.result;
      const transaction = db.transaction(STORENAME, type);
      const store = transaction.objectStore(STORENAME);
      onsuccess(store);
    };
  }
}

function getItem(itemKey) {
  return new Promise((resolve, reject) => {
    let req;
    withStore("readonly", store => {
      store.transaction.oncomplete = function onComplete() {
        let value = req.result;
        if (value === undefined) {
          value = null;
        }
        resolve(value);
      };
      req = store.get(itemKey);
      req.onerror = function getItemOnError() {
        reject("Error in asyncStorage.getItem(): ", req.error.name);
      };
    }, reject);
  });
}

function setItem(itemKey, value) {
  return new Promise((resolve, reject) => {
    withStore("readwrite", store => {
      store.transaction.oncomplete = resolve;
      const req = store.put(value, itemKey);
      req.onerror = function setItemOnError() {
        reject("Error in asyncStorage.setItem(): ", req.error.name);
      };
    }, reject);
  });
}

function removeItem(itemKey) {
  return new Promise((resolve, reject) => {
    withStore("readwrite", store => {
      store.transaction.oncomplete = resolve;
      const req = store.delete(itemKey);
      req.onerror = function removeItemOnError() {
        reject("Error in asyncStorage.removeItem(): ", req.error.name);
      };
    }, reject);
  });
}

function clear() {
  return new Promise((resolve, reject) => {
    withStore("readwrite", store => {
      store.transaction.oncomplete = resolve;
      const req = store.clear();
      req.onerror = function clearOnError() {
        reject("Error in asyncStorage.clear(): ", req.error.name);
      };
    }, reject);
  });
}

function length() {
  return new Promise((resolve, reject) => {
    let req;
    withStore("readonly", store => {
      store.transaction.oncomplete = function onComplete() {
        resolve(req.result);
      };
      req = store.count();
      req.onerror = function lengthOnError() {
        reject("Error in asyncStorage.length(): ", req.error.name);
      };
    }, reject);
  });
}

function key(n) {
  return new Promise((resolve, reject) => {
    if (n < 0) {
      resolve(null);
      return;
    }

    let req;
    withStore("readonly", store => {
      store.transaction.oncomplete = function onComplete() {
        const cursor = req.result;
        resolve(cursor ? cursor.key : null);
      };
      let advanced = false;
      req = store.openCursor();
      req.onsuccess = function keyOnSuccess() {
        const cursor = req.result;
        if (!cursor) {
          // this means there weren"t enough keys
          return;
        }
        if (n === 0 || advanced) {
          // Either 1) we have the first key, return it if that's what they
          // wanted, or 2) we"ve got the nth key.
          return;
        }

        // Otherwise, ask the cursor to skip ahead n records
        advanced = true;
        cursor.advance(n);
      };
      req.onerror = function keyOnError() {
        reject("Error in asyncStorage.key(): ", req.error.name);
      };
    }, reject);
  });
}

exports.getItem = getItem;
exports.setItem = setItem;
exports.removeItem = removeItem;
exports.clear = clear;
exports.length = length;
exports.key = key;

/***/ }),
/* 428 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/. */

// TODO : Localize this (was l10n.getStr("frame.unknownSource"))
const UNKNOWN_SOURCE_STRING = "(unknown)";

// Character codes used in various parsing helper functions.
const CHAR_CODE_A = "a".charCodeAt(0);
const CHAR_CODE_B = "b".charCodeAt(0);
const CHAR_CODE_C = "c".charCodeAt(0);
const CHAR_CODE_D = "d".charCodeAt(0);
const CHAR_CODE_E = "e".charCodeAt(0);
const CHAR_CODE_F = "f".charCodeAt(0);
const CHAR_CODE_H = "h".charCodeAt(0);
const CHAR_CODE_I = "i".charCodeAt(0);
const CHAR_CODE_J = "j".charCodeAt(0);
const CHAR_CODE_L = "l".charCodeAt(0);
const CHAR_CODE_M = "m".charCodeAt(0);
const CHAR_CODE_N = "n".charCodeAt(0);
const CHAR_CODE_O = "o".charCodeAt(0);
const CHAR_CODE_P = "p".charCodeAt(0);
const CHAR_CODE_R = "r".charCodeAt(0);
const CHAR_CODE_S = "s".charCodeAt(0);
const CHAR_CODE_T = "t".charCodeAt(0);
const CHAR_CODE_U = "u".charCodeAt(0);
const CHAR_CODE_W = "w".charCodeAt(0);
const CHAR_CODE_COLON = ":".charCodeAt(0);
const CHAR_CODE_DASH = "-".charCodeAt(0);
const CHAR_CODE_L_SQUARE_BRACKET = "[".charCodeAt(0);
const CHAR_CODE_SLASH = "/".charCodeAt(0);
const CHAR_CODE_CAP_S = "S".charCodeAt(0);

// The cache used in the `parseURL` function.
const gURLStore = new Map();
// The cache used in the `getSourceNames` function.
const gSourceNamesStore = new Map();

/**
* Takes a string and returns an object containing all the properties
* available on an URL instance, with additional properties (fileName),
* Leverages caching.
*
* @param {String} location
* @return {Object?} An object containing most properties available
*                   in https://developer.mozilla.org/en-US/docs/Web/API/URL
*/

function parseURL(location) {
  let url = gURLStore.get(location);

  if (url !== void 0) {
    return url;
  }

  try {
    url = new URL(location);
    // The callers were generally written to expect a URL from
    // sdk/url, which is subtly different.  So, work around some
    // important differences here.
    url = {
      href: url.href,
      protocol: url.protocol,
      host: url.host,
      hostname: url.hostname,
      port: url.port || null,
      pathname: url.pathname,
      search: url.search,
      hash: url.hash,
      username: url.username,
      password: url.password,
      origin: url.origin
    };

    // Definitions:
    // Example: https://foo.com:8888/file.js
    // `hostname`: "foo.com"
    // `host`: "foo.com:8888"
    let isChrome = isChromeScheme(location);

    url.fileName = url.pathname ? url.pathname.slice(url.pathname.lastIndexOf("/") + 1) || "/" : "/";

    if (isChrome) {
      url.hostname = null;
      url.host = null;
    }

    gURLStore.set(location, url);
    return url;
  } catch (e) {
    gURLStore.set(location, null);
    return null;
  }
}

/**
* Parse a source into a short and long name as well as a host name.
*
* @param {String} source
*        The source to parse. Can be a URI or names like "(eval)" or
*        "self-hosted".
* @return {Object}
*         An object with the following properties:
*           - {String} short: A short name for the source.
*             - "http://page.com/test.js#go?q=query" -> "test.js"
*           - {String} long: The full, long name for the source, with
              hash/query stripped.
*             - "http://page.com/test.js#go?q=query" -> "http://page.com/test.js"
*           - {String?} host: If available, the host name for the source.
*             - "http://page.com/test.js#go?q=query" -> "page.com"
*/
function getSourceNames(source) {
  let data = gSourceNamesStore.get(source);

  if (data) {
    return data;
  }

  let short, long, host;
  const sourceStr = source ? String(source) : "";

  // If `data:...` uri
  if (isDataScheme(sourceStr)) {
    let commaIndex = sourceStr.indexOf(",");
    if (commaIndex > -1) {
      // The `short` name for a data URI becomes `data:` followed by the actual
      // encoded content, omitting the MIME type, and charset.
      short = `data:${sourceStr.substring(commaIndex + 1)}`.slice(0, 100);
      let result = { short, long: sourceStr };
      gSourceNamesStore.set(source, result);
      return result;
    }
  }

  // If Scratchpad URI, like "Scratchpad/1"; no modifications,
  // and short/long are the same.
  if (isScratchpadScheme(sourceStr)) {
    let result = { short: sourceStr, long: sourceStr };
    gSourceNamesStore.set(source, result);
    return result;
  }

  const parsedUrl = parseURL(sourceStr);

  if (!parsedUrl) {
    // Malformed URI.
    long = sourceStr;
    short = sourceStr.slice(0, 100);
  } else {
    host = parsedUrl.host;

    long = parsedUrl.href;
    if (parsedUrl.hash) {
      long = long.replace(parsedUrl.hash, "");
    }
    if (parsedUrl.search) {
      long = long.replace(parsedUrl.search, "");
    }

    short = parsedUrl.fileName;
    // If `short` is just a slash, and we actually have a path,
    // strip the slash and parse again to get a more useful short name.
    // e.g. "http://foo.com/bar/" -> "bar", rather than "/"
    if (short === "/" && parsedUrl.pathname !== "/") {
      short = parseURL(long.replace(/\/$/, "")).fileName;
    }
  }

  if (!short) {
    if (!long) {
      long = UNKNOWN_SOURCE_STRING;
    }
    short = long.slice(0, 100);
  }

  let result = { short, long, host };
  gSourceNamesStore.set(source, result);
  return result;
}

// For the functions below, we assume that we will never access the location
// argument out of bounds, which is indeed the vast majority of cases.
//
// They are written this way because they are hot. Each frame is checked for
// being content or chrome when processing the profile.

function isColonSlashSlash(location, i = 0) {
  return location.charCodeAt(++i) === CHAR_CODE_COLON && location.charCodeAt(++i) === CHAR_CODE_SLASH && location.charCodeAt(++i) === CHAR_CODE_SLASH;
}

/**
* Checks for a Scratchpad URI, like "Scratchpad/1"
*/
function isScratchpadScheme(location, i = 0) {
  return location.charCodeAt(i) === CHAR_CODE_CAP_S && location.charCodeAt(++i) === CHAR_CODE_C && location.charCodeAt(++i) === CHAR_CODE_R && location.charCodeAt(++i) === CHAR_CODE_A && location.charCodeAt(++i) === CHAR_CODE_T && location.charCodeAt(++i) === CHAR_CODE_C && location.charCodeAt(++i) === CHAR_CODE_H && location.charCodeAt(++i) === CHAR_CODE_P && location.charCodeAt(++i) === CHAR_CODE_A && location.charCodeAt(++i) === CHAR_CODE_D && location.charCodeAt(++i) === CHAR_CODE_SLASH;
}

function isDataScheme(location, i = 0) {
  return location.charCodeAt(i) === CHAR_CODE_D && location.charCodeAt(++i) === CHAR_CODE_A && location.charCodeAt(++i) === CHAR_CODE_T && location.charCodeAt(++i) === CHAR_CODE_A && location.charCodeAt(++i) === CHAR_CODE_COLON;
}

function isContentScheme(location, i = 0) {
  let firstChar = location.charCodeAt(i);

  switch (firstChar) {
    // "http://" or "https://"
    case CHAR_CODE_H:
      if (location.charCodeAt(++i) === CHAR_CODE_T && location.charCodeAt(++i) === CHAR_CODE_T && location.charCodeAt(++i) === CHAR_CODE_P) {
        if (location.charCodeAt(i + 1) === CHAR_CODE_S) {
          ++i;
        }
        return isColonSlashSlash(location, i);
      }
      return false;

    // "file://"
    case CHAR_CODE_F:
      if (location.charCodeAt(++i) === CHAR_CODE_I && location.charCodeAt(++i) === CHAR_CODE_L && location.charCodeAt(++i) === CHAR_CODE_E) {
        return isColonSlashSlash(location, i);
      }
      return false;

    // "app://"
    case CHAR_CODE_A:
      if (location.charCodeAt(++i) == CHAR_CODE_P && location.charCodeAt(++i) == CHAR_CODE_P) {
        return isColonSlashSlash(location, i);
      }
      return false;

    // "blob:"
    case CHAR_CODE_B:
      if (location.charCodeAt(++i) == CHAR_CODE_L && location.charCodeAt(++i) == CHAR_CODE_O && location.charCodeAt(++i) == CHAR_CODE_B && location.charCodeAt(++i) == CHAR_CODE_COLON) {
        return isContentScheme(location, i + 1);
      }
      return false;

    default:
      return false;
  }
}

function isChromeScheme(location, i = 0) {
  let firstChar = location.charCodeAt(i);

  switch (firstChar) {
    // "chrome://"
    case CHAR_CODE_C:
      if (location.charCodeAt(++i) === CHAR_CODE_H && location.charCodeAt(++i) === CHAR_CODE_R && location.charCodeAt(++i) === CHAR_CODE_O && location.charCodeAt(++i) === CHAR_CODE_M && location.charCodeAt(++i) === CHAR_CODE_E) {
        return isColonSlashSlash(location, i);
      }
      return false;

    // "resource://"
    case CHAR_CODE_R:
      if (location.charCodeAt(++i) === CHAR_CODE_E && location.charCodeAt(++i) === CHAR_CODE_S && location.charCodeAt(++i) === CHAR_CODE_O && location.charCodeAt(++i) === CHAR_CODE_U && location.charCodeAt(++i) === CHAR_CODE_R && location.charCodeAt(++i) === CHAR_CODE_C && location.charCodeAt(++i) === CHAR_CODE_E) {
        return isColonSlashSlash(location, i);
      }
      return false;

    // "jar:file://"
    case CHAR_CODE_J:
      if (location.charCodeAt(++i) === CHAR_CODE_A && location.charCodeAt(++i) === CHAR_CODE_R && location.charCodeAt(++i) === CHAR_CODE_COLON && location.charCodeAt(++i) === CHAR_CODE_F && location.charCodeAt(++i) === CHAR_CODE_I && location.charCodeAt(++i) === CHAR_CODE_L && location.charCodeAt(++i) === CHAR_CODE_E) {
        return isColonSlashSlash(location, i);
      }
      return false;

    default:
      return false;
  }
}

function isWASM(location, i = 0) {
  return (
    // "wasm-function["
    location.charCodeAt(i) === CHAR_CODE_W && location.charCodeAt(++i) === CHAR_CODE_A && location.charCodeAt(++i) === CHAR_CODE_S && location.charCodeAt(++i) === CHAR_CODE_M && location.charCodeAt(++i) === CHAR_CODE_DASH && location.charCodeAt(++i) === CHAR_CODE_F && location.charCodeAt(++i) === CHAR_CODE_U && location.charCodeAt(++i) === CHAR_CODE_N && location.charCodeAt(++i) === CHAR_CODE_C && location.charCodeAt(++i) === CHAR_CODE_T && location.charCodeAt(++i) === CHAR_CODE_I && location.charCodeAt(++i) === CHAR_CODE_O && location.charCodeAt(++i) === CHAR_CODE_N && location.charCodeAt(++i) === CHAR_CODE_L_SQUARE_BRACKET
  );
}

/**
* A utility method to get the file name from a sourcemapped location
* The sourcemap location can be in any form. This method returns a
* formatted file name for different cases like Windows or OSX.
* @param source
* @returns String
*/
function getSourceMappedFile(source) {
  // If sourcemapped source is a OSX path, return
  // the characters after last "/".
  // If sourcemapped source is a Windowss path, return
  // the characters after last "\\".
  if (source.lastIndexOf("/") >= 0) {
    source = source.slice(source.lastIndexOf("/") + 1);
  } else if (source.lastIndexOf("\\") >= 0) {
    source = source.slice(source.lastIndexOf("\\") + 1);
  }
  return source;
}

module.exports = {
  parseURL,
  getSourceNames,
  isScratchpadScheme,
  isChromeScheme,
  isContentScheme,
  isWASM,
  isDataScheme,
  getSourceMappedFile
};

/***/ }),
/* 429 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/**
 * This is a stub of the DevTools telemetry module and will be replaced by the
 * full version of the file by Webpack for running inside Firefox.
 */

class Telemetry {
  /**
   * Time since the system wide epoch. This is not a monotonic timer but
   * can be used across process boundaries.
   */
  get msSystemNow() {
    return 0;
  }

  /**
   * Starts a timer associated with a telemetry histogram. The timer can be
   * directly associated with a histogram, or with a pair of a histogram and
   * an object.
   *
   * @param {String} histogramId
   *        A string which must be a valid histogram name.
   * @param {Object} obj
   *        Optional parameter. If specified, the timer is associated with this
   *        object, meaning that multiple timers for the same histogram may be
   *        run concurrently, as long as they are associated with different
   *        objects.
   *
   * @returns {Boolean}
   *          True if the timer was successfully started, false otherwise. If a
   *          timer already exists, it can't be started again, and the existing
   *          one will be cleared in order to avoid measurements errors.
   */
  start(histogramId, obj) {
    return true;
  }

  /**
   * Starts a timer associated with a keyed telemetry histogram. The timer can
   * be directly associated with a histogram and its key. Similarly to
   * TelemetryStopwatch.start the histogram and its key can be associated
   * with an object. Each key may have multiple associated objects and each
   * object can be associated with multiple keys.
   *
   * @param {String} histogramId
   *        A string which must be a valid histogram name.
   * @param {String} key
   *        A string which must be a valid histgram key.
   * @param {Object} obj
   *        Optional parameter. If specified, the timer is associated with this
   *        object, meaning that multiple timers for the same histogram may be
   *        run concurrently,as long as they are associated with different
   *        objects.
   *
   * @returns {Boolean}
   *          True if the timer was successfully started, false otherwise. If a
   *          timer already exists, it can't be started again, and the existing
   *          one will be cleared in order to avoid measurements errors.
   */
  startKeyed(histogramId, key, obj) {
    return true;
  }

  /**
   * Stops the timer associated with the given histogram (and object),
   * calculates the time delta between start and finish, and adds the value
   * to the histogram.
   *
   * @param {String} histogramId
   *        A string which must be a valid histogram name.
   * @param {Object} obj
   *        Optional parameter which associates the histogram timer with the
   *        given object.
   * @param {Boolean} canceledOkay
   *        Optional parameter which will suppress any warnings that normally
   *        fire when a stopwatch is finished after being cancelled.
   *        Defaults to false.
   *
   * @returns {Boolean}
   *          True if the timer was succesfully stopped and the data was added
   *          to the histogram, False otherwise.
   */
  finish(histogramId, obj, canceledOkay) {
    return true;
  }

  /**
   * Stops the timer associated with the given keyed histogram (and object),
   * calculates the time delta between start and finish, and adds the value
   * to the keyed histogram.
   *
   * @param {String} histogramId
   *        A string which must be a valid histogram name.
   * @param {String} key
   *        A string which must be a valid histogram key.
   * @param {Object} obj
   *        Optional parameter which associates the histogram timer with the
   *        given object.
   * @param {Boolean} canceledOkay
   *        Optional parameter which will suppress any warnings that normally
   *        fire when a stopwatch is finished after being cancelled.
   *        Defaults to false.
   *
   * @returns {Boolean}
   *          True if the timer was succesfully stopped and the data was added
   *          to the histogram, False otherwise.
   */
  finishKeyed(histogramId, key, obj, cancelledOkay) {
    return true;
  }

  /**
   * Log a value to a histogram.
   *
   * @param  {String} histogramId
   *         Histogram in which the data is to be stored.
   */
  getHistogramById(histogramId) {
    return {
      add: () => {}
    };
  }

  /**
   * Get a keyed histogram.
   *
   * @param  {String} histogramId
   *         Histogram in which the data is to be stored.
   */
  getKeyedHistogramById(histogramId) {
    return {
      add: () => {}
    };
  }

  /**
   * Log a value to a scalar.
   *
   * @param  {String} scalarId
   *         Scalar in which the data is to be stored.
   * @param  value
   *         Value to store.
   */
  scalarSet(scalarId, value) {}

  /**
   * Log a value to a count scalar.
   *
   * @param  {String} scalarId
   *         Scalar in which the data is to be stored.
   * @param  value
   *         Value to store.
   */
  scalarAdd(scalarId, value) {}

  /**
   * Log a value to a keyed count scalar.
   *
   * @param  {String} scalarId
   *         Scalar in which the data is to be stored.
   * @param  {String} key
   *         The key within the  scalar.
   * @param  value
   *         Value to store.
   */
  keyedScalarAdd(scalarId, key, value) {}

  /**
   * Event telemetry is disabled by default. Use this method to enable it for
   * a particular category.
   *
   * @param {Boolean} enabled
   *        Enabled: true or false.
   */
  setEventRecordingEnabled(enabled) {
    return enabled;
  }

  /**
   * Telemetry events often need to make use of a number of properties from
   * completely different codepaths. To make this possible we create a
   * "pending event" along with an array of property names that we need to wait
   * for before sending the event.
   *
   * As each property is received via addEventProperty() we check if all
   * properties have been received. Once they have all been received we send the
   * telemetry event.
   *
   * @param {Object} obj
   *        The telemetry event or ping is associated with this object, meaning
   *        that multiple events or pings for the same histogram may be run
   *        concurrently, as long as they are associated with different objects.
   * @param {String} method
   *        The telemetry event method (describes the type of event that
   *        occurred e.g. "open")
   * @param {String} object
   *        The telemetry event object name (the name of the object the event
   *        occurred on) e.g. "tools" or "setting"
   * @param {String|null} value
   *        The telemetry event value (a user defined value, providing context
   *        for the event) e.g. "console"
   * @param {Array} expected
   *        An array of the properties needed before sending the telemetry
   *        event e.g.
   *        [
   *          "host",
   *          "width"
   *        ]
   */
  preparePendingEvent(obj, method, object, value, expected = []) {}

  /**
   * Adds an expected property for either a current or future pending event.
   * This means that if preparePendingEvent() is called before or after sending
   * the event properties they will automatically added to the event.
   *
   * @param {Object} obj
   *        The telemetry event or ping is associated with this object, meaning
   *        that multiple events or pings for the same histogram may be run
   *        concurrently, as long as they are associated with different objects.
   * @param {String} method
   *        The telemetry event method (describes the type of event that
   *        occurred e.g. "open")
   * @param {String} object
   *        The telemetry event object name (the name of the object the event
   *        occurred on) e.g. "tools" or "setting"
   * @param {String|null} value
   *        The telemetry event value (a user defined value, providing context
   *        for the event) e.g. "console"
   * @param {String} pendingPropName
   *        The pending property name
   * @param {String} pendingPropValue
   *        The pending property value
   */
  addEventProperty(obj, method, object, value, pendingPropName, pendingPropValue) {}

  /**
   * Adds expected properties for either a current or future pending event.
   * This means that if preparePendingEvent() is called before or after sending
   * the event properties they will automatically added to the event.
   *
   * @param {Object} obj
   *        The telemetry event or ping is associated with this object, meaning
   *        that multiple events or pings for the same histogram may be run
   *        concurrently, as long as they are associated with different objects.
   * @param {String} method
   *        The telemetry event method (describes the type of event that
   *        occurred e.g. "open")
   * @param {String} object
   *        The telemetry event object name (the name of the object the event
   *        occurred on) e.g. "tools" or "setting"
   * @param {String|null} value
   *        The telemetry event value (a user defined value, providing context
   *        for the event) e.g. "console"
   * @param {String} pendingObject
   *        An object containing key, value pairs that should be added to the
   *        event as properties.
   */
  addEventProperties(obj, method, object, value, pendingObject) {}

  /**
   * A private method that is not to be used externally. This method is used to
   * prepare a pending telemetry event for sending and then send it via
   * recordEvent().
   *
   * @param {Object} obj
   *        The telemetry event or ping is associated with this object, meaning
   *        that multiple events or pings for the same histogram may be run
   *        concurrently, as long as they are associated with different objects.
   * @param {String} method
   *        The telemetry event method (describes the type of event that
   *        occurred e.g. "open")
   * @param {String} object
   *        The telemetry event object name (the name of the object the event
   *        occurred on) e.g. "tools" or "setting"
   * @param {String|null} value
   *        The telemetry event value (a user defined value, providing context
   *        for the event) e.g. "console"
   */
  _sendPendingEvent(obj, method, object, value) {}

  /**
   * Send a telemetry event.
   *
   * @param {String} method
   *        The telemetry event method (describes the type of event that
   *        occurred e.g. "open")
   * @param {String} object
   *        The telemetry event object name (the name of the object the event
   *        occurred on) e.g. "tools" or "setting"
   * @param {String|null} value
   *        The telemetry event value (a user defined value, providing context
   *        for the event) e.g. "console"
   * @param {Object} extra
   *        The telemetry event extra object containing the properties that will
   *        be sent with the event e.g.
   *        {
   *          host: "bottom",
   *          width: "1024"
   *        }
   */
  recordEvent(method, object, value, extra) {}

  /**
   * Sends telemetry pings to indicate that a tool has been opened.
   *
   * @param {String} id
   *        The ID of the tool opened.
   * @param {String} sessionId
   *        Toolbox session id used when we need to ensure a tool really has a
   *        timer before calculating a delta.
   * @param {Object} obj
   *        The telemetry event or ping is associated with this object, meaning
   *        that multiple events or pings for the same histogram may be run
   *        concurrently, as long as they are associated with different objects.
   */
  toolOpened(id, sessionId, obj) {}

  /**
   * Sends telemetry pings to indicate that a tool has been closed.
   *
   * @param {String} id
   *        The ID of the tool opened.
   */
  toolClosed(id, sessionId, obj) {}
}

module.exports = Telemetry;

/***/ }),
/* 430 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

// This file is a chrome-API-free version of the module
// devtools/client/shared/unicode-url.js in the mozilla-central repository, so
// that it can be used in Chrome-API-free applications, such as the Launchpad.
// But because of this, it cannot take advantage of utilizing chrome APIs and
// should implement the similar functionalities on its own.
//
// Please keep in mind that if the feature in this file has changed, don't
// forget to also change that accordingly in
// devtools/client/shared/unicode-url.js in the mozilla-central repository.



const punycode = __webpack_require__(62);

/**
 * Gets a readble Unicode hostname from a hostname.
 *
 * If the `hostname` is a readable ASCII hostname, such as example.org, then
 * this function will simply return the original `hostname`.
 *
 * If the `hostname` is a Punycode hostname representing a Unicode domain name,
 * such as xn--g6w.xn--8pv, then this function will return the readable Unicode
 * domain name by decoding the Punycode hostname.
 *
 * @param {string}  hostname
 *                  the hostname from which the Unicode hostname will be
 *                  parsed, such as example.org, xn--g6w.xn--8pv.
 * @return {string} The Unicode hostname. It may be the same as the `hostname`
 *                  passed to this function if the `hostname` itself is
 *                  a readable ASCII hostname or a Unicode hostname.
 */
function getUnicodeHostname(hostname) {
  try {
    return punycode.toUnicode(hostname);
  } catch (err) {}
  return hostname;
}

/**
 * Gets a readble Unicode URL pathname from a URL pathname.
 *
 * If the `urlPath` is a readable ASCII URL pathname, such as /a/b/c.js, then
 * this function will simply return the original `urlPath`.
 *
 * If the `urlPath` is a URI-encoded pathname, such as %E8%A9%A6/%E6%B8%AC.js,
 * then this function will return the readable Unicode pathname.
 *
 * If the `urlPath` is a malformed URL pathname, then this function will simply
 * return the original `urlPath`.
 *
 * @param {string}  urlPath
 *                  the URL path from which the Unicode URL path will be parsed,
 *                  such as /a/b/c.js, %E8%A9%A6/%E6%B8%AC.js.
 * @return {string} The Unicode URL Path. It may be the same as the `urlPath`
 *                  passed to this function if the `urlPath` itself is a readable
 *                  ASCII url or a Unicode url.
 */
function getUnicodeUrlPath(urlPath) {
  try {
    return decodeURIComponent(urlPath);
  } catch (err) {}
  return urlPath;
}

/**
 * Gets a readable Unicode URL from a URL.
 *
 * If the `url` is a readable ASCII URL, such as http://example.org/a/b/c.js,
 * then this function will simply return the original `url`.
 *
 * If the `url` includes either an unreadable Punycode domain name or an
 * unreadable URI-encoded pathname, such as
 * http://xn--g6w.xn--8pv/%E8%A9%A6/%E6%B8%AC.js, then this function will return
 * the readable URL by decoding all its unreadable URL components to Unicode
 * characters.
 *
 * If the `url` is a malformed URL, then this function will return the original
 * `url`.
 *
 * If the `url` is a data: URI, then this function will return the original
 * `url`.
 *
 * @param {string}  url
 *                  the full URL, or a data: URI. from which the readable URL
 *                  will be parsed, such as, http://example.org/a/b/c.js,
 *                  http://xn--g6w.xn--8pv/%E8%A9%A6/%E6%B8%AC.js
 * @return {string} The readable URL. It may be the same as the `url` passed to
 *                  this function if the `url` itself is readable.
 */
function getUnicodeUrl(url) {
  try {
    const { protocol, hostname } = new URL(url);
    if (protocol === "data:") {
      // Never convert a data: URI.
      return url;
    }
    const readableHostname = getUnicodeHostname(hostname);
    url = decodeURIComponent(url);
    return url.replace(hostname, readableHostname);
  } catch (err) {}
  return url;
}

module.exports = {
  getUnicodeHostname,
  getUnicodeUrlPath,
  getUnicodeUrl
};

/***/ }),
/* 431 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 432 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {(function() {
  var Query, defaultPathSeparator, filter, matcher, parseOptions, pathScorer, preparedQueryCache, scorer;

  filter = __webpack_require__(433);

  matcher = __webpack_require__(434);

  scorer = __webpack_require__(66);

  pathScorer = __webpack_require__(111);

  Query = __webpack_require__(184);

  preparedQueryCache = null;

  defaultPathSeparator = (typeof process !== "undefined" && process !== null ? process.platform : void 0) === "win32" ? '\\' : '/';

  module.exports = {
    filter: function(candidates, query, options) {
      if (options == null) {
        options = {};
      }
      if (!((query != null ? query.length : void 0) && (candidates != null ? candidates.length : void 0))) {
        return [];
      }
      options = parseOptions(options, query);
      return filter(candidates, query, options);
    },
    score: function(string, query, options) {
      if (options == null) {
        options = {};
      }
      if (!((string != null ? string.length : void 0) && (query != null ? query.length : void 0))) {
        return 0;
      }
      options = parseOptions(options, query);
      if (options.usePathScoring) {
        return pathScorer.score(string, query, options);
      } else {
        return scorer.score(string, query, options);
      }
    },
    match: function(string, query, options) {
      var _i, _ref, _results;
      if (options == null) {
        options = {};
      }
      if (!string) {
        return [];
      }
      if (!query) {
        return [];
      }
      if (string === query) {
        return (function() {
          _results = [];
          for (var _i = 0, _ref = string.length; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
          return _results;
        }).apply(this);
      }
      options = parseOptions(options, query);
      return matcher.match(string, query, options);
    },
    wrap: function(string, query, options) {
      if (options == null) {
        options = {};
      }
      if (!string) {
        return [];
      }
      if (!query) {
        return [];
      }
      options = parseOptions(options, query);
      return matcher.wrap(string, query, options);
    },
    prepareQuery: function(query, options) {
      if (options == null) {
        options = {};
      }
      options = parseOptions(options, query);
      return options.preparedQuery;
    }
  };

  parseOptions = function(options, query) {
    if (options.allowErrors == null) {
      options.allowErrors = false;
    }
    if (options.usePathScoring == null) {
      options.usePathScoring = true;
    }
    if (options.useExtensionBonus == null) {
      options.useExtensionBonus = false;
    }
    if (options.pathSeparator == null) {
      options.pathSeparator = defaultPathSeparator;
    }
    if (options.optCharRegEx == null) {
      options.optCharRegEx = null;
    }
    if (options.wrap == null) {
      options.wrap = null;
    }
    if (options.preparedQuery == null) {
      options.preparedQuery = preparedQueryCache && preparedQueryCache.query === query ? preparedQueryCache : (preparedQueryCache = new Query(query, options));
    }
    return options;
  };

}).call(this);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(35)))

/***/ }),
/* 433 */
/***/ (function(module, exports, __webpack_require__) {

(function() {
  var Query, pathScorer, pluckCandidates, scorer, sortCandidates;

  scorer = __webpack_require__(66);

  pathScorer = __webpack_require__(111);

  Query = __webpack_require__(184);

  pluckCandidates = function(a) {
    return a.candidate;
  };

  sortCandidates = function(a, b) {
    return b.score - a.score;
  };

  module.exports = function(candidates, query, options) {
    var bKey, candidate, key, maxInners, maxResults, score, scoreProvider, scoredCandidates, spotLeft, string, usePathScoring, _i, _len;
    scoredCandidates = [];
    key = options.key, maxResults = options.maxResults, maxInners = options.maxInners, usePathScoring = options.usePathScoring;
    spotLeft = (maxInners != null) && maxInners > 0 ? maxInners : candidates.length + 1;
    bKey = key != null;
    scoreProvider = usePathScoring ? pathScorer : scorer;
    for (_i = 0, _len = candidates.length; _i < _len; _i++) {
      candidate = candidates[_i];
      string = bKey ? candidate[key] : candidate;
      if (!string) {
        continue;
      }
      score = scoreProvider.score(string, query, options);
      if (score > 0) {
        scoredCandidates.push({
          candidate: candidate,
          score: score
        });
        if (!--spotLeft) {
          break;
        }
      }
    }
    scoredCandidates.sort(sortCandidates);
    candidates = scoredCandidates.map(pluckCandidates);
    if (maxResults != null) {
      candidates = candidates.slice(0, maxResults);
    }
    return candidates;
  };

}).call(this);


/***/ }),
/* 434 */
/***/ (function(module, exports, __webpack_require__) {

(function() {
  var basenameMatch, computeMatch, isMatch, isWordStart, match, mergeMatches, scoreAcronyms, scoreCharacter, scoreConsecutives, _ref;

  _ref = __webpack_require__(66), isMatch = _ref.isMatch, isWordStart = _ref.isWordStart, scoreConsecutives = _ref.scoreConsecutives, scoreCharacter = _ref.scoreCharacter, scoreAcronyms = _ref.scoreAcronyms;

  exports.match = match = function(string, query, options) {
    var allowErrors, baseMatches, matches, pathSeparator, preparedQuery, string_lw;
    allowErrors = options.allowErrors, preparedQuery = options.preparedQuery, pathSeparator = options.pathSeparator;
    if (!(allowErrors || isMatch(string, preparedQuery.core_lw, preparedQuery.core_up))) {
      return [];
    }
    string_lw = string.toLowerCase();
    matches = computeMatch(string, string_lw, preparedQuery);
    if (matches.length === 0) {
      return matches;
    }
    if (string.indexOf(pathSeparator) > -1) {
      baseMatches = basenameMatch(string, string_lw, preparedQuery, pathSeparator);
      matches = mergeMatches(matches, baseMatches);
    }
    return matches;
  };

  exports.wrap = function(string, query, options) {
    var matchIndex, matchPos, matchPositions, output, strPos, tagClass, tagClose, tagOpen, _ref1;
    if ((options.wrap != null)) {
      _ref1 = options.wrap, tagClass = _ref1.tagClass, tagOpen = _ref1.tagOpen, tagClose = _ref1.tagClose;
    }
    if (tagClass == null) {
      tagClass = 'highlight';
    }
    if (tagOpen == null) {
      tagOpen = '<strong class="' + tagClass + '">';
    }
    if (tagClose == null) {
      tagClose = '</strong>';
    }
    if (string === query) {
      return tagOpen + string + tagClose;
    }
    matchPositions = match(string, query, options);
    if (matchPositions.length === 0) {
      return string;
    }
    output = '';
    matchIndex = -1;
    strPos = 0;
    while (++matchIndex < matchPositions.length) {
      matchPos = matchPositions[matchIndex];
      if (matchPos > strPos) {
        output += string.substring(strPos, matchPos);
        strPos = matchPos;
      }
      while (++matchIndex < matchPositions.length) {
        if (matchPositions[matchIndex] === matchPos + 1) {
          matchPos++;
        } else {
          matchIndex--;
          break;
        }
      }
      matchPos++;
      if (matchPos > strPos) {
        output += tagOpen;
        output += string.substring(strPos, matchPos);
        output += tagClose;
        strPos = matchPos;
      }
    }
    if (strPos <= string.length - 1) {
      output += string.substring(strPos);
    }
    return output;
  };

  basenameMatch = function(subject, subject_lw, preparedQuery, pathSeparator) {
    var basePos, depth, end;
    end = subject.length - 1;
    while (subject[end] === pathSeparator) {
      end--;
    }
    basePos = subject.lastIndexOf(pathSeparator, end);
    if (basePos === -1) {
      return [];
    }
    depth = preparedQuery.depth;
    while (depth-- > 0) {
      basePos = subject.lastIndexOf(pathSeparator, basePos - 1);
      if (basePos === -1) {
        return [];
      }
    }
    basePos++;
    end++;
    return computeMatch(subject.slice(basePos, end), subject_lw.slice(basePos, end), preparedQuery, basePos);
  };

  mergeMatches = function(a, b) {
    var ai, bj, i, j, m, n, out;
    m = a.length;
    n = b.length;
    if (n === 0) {
      return a.slice();
    }
    if (m === 0) {
      return b.slice();
    }
    i = -1;
    j = 0;
    bj = b[j];
    out = [];
    while (++i < m) {
      ai = a[i];
      while (bj <= ai && ++j < n) {
        if (bj < ai) {
          out.push(bj);
        }
        bj = b[j];
      }
      out.push(ai);
    }
    while (j < n) {
      out.push(b[j++]);
    }
    return out;
  };

  computeMatch = function(subject, subject_lw, preparedQuery, offset) {
    var DIAGONAL, LEFT, STOP, UP, acro_score, align, backtrack, csc_diag, csc_row, csc_score, i, j, m, matches, move, n, pos, query, query_lw, score, score_diag, score_row, score_up, si_lw, start, trace;
    if (offset == null) {
      offset = 0;
    }
    query = preparedQuery.query;
    query_lw = preparedQuery.query_lw;
    m = subject.length;
    n = query.length;
    acro_score = scoreAcronyms(subject, subject_lw, query, query_lw).score;
    score_row = new Array(n);
    csc_row = new Array(n);
    STOP = 0;
    UP = 1;
    LEFT = 2;
    DIAGONAL = 3;
    trace = new Array(m * n);
    pos = -1;
    j = -1;
    while (++j < n) {
      score_row[j] = 0;
      csc_row[j] = 0;
    }
    i = -1;
    while (++i < m) {
      score = 0;
      score_up = 0;
      csc_diag = 0;
      si_lw = subject_lw[i];
      j = -1;
      while (++j < n) {
        csc_score = 0;
        align = 0;
        score_diag = score_up;
        if (query_lw[j] === si_lw) {
          start = isWordStart(i, subject, subject_lw);
          csc_score = csc_diag > 0 ? csc_diag : scoreConsecutives(subject, subject_lw, query, query_lw, i, j, start);
          align = score_diag + scoreCharacter(i, j, start, acro_score, csc_score);
        }
        score_up = score_row[j];
        csc_diag = csc_row[j];
        if (score > score_up) {
          move = LEFT;
        } else {
          score = score_up;
          move = UP;
        }
        if (align > score) {
          score = align;
          move = DIAGONAL;
        } else {
          csc_score = 0;
        }
        score_row[j] = score;
        csc_row[j] = csc_score;
        trace[++pos] = score > 0 ? move : STOP;
      }
    }
    i = m - 1;
    j = n - 1;
    pos = i * n + j;
    backtrack = true;
    matches = [];
    while (backtrack && i >= 0 && j >= 0) {
      switch (trace[pos]) {
        case UP:
          i--;
          pos -= n;
          break;
        case LEFT:
          j--;
          pos--;
          break;
        case DIAGONAL:
          matches.push(i + offset);
          j--;
          i--;
          pos -= n + 1;
          break;
        default:
          backtrack = false;
      }
    }
    matches.reverse();
    return matches;
  };

}).call(this);


/***/ }),
/* 435 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.EXITING = exports.ENTERED = exports.ENTERING = exports.EXITED = exports.UNMOUNTED = undefined;

var _propTypes = __webpack_require__(0);

var PropTypes = _interopRequireWildcard(_propTypes);

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(112);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _reactLifecyclesCompat = __webpack_require__(436);

var _PropTypes = __webpack_require__(437);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UNMOUNTED = exports.UNMOUNTED = 'unmounted';
var EXITED = exports.EXITED = 'exited';
var ENTERING = exports.ENTERING = 'entering';
var ENTERED = exports.ENTERED = 'entered';
var EXITING = exports.EXITING = 'exiting';

/**
 * The Transition component lets you describe a transition from one component
 * state to another _over time_ with a simple declarative API. Most commonly
 * it's used to animate the mounting and unmounting of a component, but can also
 * be used to describe in-place transition states as well.
 *
 * By default the `Transition` component does not alter the behavior of the
 * component it renders, it only tracks "enter" and "exit" states for the components.
 * It's up to you to give meaning and effect to those states. For example we can
 * add styles to a component when it enters or exits:
 *
 * ```jsx
 * import Transition from 'react-transition-group/Transition';
 *
 * const duration = 300;
 *
 * const defaultStyle = {
 *   transition: `opacity ${duration}ms ease-in-out`,
 *   opacity: 0,
 * }
 *
 * const transitionStyles = {
 *   entering: { opacity: 0 },
 *   entered:  { opacity: 1 },
 * };
 *
 * const Fade = ({ in: inProp }) => (
 *   <Transition in={inProp} timeout={duration}>
 *     {(state) => (
 *       <div style={{
 *         ...defaultStyle,
 *         ...transitionStyles[state]
 *       }}>
 *         I'm a fade Transition!
 *       </div>
 *     )}
 *   </Transition>
 * );
 * ```
 *
 * As noted the `Transition` component doesn't _do_ anything by itself to its child component.
 * What it does do is track transition states over time so you can update the
 * component (such as by adding styles or classes) when it changes states.
 *
 * There are 4 main states a Transition can be in:
 *  - `'entering'`
 *  - `'entered'`
 *  - `'exiting'`
 *  - `'exited'`
 *
 * Transition state is toggled via the `in` prop. When `true` the component begins the
 * "Enter" stage. During this stage, the component will shift from its current transition state,
 * to `'entering'` for the duration of the transition and then to the `'entered'` stage once
 * it's complete. Let's take the following example:
 *
 * ```jsx
 * state = { in: false };
 *
 * toggleEnterState = () => {
 *   this.setState({ in: true });
 * }
 *
 * render() {
 *   return (
 *     <div>
 *       <Transition in={this.state.in} timeout={500} />
 *       <button onClick={this.toggleEnterState}>Click to Enter</button>
 *     </div>
 *   );
 * }
 * ```
 *
 * When the button is clicked the component will shift to the `'entering'` state and
 * stay there for 500ms (the value of `timeout`) before it finally switches to `'entered'`.
 *
 * When `in` is `false` the same thing happens except the state moves from `'exiting'` to `'exited'`.
 *
 * ## Timing
 *
 * Timing is often the trickiest part of animation, mistakes can result in slight delays
 * that are hard to pin down. A common example is when you want to add an exit transition,
 * you should set the desired final styles when the state is `'exiting'`. That's when the
 * transition to those styles will start and, if you matched the `timeout` prop with the
 * CSS Transition duration, it will end exactly when the state changes to `'exited'`.
 *
 * > **Note**: For simpler transitions the `Transition` component might be enough, but
 * > take into account that it's platform-agnostic, while the `CSSTransition` component
 * > [forces reflows](https://github.com/reactjs/react-transition-group/blob/5007303e729a74be66a21c3e2205e4916821524b/src/CSSTransition.js#L208-L215)
 * > in order to make more complex transitions more predictable. For example, even though
 * > classes `example-enter` and `example-enter-active` are applied immediately one after
 * > another, you can still transition from one to the other because of the forced reflow
 * > (read [this issue](https://github.com/reactjs/react-transition-group/issues/159#issuecomment-322761171)
 * > for more info). Take this into account when choosing between `Transition` and
 * > `CSSTransition`.
 *
 * ## Example
 *
 * <iframe src="https://codesandbox.io/embed/741op4mmj0?fontsize=14" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe>
 *
 */

var Transition = function (_React$Component) {
  _inherits(Transition, _React$Component);

  function Transition(props, context) {
    _classCallCheck(this, Transition);

    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));

    var parentGroup = context.transitionGroup;
    // In the context of a TransitionGroup all enters are really appears
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;

    var initialStatus = void 0;

    _this.appearStatus = null;

    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }

    _this.state = { status: initialStatus };

    _this.nextCallback = null;
    return _this;
  }

  Transition.prototype.getChildContext = function getChildContext() {
    return { transitionGroup: null // allows for nested Transitions
    };
  };

  Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;

    if (nextIn && prevState.status === UNMOUNTED) {
      return { status: EXITED };
    }
    return null;
  };

  // getSnapshotBeforeUpdate(prevProps) {
  //   let nextStatus = null

  //   if (prevProps !== this.props) {
  //     const { status } = this.state

  //     if (this.props.in) {
  //       if (status !== ENTERING && status !== ENTERED) {
  //         nextStatus = ENTERING
  //       }
  //     } else {
  //       if (status === ENTERING || status === ENTERED) {
  //         nextStatus = EXITING
  //       }
  //     }
  //   }

  //   return { nextStatus }
  // }

  Transition.prototype.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };

  Transition.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;


      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  };

  Transition.prototype.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };

  Transition.prototype.getTimeouts = function getTimeouts() {
    var timeout = this.props.timeout;

    var exit = void 0,
        enter = void 0,
        appear = void 0;

    exit = enter = appear = timeout;

    if (timeout != null && typeof timeout !== 'number') {
      exit = timeout.exit;
      enter = timeout.enter;
      appear = timeout.appear;
    }
    return { exit: exit, enter: enter, appear: appear };
  };

  Transition.prototype.updateStatus = function updateStatus() {
    var mounting = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var nextStatus = arguments[1];

    if (nextStatus !== null) {
      // nextStatus will always be ENTERING or EXITING.
      this.cancelNextCallback();
      var node = _reactDom2.default.findDOMNode(this);

      if (nextStatus === ENTERING) {
        this.performEnter(node, mounting);
      } else {
        this.performExit(node);
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({ status: UNMOUNTED });
    }
  };

  Transition.prototype.performEnter = function performEnter(node, mounting) {
    var _this2 = this;

    var enter = this.props.enter;

    var appearing = this.context.transitionGroup ? this.context.transitionGroup.isMounting : mounting;

    var timeouts = this.getTimeouts();

    // no enter animation skip right to ENTERED
    // if we are mounting and running this it means appear _must_ be set
    if (!mounting && !enter) {
      this.safeSetState({ status: ENTERED }, function () {
        _this2.props.onEntered(node);
      });
      return;
    }

    this.props.onEnter(node, appearing);

    this.safeSetState({ status: ENTERING }, function () {
      _this2.props.onEntering(node, appearing);

      // FIXME: appear timeout?
      _this2.onTransitionEnd(node, timeouts.enter, function () {
        _this2.safeSetState({ status: ENTERED }, function () {
          _this2.props.onEntered(node, appearing);
        });
      });
    });
  };

  Transition.prototype.performExit = function performExit(node) {
    var _this3 = this;

    var exit = this.props.exit;

    var timeouts = this.getTimeouts();

    // no exit animation skip right to EXITED
    if (!exit) {
      this.safeSetState({ status: EXITED }, function () {
        _this3.props.onExited(node);
      });
      return;
    }
    this.props.onExit(node);

    this.safeSetState({ status: EXITING }, function () {
      _this3.props.onExiting(node);

      _this3.onTransitionEnd(node, timeouts.exit, function () {
        _this3.safeSetState({ status: EXITED }, function () {
          _this3.props.onExited(node);
        });
      });
    });
  };

  Transition.prototype.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };

  Transition.prototype.safeSetState = function safeSetState(nextState, callback) {
    // This shouldn't be necessary, but there are weird race conditions with
    // setState callbacks and unmounting in testing, so always make sure that
    // we can cancel any pending setState callbacks after we unmount.
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };

  Transition.prototype.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;

    var active = true;

    this.nextCallback = function (event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;

        callback(event);
      }
    };

    this.nextCallback.cancel = function () {
      active = false;
    };

    return this.nextCallback;
  };

  Transition.prototype.onTransitionEnd = function onTransitionEnd(node, timeout, handler) {
    this.setNextCallback(handler);

    if (node) {
      if (this.props.addEndListener) {
        this.props.addEndListener(node, this.nextCallback);
      }
      if (timeout != null) {
        setTimeout(this.nextCallback, timeout);
      }
    } else {
      setTimeout(this.nextCallback, 0);
    }
  };

  Transition.prototype.render = function render() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }

    var _props = this.props,
        children = _props.children,
        childProps = _objectWithoutProperties(_props, ['children']);
    // filter props for Transtition


    delete childProps.in;
    delete childProps.mountOnEnter;
    delete childProps.unmountOnExit;
    delete childProps.appear;
    delete childProps.enter;
    delete childProps.exit;
    delete childProps.timeout;
    delete childProps.addEndListener;
    delete childProps.onEnter;
    delete childProps.onEntering;
    delete childProps.onEntered;
    delete childProps.onExit;
    delete childProps.onExiting;
    delete childProps.onExited;

    if (typeof children === 'function') {
      return children(status, childProps);
    }

    var child = _react2.default.Children.only(children);
    return _react2.default.cloneElement(child, childProps);
  };

  return Transition;
}(_react2.default.Component);

Transition.contextTypes = {
  transitionGroup: PropTypes.object
};
Transition.childContextTypes = {
  transitionGroup: function transitionGroup() {}
};


Transition.propTypes =  false ? {
  /**
   * A `function` child can be used instead of a React element.
   * This function is called with the current transition status
   * ('entering', 'entered', 'exiting', 'exited', 'unmounted'), which can be used
   * to apply context specific props to a component.
   *
   * ```jsx
   * <Transition timeout={150}>
   *   {(status) => (
   *     <MyComponent className={`fade fade-${status}`} />
   *   )}
   * </Transition>
   * ```
   */
  children: PropTypes.oneOfType([PropTypes.func.isRequired, PropTypes.element.isRequired]).isRequired,

  /**
   * Show the component; triggers the enter or exit states
   */
  in: PropTypes.bool,

  /**
   * By default the child component is mounted immediately along with
   * the parent `Transition` component. If you want to "lazy mount" the component on the
   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
   * mounted, even on "exited", unless you also specify `unmountOnExit`.
   */
  mountOnEnter: PropTypes.bool,

  /**
   * By default the child component stays mounted after it reaches the `'exited'` state.
   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
   */
  unmountOnExit: PropTypes.bool,

  /**
   * Normally a component is not transitioned if it is shown when the `<Transition>` component mounts.
   * If you want to transition on the first mount set `appear` to `true`, and the
   * component will transition in as soon as the `<Transition>` mounts.
   *
   * > Note: there are no specific "appear" states. `appear` only adds an additional `enter` transition.
   */
  appear: PropTypes.bool,

  /**
   * Enable or disable enter transitions.
   */
  enter: PropTypes.bool,

  /**
   * Enable or disable exit transitions.
   */
  exit: PropTypes.bool,

  /**
   * The duration of the transition, in milliseconds.
   * Required unless `addEndListener` is provided
   *
   * You may specify a single timeout for all transitions like: `timeout={500}`,
   * or individually like:
   *
   * ```jsx
   * timeout={{
   *  enter: 300,
   *  exit: 500,
   * }}
   * ```
   *
   * @type {number | { enter?: number, exit?: number }}
   */
  timeout: function timeout(props) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var pt = _PropTypes.timeoutsShape;
    if (!props.addEndListener) pt = pt.isRequired;
    return pt.apply(undefined, [props].concat(args));
  },

  /**
   * Add a custom transition end trigger. Called with the transitioning
   * DOM node and a `done` callback. Allows for more fine grained transition end
   * logic. **Note:** Timeouts are still used as a fallback if provided.
   *
   * ```jsx
   * addEndListener={(node, done) => {
   *   // use the css transitionend event to mark the finish of a transition
   *   node.addEventListener('transitionend', done, false);
   * }}
   * ```
   */
  addEndListener: PropTypes.func,

  /**
   * Callback fired before the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEnter: PropTypes.func,

  /**
   * Callback fired after the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: PropTypes.func,

  /**
   * Callback fired after the "entered" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEntered: PropTypes.func,

  /**
   * Callback fired before the "exiting" status is applied.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExit: PropTypes.func,

  /**
   * Callback fired after the "exiting" status is applied.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExiting: PropTypes.func,

  /**
   * Callback fired after the "exited" status is applied.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExited: PropTypes.func

  // Name the function so it is clearer in the documentation
} : {};function noop() {}

Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,

  onEnter: noop,
  onEntering: noop,
  onEntered: noop,

  onExit: noop,
  onExiting: noop,
  onExited: noop
};

Transition.UNMOUNTED = 0;
Transition.EXITED = 1;
Transition.ENTERING = 2;
Transition.ENTERED = 3;
Transition.EXITING = 4;

exports.default = (0, _reactLifecyclesCompat.polyfill)(Transition);

/***/ }),
/* 436 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyfill", function() { return polyfill; });
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

function componentWillMount() {
  // Call this.constructor.gDSFP to support sub-classes.
  var state = this.constructor.getDerivedStateFromProps(this.props, this.state);
  if (state !== null && state !== undefined) {
    this.setState(state);
  }
}

function componentWillReceiveProps(nextProps) {
  // Call this.constructor.gDSFP to support sub-classes.
  // Use the setState() updater to ensure state isn't stale in certain edge cases.
  function updater(prevState) {
    var state = this.constructor.getDerivedStateFromProps(nextProps, prevState);
    return state !== null && state !== undefined ? state : null;
  }
  // Binding "this" is important for shallow renderer support.
  this.setState(updater.bind(this));
}

function componentWillUpdate(nextProps, nextState) {
  try {
    var prevProps = this.props;
    var prevState = this.state;
    this.props = nextProps;
    this.state = nextState;
    this.__reactInternalSnapshotFlag = true;
    this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(
      prevProps,
      prevState
    );
  } finally {
    this.props = prevProps;
    this.state = prevState;
  }
}

// React may warn about cWM/cWRP/cWU methods being deprecated.
// Add a flag to suppress these warnings for this special case.
componentWillMount.__suppressDeprecationWarning = true;
componentWillReceiveProps.__suppressDeprecationWarning = true;
componentWillUpdate.__suppressDeprecationWarning = true;

function polyfill(Component) {
  var prototype = Component.prototype;

  if (!prototype || !prototype.isReactComponent) {
    throw new Error('Can only polyfill class components');
  }

  if (
    typeof Component.getDerivedStateFromProps !== 'function' &&
    typeof prototype.getSnapshotBeforeUpdate !== 'function'
  ) {
    return Component;
  }

  // If new component APIs are defined, "unsafe" lifecycles won't be called.
  // Error if any of these lifecycles are present,
  // Because they would work differently between older and newer (16.3+) versions of React.
  var foundWillMountName = null;
  var foundWillReceivePropsName = null;
  var foundWillUpdateName = null;
  if (typeof prototype.componentWillMount === 'function') {
    foundWillMountName = 'componentWillMount';
  } else if (typeof prototype.UNSAFE_componentWillMount === 'function') {
    foundWillMountName = 'UNSAFE_componentWillMount';
  }
  if (typeof prototype.componentWillReceiveProps === 'function') {
    foundWillReceivePropsName = 'componentWillReceiveProps';
  } else if (typeof prototype.UNSAFE_componentWillReceiveProps === 'function') {
    foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';
  }
  if (typeof prototype.componentWillUpdate === 'function') {
    foundWillUpdateName = 'componentWillUpdate';
  } else if (typeof prototype.UNSAFE_componentWillUpdate === 'function') {
    foundWillUpdateName = 'UNSAFE_componentWillUpdate';
  }
  if (
    foundWillMountName !== null ||
    foundWillReceivePropsName !== null ||
    foundWillUpdateName !== null
  ) {
    var componentName = Component.displayName || Component.name;
    var newApiName =
      typeof Component.getDerivedStateFromProps === 'function'
        ? 'getDerivedStateFromProps()'
        : 'getSnapshotBeforeUpdate()';

    throw Error(
      'Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n' +
        componentName +
        ' uses ' +
        newApiName +
        ' but also contains the following legacy lifecycles:' +
        (foundWillMountName !== null ? '\n  ' + foundWillMountName : '') +
        (foundWillReceivePropsName !== null
          ? '\n  ' + foundWillReceivePropsName
          : '') +
        (foundWillUpdateName !== null ? '\n  ' + foundWillUpdateName : '') +
        '\n\nThe above lifecycles should be removed. Learn more about this warning here:\n' +
        'https://fb.me/react-async-component-lifecycle-hooks'
    );
  }

  // React <= 16.2 does not support static getDerivedStateFromProps.
  // As a workaround, use cWM and cWRP to invoke the new static lifecycle.
  // Newer versions of React will ignore these lifecycles if gDSFP exists.
  if (typeof Component.getDerivedStateFromProps === 'function') {
    prototype.componentWillMount = componentWillMount;
    prototype.componentWillReceiveProps = componentWillReceiveProps;
  }

  // React <= 16.2 does not support getSnapshotBeforeUpdate.
  // As a workaround, use cWU to invoke the new lifecycle.
  // Newer versions of React will ignore that lifecycle if gSBU exists.
  if (typeof prototype.getSnapshotBeforeUpdate === 'function') {
    if (typeof prototype.componentDidUpdate !== 'function') {
      throw new Error(
        'Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype'
      );
    }

    prototype.componentWillUpdate = componentWillUpdate;

    var componentDidUpdate = prototype.componentDidUpdate;

    prototype.componentDidUpdate = function componentDidUpdatePolyfill(
      prevProps,
      prevState,
      maybeSnapshot
    ) {
      // 16.3+ will not execute our will-update method;
      // It will pass a snapshot value to did-update though.
      // Older versions will require our polyfilled will-update value.
      // We need to handle both cases, but can't just check for the presence of "maybeSnapshot",
      // Because for <= 15.x versions this might be a "prevContext" object.
      // We also can't just check "__reactInternalSnapshot",
      // Because get-snapshot might return a falsy value.
      // So check for the explicit __reactInternalSnapshotFlag flag to determine behavior.
      var snapshot = this.__reactInternalSnapshotFlag
        ? this.__reactInternalSnapshot
        : maybeSnapshot;

      componentDidUpdate.call(this, prevProps, prevState, snapshot);
    };
  }

  return Component;
}




/***/ }),
/* 437 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.classNamesShape = exports.timeoutsShape = undefined;
exports.transitionTimeout = transitionTimeout;

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function transitionTimeout(transitionType) {
  var timeoutPropName = 'transition' + transitionType + 'Timeout';
  var enabledPropName = 'transition' + transitionType;

  return function (props) {
    // If the transition is enabled
    if (props[enabledPropName]) {
      // If no timeout duration is provided
      if (props[timeoutPropName] == null) {
        return new Error(timeoutPropName + ' wasn\'t supplied to CSSTransitionGroup: ' + 'this can cause unreliable animations and won\'t be supported in ' + 'a future version of React. See ' + 'https://fb.me/react-animation-transition-group-timeout for more ' + 'information.');

        // If the duration isn't a number
      } else if (typeof props[timeoutPropName] !== 'number') {
        return new Error(timeoutPropName + ' must be a number (in milliseconds)');
      }
    }

    return null;
  };
}

var timeoutsShape = exports.timeoutsShape = _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.shape({
  enter: _propTypes2.default.number,
  exit: _propTypes2.default.number
}).isRequired]);

var classNamesShape = exports.classNamesShape = _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.shape({
  enter: _propTypes2.default.string,
  exit: _propTypes2.default.string,
  active: _propTypes2.default.string
}), _propTypes2.default.shape({
  enter: _propTypes2.default.string,
  enterDone: _propTypes2.default.string,
  enterActive: _propTypes2.default.string,
  exit: _propTypes2.default.string,
  exitDone: _propTypes2.default.string,
  exitActive: _propTypes2.default.string
})]);

/***/ }),
/* 438 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _tabList = __webpack_require__(185);

Object.defineProperty(exports, 'TabList', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_tabList).default;
  }
});

var _tabPanels = __webpack_require__(187);

Object.defineProperty(exports, 'TabPanels', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_tabPanels).default;
  }
});

var _tab = __webpack_require__(186);

Object.defineProperty(exports, 'Tab', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_tab).default;
  }
});

var _tabs = __webpack_require__(442);

Object.defineProperty(exports, 'Tabs', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_tabs).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 439 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _propTypes2.default.object;

/***/ }),
/* 440 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 441 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 442 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _uniqueId = __webpack_require__(443);

var _uniqueId2 = _interopRequireDefault(_uniqueId);

var _tabList = __webpack_require__(185);

var _tabList2 = _interopRequireDefault(_tabList);

var _tabPanels = __webpack_require__(187);

var _tabPanels2 = _interopRequireDefault(_tabPanels);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Tabs = function (_React$Component) {
  _inherits(Tabs, _React$Component);

  function Tabs() {
    _classCallCheck(this, Tabs);

    var _this = _possibleConstructorReturn(this, (Tabs.__proto__ || Object.getPrototypeOf(Tabs)).call(this));

    _this.accessibleId = (0, _uniqueId2.default)();
    return _this;
  }

  _createClass(Tabs, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          activeIndex = _props.activeIndex,
          children = _props.children,
          className = _props.className,
          onActivateTab = _props.onActivateTab;

      var accessibleId = this.accessibleId;

      return _react2.default.createElement(
        'div',
        { className: className },
        _react2.default.Children.map(children, function (child) {
          if (!child) {
            return child;
          }

          switch (child.type) {
            case _tabList2.default:
              return _react2.default.cloneElement(child, { accessibleId: accessibleId, activeIndex: activeIndex, onActivateTab: onActivateTab });
            case _tabPanels2.default:
              return _react2.default.cloneElement(child, { accessibleId: accessibleId, activeIndex: activeIndex });
            default:
              return child;
          }
        })
      );
    }
  }]);

  return Tabs;
}(_react2.default.Component);

exports.default = Tabs;


Tabs.propTypes = {
  activeIndex: _propTypes2.default.number.isRequired,
  children: _propTypes2.default.node,
  className: _propTypes2.default.string,
  onActivateTab: _propTypes2.default.func
};

Tabs.defaultProps = {
  children: null,
  className: undefined,
  onActivateTab: function onActivateTab() {}
};

/***/ }),
/* 443 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = uniqueId;
var counter = 0;

function uniqueId() {
  counter += 1;
  return "$rac$" + counter;
}

/***/ }),
/* 444 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["defaultMemoize"] = defaultMemoize;
/* harmony export (immutable) */ __webpack_exports__["createSelectorCreator"] = createSelectorCreator;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSelector", function() { return createSelector; });
/* harmony export (immutable) */ __webpack_exports__["createStructuredSelector"] = createStructuredSelector;
function defaultEqualityCheck(a, b) {
  return a === b;
}

function areArgumentsShallowlyEqual(equalityCheck, prev, next) {
  if (prev === null || next === null || prev.length !== next.length) {
    return false;
  }

  // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.
  var length = prev.length;
  for (var i = 0; i < length; i++) {
    if (!equalityCheck(prev[i], next[i])) {
      return false;
    }
  }

  return true;
}

function defaultMemoize(func) {
  var equalityCheck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultEqualityCheck;

  var lastArgs = null;
  var lastResult = null;
  // we reference arguments instead of spreading them for performance reasons
  return function () {
    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {
      // apply arguments instead of spreading for performance.
      lastResult = func.apply(null, arguments);
    }

    lastArgs = arguments;
    return lastResult;
  };
}

function getDependencies(funcs) {
  var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;

  if (!dependencies.every(function (dep) {
    return typeof dep === 'function';
  })) {
    var dependencyTypes = dependencies.map(function (dep) {
      return typeof dep;
    }).join(', ');
    throw new Error('Selector creators expect all input-selectors to be functions, ' + ('instead received the following types: [' + dependencyTypes + ']'));
  }

  return dependencies;
}

function createSelectorCreator(memoize) {
  for (var _len = arguments.length, memoizeOptions = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    memoizeOptions[_key - 1] = arguments[_key];
  }

  return function () {
    for (var _len2 = arguments.length, funcs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      funcs[_key2] = arguments[_key2];
    }

    var recomputations = 0;
    var resultFunc = funcs.pop();
    var dependencies = getDependencies(funcs);

    var memoizedResultFunc = memoize.apply(undefined, [function () {
      recomputations++;
      // apply arguments instead of spreading for performance.
      return resultFunc.apply(null, arguments);
    }].concat(memoizeOptions));

    // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.
    var selector = memoize(function () {
      var params = [];
      var length = dependencies.length;

      for (var i = 0; i < length; i++) {
        // apply arguments instead of spreading and mutate a local list of params for performance.
        params.push(dependencies[i].apply(null, arguments));
      }

      // apply arguments instead of spreading for performance.
      return memoizedResultFunc.apply(null, params);
    });

    selector.resultFunc = resultFunc;
    selector.dependencies = dependencies;
    selector.recomputations = function () {
      return recomputations;
    };
    selector.resetRecomputations = function () {
      return recomputations = 0;
    };
    return selector;
  };
}

var createSelector = createSelectorCreator(defaultMemoize);

function createStructuredSelector(selectors) {
  var selectorCreator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : createSelector;

  if (typeof selectors !== 'object') {
    throw new Error('createStructuredSelector expects first argument to be an object ' + ('where each property is a selector, instead received a ' + typeof selectors));
  }
  var objectKeys = Object.keys(selectors);
  return selectorCreator(objectKeys.map(function (key) {
    return selectors[key];
  }), function () {
    for (var _len3 = arguments.length, values = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      values[_key3] = arguments[_key3];
    }

    return values.reduce(function (composition, value, index) {
      composition[objectKeys[index]] = value;
      return composition;
    }, {});
  });
}

/***/ }),
/* 445 */
/***/ (function(module, exports, __webpack_require__) {

const SplitBox = __webpack_require__(446);

module.exports = SplitBox;

/***/ }),
/* 446 */
/***/ (function(module, exports, __webpack_require__) {

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const React = __webpack_require__(6);
const ReactDOM = __webpack_require__(112);
const Draggable = React.createFactory(__webpack_require__(447));
const { Component } = React;
const PropTypes = __webpack_require__(0);
const dom = __webpack_require__(1);

__webpack_require__(448);

/**
 * This component represents a Splitter. The splitter supports vertical
 * as well as horizontal mode.
 */
class SplitBox extends Component {
  static get propTypes() {
    return {
      // Custom class name. You can use more names separated by a space.
      className: PropTypes.string,
      // Initial size of controlled panel.
      initialSize: PropTypes.any,
      // Optional initial width of controlled panel.
      initialWidth: PropTypes.number,
      // Optional initial height of controlled panel.
      initialHeight: PropTypes.number,
      // Left/top panel
      startPanel: PropTypes.any,
      // Left/top panel collapse state.
      startPanelCollapsed: PropTypes.bool,
      // Min panel size.
      minSize: PropTypes.any,
      // Max panel size.
      maxSize: PropTypes.any,
      // Right/bottom panel
      endPanel: PropTypes.any,
      // Right/bottom panel collapse state.
      endPanelCollapsed: PropTypes.bool,
      // True if the right/bottom panel should be controlled.
      endPanelControl: PropTypes.bool,
      // Size of the splitter handle bar.
      splitterSize: PropTypes.number,
      // True if the splitter bar is vertical (default is vertical).
      vert: PropTypes.bool,
      // Optional style properties passed into the splitbox
      style: PropTypes.object,
      // Optional callback when splitbox resize stops
      onResizeEnd: PropTypes.func
    };
  }

  static get defaultProps() {
    return {
      splitterSize: 5,
      vert: true,
      endPanelControl: false,
      endPanelCollapsed: false,
      startPanelCollapsed: false
    };
  }

  constructor(props) {
    super(props);

    this.state = {
      vert: props.vert,
      // We use integers for these properties
      width: parseInt(props.initialWidth || props.initialSize, 10),
      height: parseInt(props.initialHeight || props.initialSize, 10)
    };

    this.onStartMove = this.onStartMove.bind(this);
    this.onStopMove = this.onStopMove.bind(this);
    this.onMove = this.onMove.bind(this);
    this.preparePanelStyles = this.preparePanelStyles.bind(this);
  }

  componentWillReceiveProps(nextProps) {
    if (this.props.vert !== nextProps.vert) {
      this.setState({ vert: nextProps.vert });
    }
    if (this.props.initialSize !== nextProps.initialSize || this.props.initialWidth !== nextProps.initialWidth || this.props.initialHeight !== nextProps.initialHeight) {
      this.setState({
        width: parseInt(nextProps.initialWidth || nextProps.initialSize, 10),
        height: parseInt(nextProps.initialHeight || nextProps.initialSize, 10)
      });
    }
  }

  // Dragging Events

  /**
   * Set 'resizing' cursor on entire document during splitter dragging.
   * This avoids cursor-flickering that happens when the mouse leaves
   * the splitter bar area (happens frequently).
   */
  onStartMove() {
    const splitBox = ReactDOM.findDOMNode(this);
    const doc = splitBox.ownerDocument;
    const defaultCursor = doc.documentElement.style.cursor;
    doc.documentElement.style.cursor = this.state.vert ? "ew-resize" : "ns-resize";

    splitBox.classList.add("dragging");
    document.dispatchEvent(new CustomEvent("drag:start"));

    this.setState({
      defaultCursor: defaultCursor
    });
  }

  onStopMove() {
    const splitBox = ReactDOM.findDOMNode(this);
    const doc = splitBox.ownerDocument;
    doc.documentElement.style.cursor = this.state.defaultCursor;

    splitBox.classList.remove("dragging");
    document.dispatchEvent(new CustomEvent("drag:end"));

    if (this.props.onResizeEnd) {
      this.props.onResizeEnd(this.state.vert ? this.state.width : this.state.height);
    }
  }

  /**
   * Adjust size of the controlled panel. Depending on the current
   * orientation we either remember the width or height of
   * the splitter box.
   */
  onMove({ movementX, movementY }) {
    const node = ReactDOM.findDOMNode(this);
    const doc = node.ownerDocument;

    if (this.props.endPanelControl) {
      // For the end panel we need to increase the width/height when the
      // movement is towards the left/top.
      movementX = -movementX;
      movementY = -movementY;
    }

    if (this.state.vert) {
      const isRtl = doc.dir === "rtl";
      if (isRtl) {
        // In RTL we need to reverse the movement again -- but only for vertical
        // splitters
        movementX = -movementX;
      }

      this.setState((state, props) => ({
        width: state.width + movementX
      }));
    } else {
      this.setState((state, props) => ({
        height: state.height + movementY
      }));
    }
  }

  // Rendering
  preparePanelStyles() {
    const vert = this.state.vert;
    const {
      minSize,
      maxSize,
      startPanelCollapsed,
      endPanelControl,
      endPanelCollapsed
    } = this.props;
    let leftPanelStyle, rightPanelStyle;

    // Set proper size for panels depending on the current state.
    if (vert) {
      const startWidth = endPanelControl ? null : this.state.width,
            endWidth = endPanelControl ? this.state.width : null;

      leftPanelStyle = {
        maxWidth: endPanelControl ? null : maxSize,
        minWidth: endPanelControl ? null : minSize,
        width: startPanelCollapsed ? 0 : startWidth
      };
      rightPanelStyle = {
        maxWidth: endPanelControl ? maxSize : null,
        minWidth: endPanelControl ? minSize : null,
        width: endPanelCollapsed ? 0 : endWidth
      };
    } else {
      const startHeight = endPanelControl ? null : this.state.height,
            endHeight = endPanelControl ? this.state.height : null;

      leftPanelStyle = {
        maxHeight: endPanelControl ? null : maxSize,
        minHeight: endPanelControl ? null : minSize,
        height: endPanelCollapsed ? maxSize : startHeight
      };
      rightPanelStyle = {
        maxHeight: endPanelControl ? maxSize : null,
        minHeight: endPanelControl ? minSize : null,
        height: startPanelCollapsed ? maxSize : endHeight
      };
    }

    return { leftPanelStyle, rightPanelStyle };
  }

  render() {
    const vert = this.state.vert;
    const {
      startPanelCollapsed,
      startPanel,
      endPanel,
      endPanelControl,
      splitterSize,
      endPanelCollapsed
    } = this.props;

    const style = Object.assign({}, this.props.style);

    // Calculate class names list.
    let classNames = ["split-box"];
    classNames.push(vert ? "vert" : "horz");
    if (this.props.className) {
      classNames = classNames.concat(this.props.className.split(" "));
    }

    const { leftPanelStyle, rightPanelStyle } = this.preparePanelStyles();

    // Calculate splitter size
    const splitterStyle = {
      flex: `0 0 ${splitterSize}px`
    };

    return dom.div({
      className: classNames.join(" "),
      style: style
    }, !startPanelCollapsed ? dom.div({
      className: endPanelControl ? "uncontrolled" : "controlled",
      style: leftPanelStyle
    }, startPanel) : null, Draggable({
      className: "splitter",
      style: splitterStyle,
      onStart: this.onStartMove,
      onStop: this.onStopMove,
      onMove: this.onMove
    }), !endPanelCollapsed ? dom.div({
      className: endPanelControl ? "controlled" : "uncontrolled",
      style: rightPanelStyle
    }, endPanel) : null);
  }
}

module.exports = SplitBox;

/***/ }),
/* 447 */
/***/ (function(module, exports, __webpack_require__) {

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const React = __webpack_require__(6);
const ReactDOM = __webpack_require__(112);
const { Component } = React;
const PropTypes = __webpack_require__(0);
const dom = __webpack_require__(1);

class Draggable extends Component {
  static get propTypes() {
    return {
      onMove: PropTypes.func.isRequired,
      onStart: PropTypes.func,
      onStop: PropTypes.func,
      style: PropTypes.object,
      className: PropTypes.string
    };
  }

  constructor(props) {
    super(props);
    this.startDragging = this.startDragging.bind(this);
    this.onMove = this.onMove.bind(this);
    this.onUp = this.onUp.bind(this);
  }

  startDragging(ev) {
    ev.preventDefault();
    const doc = ReactDOM.findDOMNode(this).ownerDocument;
    doc.addEventListener("mousemove", this.onMove);
    doc.addEventListener("mouseup", this.onUp);
    this.props.onStart && this.props.onStart();
  }

  onMove(ev) {
    ev.preventDefault();

    // When the target is outside of the document, its tagName is undefined
    if (!ev.target.tagName) {
      return;
    }

    // We pass the whole event because we don't know which properties
    // the callee needs.
    this.props.onMove(ev);
  }

  onUp(ev) {
    ev.preventDefault();
    const doc = ReactDOM.findDOMNode(this).ownerDocument;
    doc.removeEventListener("mousemove", this.onMove);
    doc.removeEventListener("mouseup", this.onUp);
    this.props.onStop && this.props.onStop();
  }

  render() {
    return dom.div({
      style: this.props.style,
      className: this.props.className,
      onMouseDown: this.startDragging
    });
  }
}

module.exports = Draggable;

/***/ }),
/* 448 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 449 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = move;

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function move(array, moveIndex, toIndex) {
  /* #move - Moves an array item from one position in an array to another.
      Note: This is a pure function so a new array will be returned, instead
     of altering the array argument.
     Arguments:
    1. array     (String) : Array in which to move an item.         (required)
    2. moveIndex (Object) : The index of the item to move.          (required)
    3. toIndex   (Object) : The index to move item at moveIndex to. (required)
  */
  var item = array[moveIndex];
  var length = array.length;
  var diff = moveIndex - toIndex;

  if (diff > 0) {
    // move left
    return [].concat(_toConsumableArray(array.slice(0, toIndex)), [item], _toConsumableArray(array.slice(toIndex, moveIndex)), _toConsumableArray(array.slice(moveIndex + 1, length)));
  } else if (diff < 0) {
    // move right
    return [].concat(_toConsumableArray(array.slice(0, moveIndex)), _toConsumableArray(array.slice(moveIndex + 1, toIndex + 1)), [item], _toConsumableArray(array.slice(toIndex + 1, length)));
  }
  return array;
}

/***/ }),
/* 450 */,
/* 451 */,
/* 452 */,
/* 453 */,
/* 454 */,
/* 455 */,
/* 456 */,
/* 457 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const { MODE } = __webpack_require__(4);
const { REPS, getRep } = __webpack_require__(24);
const objectInspector = __webpack_require__(482);

const {
  parseURLEncodedText,
  parseURLParams,
  maybeEscapePropertyName,
  getGripPreviewItems
} = __webpack_require__(2);

module.exports = {
  REPS,
  getRep,
  MODE,
  maybeEscapePropertyName,
  parseURLEncodedText,
  parseURLParams,
  getGripPreviewItems,
  objectInspector
};

/***/ }),
/* 458 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 459 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// Dependencies
const { getGripType, wrapRender } = __webpack_require__(2);

const dom = __webpack_require__(1);
const { span } = dom;

/**
 * Renders undefined value
 */
const Undefined = function () {
  return span({ className: "objectBox objectBox-undefined" }, "undefined");
};

function supportsObject(object, noGrip = false) {
  if (noGrip === true) {
    return object === undefined;
  }

  return object && object.type && object.type == "undefined" || getGripType(object, noGrip) == "undefined";
}

// Exports from this module

module.exports = {
  rep: wrapRender(Undefined),
  supportsObject
};

/***/ }),
/* 460 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// Dependencies
const { wrapRender } = __webpack_require__(2);
const dom = __webpack_require__(1);
const { span } = dom;

/**
 * Renders null value
 */
function Null(props) {
  return span({ className: "objectBox objectBox-null" }, "null");
}

function supportsObject(object, noGrip = false) {
  if (noGrip === true) {
    return object === null;
  }

  if (object && object.type && object.type == "null") {
    return true;
  }

  return object == null;
}

// Exports from this module

module.exports = {
  rep: wrapRender(Null),
  supportsObject
};

/***/ }),
/* 461 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// Dependencies
const PropTypes = __webpack_require__(0);

const { getGripType, wrapRender } = __webpack_require__(2);

const dom = __webpack_require__(1);
const { span } = dom;

/**
 * Renders a number
 */
Number.propTypes = {
  object: PropTypes.oneOfType([PropTypes.object, PropTypes.number, PropTypes.bool]).isRequired
};

function Number(props) {
  const value = props.object;

  return span({ className: "objectBox objectBox-number" }, stringify(value));
}

function stringify(object) {
  const isNegativeZero = Object.is(object, -0) || object.type && object.type == "-0";

  return isNegativeZero ? "-0" : String(object);
}

function supportsObject(object, noGrip = false) {
  return ["boolean", "number", "-0"].includes(getGripType(object, noGrip));
}

// Exports from this module

module.exports = {
  rep: wrapRender(Number),
  supportsObject
};

/***/ }),
/* 462 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// Dependencies
const PropTypes = __webpack_require__(0);
const { wrapRender, ellipsisElement } = __webpack_require__(2);
const PropRep = __webpack_require__(39);
const { MODE } = __webpack_require__(4);

const dom = __webpack_require__(1);
const { span } = dom;

const DEFAULT_TITLE = "Object";

/**
 * Renders an object. An object is represented by a list of its
 * properties enclosed in curly brackets.
 */
ObjectRep.propTypes = {
  object: PropTypes.object.isRequired,
  // @TODO Change this to Object.values when supported in Node's version of V8
  mode: PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key])),
  title: PropTypes.string
};

function ObjectRep(props) {
  const object = props.object;
  const propsArray = safePropIterator(props, object);

  if (props.mode === MODE.TINY) {
    const tinyModeItems = [];
    if (getTitle(props, object) !== DEFAULT_TITLE) {
      tinyModeItems.push(getTitleElement(props, object));
    } else {
      tinyModeItems.push(span({
        className: "objectLeftBrace"
      }, "{"), propsArray.length > 0 ? ellipsisElement : null, span({
        className: "objectRightBrace"
      }, "}"));
    }

    return span({ className: "objectBox objectBox-object" }, ...tinyModeItems);
  }

  return span({ className: "objectBox objectBox-object" }, getTitleElement(props, object), span({
    className: "objectLeftBrace"
  }, " { "), ...propsArray, span({
    className: "objectRightBrace"
  }, " }"));
}

function getTitleElement(props, object) {
  return span({ className: "objectTitle" }, getTitle(props, object));
}

function getTitle(props, object) {
  return props.title || DEFAULT_TITLE;
}

function safePropIterator(props, object, max) {
  max = typeof max === "undefined" ? 3 : max;
  try {
    return propIterator(props, object, max);
  } catch (err) {
    console.error(err);
  }
  return [];
}

function propIterator(props, object, max) {
  // Work around https://bugzilla.mozilla.org/show_bug.cgi?id=945377
  if (Object.prototype.toString.call(object) === "[object Generator]") {
    object = Object.getPrototypeOf(object);
  }

  const elements = [];
  const unimportantProperties = [];
  let propertiesNumber = 0;
  const propertiesNames = Object.keys(object);

  const pushPropRep = (name, value) => {
    elements.push(PropRep({
      ...props,
      key: name,
      mode: MODE.TINY,
      name,
      object: value,
      equal: ": "
    }));
    propertiesNumber++;

    if (propertiesNumber < propertiesNames.length) {
      elements.push(", ");
    }
  };

  try {
    for (const name of propertiesNames) {
      if (propertiesNumber >= max) {
        break;
      }

      let value;
      try {
        value = object[name];
      } catch (exc) {
        continue;
      }

      // Object members with non-empty values are preferred since it gives the
      // user a better overview of the object.
      if (isInterestingProp(value)) {
        pushPropRep(name, value);
      } else {
        // If the property is not important, put its name on an array for later
        // use.
        unimportantProperties.push(name);
      }
    }
  } catch (err) {
    console.error(err);
  }

  if (propertiesNumber < max) {
    for (const name of unimportantProperties) {
      if (propertiesNumber >= max) {
        break;
      }

      let value;
      try {
        value = object[name];
      } catch (exc) {
        continue;
      }

      pushPropRep(name, value);
    }
  }

  if (propertiesNumber < propertiesNames.length) {
    elements.push(ellipsisElement);
  }

  return elements;
}

function isInterestingProp(value) {
  const type = typeof value;
  return type == "boolean" || type == "number" || type == "string" && value;
}

function supportsObject(object, noGrip = false) {
  return noGrip;
}

// Exports from this module
module.exports = {
  rep: wrapRender(ObjectRep),
  supportsObject
};

/***/ }),
/* 463 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// Dependencies
const PropTypes = __webpack_require__(0);

const { getGripType, wrapRender } = __webpack_require__(2);

const dom = __webpack_require__(1);
const { rep: StringRep } = __webpack_require__(25);
const { span } = dom;

const MAX_STRING_LENGTH = 50;

/**
 * Renders a symbol.
 */
SymbolRep.propTypes = {
  object: PropTypes.object.isRequired
};

function SymbolRep(props) {
  const { className = "objectBox objectBox-symbol", object } = props;
  const { name } = object;

  let symbolText = name || "";
  if (name && name.type && name.type === "longString") {
    symbolText = StringRep({
      object: symbolText,
      shouldCrop: true,
      cropLimit: MAX_STRING_LENGTH,
      useQuotes: false
    });
  }

  return span({
    className,
    "data-link-actor-id": object.actor
  }, "Symbol(", symbolText, ")");
}

function supportsObject(object, noGrip = false) {
  return getGripType(object, noGrip) == "symbol";
}

// Exports from this module
module.exports = {
  rep: wrapRender(SymbolRep),
  supportsObject
};

/***/ }),
/* 464 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// Dependencies
const PropTypes = __webpack_require__(0);

const { getGripType, wrapRender } = __webpack_require__(2);

const dom = __webpack_require__(1);
const { span } = dom;

/**
 * Renders a Infinity object
 */
InfinityRep.propTypes = {
  object: PropTypes.object.isRequired
};

function InfinityRep(props) {
  const { object } = props;

  return span({ className: "objectBox objectBox-number" }, object.type);
}

function supportsObject(object, noGrip = false) {
  const type = getGripType(object, noGrip);
  return type == "Infinity" || type == "-Infinity";
}

// Exports from this module
module.exports = {
  rep: wrapRender(InfinityRep),
  supportsObject
};

/***/ }),
/* 465 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// Dependencies
const { getGripType, wrapRender } = __webpack_require__(2);

const dom = __webpack_require__(1);
const { span } = dom;

/**
 * Renders a NaN object
 */
function NaNRep(props) {
  return span({ className: "objectBox objectBox-nan" }, "NaN");
}

function supportsObject(object, noGrip = false) {
  return getGripType(object, noGrip) == "NaN";
}

// Exports from this module
module.exports = {
  rep: wrapRender(NaNRep),
  supportsObject
};

/***/ }),
/* 466 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// Dependencies
const dom = __webpack_require__(1);
const PropTypes = __webpack_require__(0);
const { wrapRender } = __webpack_require__(2);
const { MODE } = __webpack_require__(4);
const { span } = dom;

/**
 * Renders an object. An object is represented by a list of its
 * properties enclosed in curly brackets.
 */
Accessor.propTypes = {
  object: PropTypes.object.isRequired,
  mode: PropTypes.oneOf(Object.values(MODE))
};

function Accessor(props) {
  const { object, evaluation, onInvokeGetterButtonClick } = props;

  if (evaluation) {
    const { Rep, Grip } = __webpack_require__(24);
    return span({
      className: "objectBox objectBox-accessor objectTitle"
    }, Rep({
      ...props,
      object: evaluation.getterValue,
      mode: props.mode || MODE.TINY,
      defaultRep: Grip
    }));
  }

  if (hasGetter(object) && onInvokeGetterButtonClick) {
    return dom.button({
      className: "invoke-getter",
      title: "Invoke getter",
      onClick: event => {
        onInvokeGetterButtonClick();
        event.stopPropagation();
      }
    });
  }

  const accessors = [];
  if (hasGetter(object)) {
    accessors.push("Getter");
  }

  if (hasSetter(object)) {
    accessors.push("Setter");
  }

  return span({ className: "objectBox objectBox-accessor objectTitle" }, accessors.join(" & "));
}

function hasGetter(object) {
  return object && object.get && object.get.type !== "undefined";
}

function hasSetter(object) {
  return object && object.set && object.set.type !== "undefined";
}

function supportsObject(object, noGrip = false) {
  if (noGrip !== true && (hasGetter(object) || hasSetter(object))) {
    return true;
  }

  return false;
}

// Exports from this module
module.exports = {
  rep: wrapRender(Accessor),
  supportsObject
};

/***/ }),
/* 467 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// ReactJS
const PropTypes = __webpack_require__(0);
const { button, span } = __webpack_require__(1);

// Utils
const { isGrip, wrapRender } = __webpack_require__(2);
const { rep: StringRep } = __webpack_require__(25);

/**
 * Renders Accessible object.
 */
Accessible.propTypes = {
  object: PropTypes.object.isRequired,
  inspectIconTitle: PropTypes.string,
  nameMaxLength: PropTypes.number,
  onAccessibleClick: PropTypes.func,
  onAccessibleMouseOver: PropTypes.func,
  onAccessibleMouseOut: PropTypes.func,
  onInspectIconClick: PropTypes.func,
  roleFirst: PropTypes.bool,
  separatorText: PropTypes.string
};

function Accessible(props) {
  const {
    object,
    inspectIconTitle,
    nameMaxLength,
    onAccessibleClick,
    onAccessibleMouseOver,
    onAccessibleMouseOut,
    onInspectIconClick,
    roleFirst,
    separatorText
  } = props;
  const elements = getElements(object, nameMaxLength, roleFirst, separatorText);
  const isInTree = object.preview && object.preview.isConnected === true;
  const baseConfig = {
    "data-link-actor-id": object.actor,
    className: "objectBox objectBox-accessible"
  };

  let inspectIcon;
  if (isInTree) {
    if (onAccessibleClick) {
      Object.assign(baseConfig, {
        onClick: _ => onAccessibleClick(object),
        className: `${baseConfig.className} clickable`
      });
    }

    if (onAccessibleMouseOver) {
      Object.assign(baseConfig, {
        onMouseOver: _ => onAccessibleMouseOver(object)
      });
    }

    if (onAccessibleMouseOut) {
      Object.assign(baseConfig, {
        onMouseOut: onAccessibleMouseOut
      });
    }

    if (onInspectIconClick) {
      inspectIcon = button({
        className: "open-accessibility-inspector",
        title: inspectIconTitle,
        onClick: e => {
          if (onAccessibleClick) {
            e.stopPropagation();
          }

          onInspectIconClick(object, e);
        }
      });
    }
  }

  return span(baseConfig, ...elements, inspectIcon);
}

function getElements(grip, nameMaxLength, roleFirst = false, separatorText = ": ") {
  const { name, role } = grip.preview;
  const elements = [];
  if (name) {
    elements.push(StringRep({
      className: "accessible-name",
      object: name,
      cropLimit: nameMaxLength
    }), span({ className: "separator" }, separatorText));
  }

  elements.push(span({ className: "accessible-role" }, role));
  return roleFirst ? elements.reverse() : elements;
}

// Registration
function supportsObject(object, noGrip = false) {
  if (noGrip === true || !isGrip(object)) {
    return false;
  }

  return object.preview && object.typeName && object.typeName === "accessible";
}

// Exports from this module
module.exports = {
  rep: wrapRender(Accessible),
  supportsObject
};

/***/ }),
/* 468 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// ReactJS
const PropTypes = __webpack_require__(0);
const dom = __webpack_require__(1);
const { span } = dom;

// Reps
const { getGripType, isGrip, wrapRender } = __webpack_require__(2);
const { rep: StringRep } = __webpack_require__(25);

/**
 * Renders DOM attribute
 */
Attribute.propTypes = {
  object: PropTypes.object.isRequired
};

function Attribute(props) {
  const { object } = props;
  const value = object.preview.value;

  return span({
    "data-link-actor-id": object.actor,
    className: "objectBox-Attr"
  }, span({ className: "attrName" }, getTitle(object)), span({ className: "attrEqual" }, "="), StringRep({ className: "attrValue", object: value, title: value }));
}

function getTitle(grip) {
  return grip.preview.nodeName;
}

// Registration
function supportsObject(grip, noGrip = false) {
  if (noGrip === true || !isGrip(grip)) {
    return false;
  }

  return getGripType(grip, noGrip) == "Attr" && grip.preview;
}

module.exports = {
  rep: wrapRender(Attribute),
  supportsObject
};

/***/ }),
/* 469 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// ReactJS
const PropTypes = __webpack_require__(0);

// Reps
const { getGripType, isGrip, wrapRender } = __webpack_require__(2);

const dom = __webpack_require__(1);
const { span } = dom;

/**
 * Used to render JS built-in Date() object.
 */
DateTime.propTypes = {
  object: PropTypes.object.isRequired
};

function DateTime(props) {
  const grip = props.object;
  let date;
  try {
    const dateObject = new Date(grip.preview.timestamp);
    // Calling `toISOString` will throw if the date is invalid,
    // so we can render an `Invalid Date` element.
    dateObject.toISOString();

    date = span({
      "data-link-actor-id": grip.actor,
      className: "objectBox"
    }, getTitle(grip), span({ className: "Date" }, dateObject.toString()));
  } catch (e) {
    date = span({ className: "objectBox" }, "Invalid Date");
  }

  return date;
}

function getTitle(grip) {
  return span({
    className: "objectTitle"
  }, `${grip.class} `);
}

// Registration
function supportsObject(grip, noGrip = false) {
  if (noGrip === true || !isGrip(grip)) {
    return false;
  }

  return getGripType(grip, noGrip) == "Date" && grip.preview;
}

// Exports from this module
module.exports = {
  rep: wrapRender(DateTime),
  supportsObject
};

/***/ }),
/* 470 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// ReactJS
const PropTypes = __webpack_require__(0);

// Reps
const {
  getGripType,
  isGrip,
  getURLDisplayString,
  wrapRender
} = __webpack_require__(2);

const dom = __webpack_require__(1);
const { span } = dom;

/**
 * Renders DOM document object.
 */
Document.propTypes = {
  object: PropTypes.object.isRequired
};

function Document(props) {
  const grip = props.object;
  const location = getLocation(grip);
  return span({
    "data-link-actor-id": grip.actor,
    className: "objectBox objectBox-document"
  }, getTitle(grip), location ? span({ className: "location" }, ` ${location}`) : null);
}

function getLocation(grip) {
  const location = grip.preview.location;
  return location ? getURLDisplayString(location) : null;
}

function getTitle(grip) {
  return span({
    className: "objectTitle"
  }, grip.class);
}

// Registration
function supportsObject(object, noGrip = false) {
  if (noGrip === true || !isGrip(object)) {
    return false;
  }

  const type = getGripType(object, noGrip);
  return object.preview && (type === "HTMLDocument" || type === "XULDocument");
}

// Exports from this module
module.exports = {
  rep: wrapRender(Document),
  supportsObject
};

/***/ }),
/* 471 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// ReactJS
const PropTypes = __webpack_require__(0);

// Reps
const { getGripType, isGrip, wrapRender } = __webpack_require__(2);
const dom = __webpack_require__(1);
const { span } = dom;

/**
 * Renders DOM documentType object.
 */
DocumentType.propTypes = {
  object: PropTypes.object.isRequired
};

function DocumentType(props) {
  const { object } = props;
  const name = object && object.preview && object.preview.nodeName ? ` ${object.preview.nodeName}` : "";
  return span({
    "data-link-actor-id": props.object.actor,
    className: "objectBox objectBox-document"
  }, `<!DOCTYPE${name}>`);
}

// Registration
function supportsObject(object, noGrip = false) {
  if (noGrip === true || !isGrip(object)) {
    return false;
  }

  const type = getGripType(object, noGrip);
  return object.preview && type === "DocumentType";
}

// Exports from this module
module.exports = {
  rep: wrapRender(DocumentType),
  supportsObject
};

/***/ }),
/* 472 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// ReactJS
const PropTypes = __webpack_require__(0);

// Reps
const { isGrip, wrapRender } = __webpack_require__(2);

const { MODE } = __webpack_require__(4);
const { rep } = __webpack_require__(113);

/**
 * Renders DOM event objects.
 */
Event.propTypes = {
  object: PropTypes.object.isRequired,
  // @TODO Change this to Object.values when supported in Node's version of V8
  mode: PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key])),
  onDOMNodeMouseOver: PropTypes.func,
  onDOMNodeMouseOut: PropTypes.func,
  onInspectIconClick: PropTypes.func
};

function Event(props) {
  const gripProps = {
    ...props,
    title: getTitle(props),
    object: {
      ...props.object,
      preview: {
        ...props.object.preview,
        ownProperties: {}
      }
    }
  };

  if (gripProps.object.preview.target) {
    Object.assign(gripProps.object.preview.ownProperties, {
      target: gripProps.object.preview.target
    });
  }
  Object.assign(gripProps.object.preview.ownProperties, gripProps.object.preview.properties);

  delete gripProps.object.preview.properties;
  gripProps.object.ownPropertyLength = Object.keys(gripProps.object.preview.ownProperties).length;

  switch (gripProps.object.class) {
    case "MouseEvent":
      gripProps.isInterestingProp = (type, value, name) => {
        return ["target", "clientX", "clientY", "layerX", "layerY"].includes(name);
      };
      break;
    case "KeyboardEvent":
      gripProps.isInterestingProp = (type, value, name) => {
        return ["target", "key", "charCode", "keyCode"].includes(name);
      };
      break;
    case "MessageEvent":
      gripProps.isInterestingProp = (type, value, name) => {
        return ["target", "isTrusted", "data"].includes(name);
      };
      break;
    default:
      gripProps.isInterestingProp = (type, value, name) => {
        // We want to show the properties in the order they are declared.
        return Object.keys(gripProps.object.preview.ownProperties).includes(name);
      };
  }

  return rep(gripProps);
}

function getTitle(props) {
  const preview = props.object.preview;
  let title = preview.type;

  if (preview.eventKind == "key" && preview.modifiers && preview.modifiers.length) {
    title = `${title} ${preview.modifiers.join("-")}`;
  }
  return title;
}

// Registration
function supportsObject(grip, noGrip = false) {
  if (noGrip === true || !isGrip(grip)) {
    return false;
  }

  return grip.preview && grip.preview.kind == "DOMEvent";
}

// Exports from this module
module.exports = {
  rep: wrapRender(Event),
  supportsObject
};

/***/ }),
/* 473 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// ReactJS
const PropTypes = __webpack_require__(0);
// Dependencies
const { getGripType, isGrip, wrapRender } = __webpack_require__(2);

const PropRep = __webpack_require__(39);
const { MODE } = __webpack_require__(4);

const dom = __webpack_require__(1);
const { span } = dom;

/**
 * Renders a DOM Promise object.
 */
PromiseRep.propTypes = {
  object: PropTypes.object.isRequired,
  // @TODO Change this to Object.values when supported in Node's version of V8
  mode: PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key])),
  onDOMNodeMouseOver: PropTypes.func,
  onDOMNodeMouseOut: PropTypes.func,
  onInspectIconClick: PropTypes.func
};

function PromiseRep(props) {
  const object = props.object;
  const { promiseState } = object;

  const config = {
    "data-link-actor-id": object.actor,
    className: "objectBox objectBox-object"
  };

  if (props.mode === MODE.TINY) {
    const { Rep } = __webpack_require__(24);

    return span(config, getTitle(object), span({
      className: "objectLeftBrace"
    }, " { "), Rep({ object: promiseState.state }), span({
      className: "objectRightBrace"
    }, " }"));
  }

  const propsArray = getProps(props, promiseState);
  return span(config, getTitle(object), span({
    className: "objectLeftBrace"
  }, " { "), ...propsArray, span({
    className: "objectRightBrace"
  }, " }"));
}

function getTitle(object) {
  return span({
    className: "objectTitle"
  }, object.class);
}

function getProps(props, promiseState) {
  const keys = ["state"];
  if (Object.keys(promiseState).includes("value")) {
    keys.push("value");
  }

  return keys.reduce((res, key, i) => {
    const object = promiseState[key];
    res = res.concat(PropRep({
      ...props,
      mode: MODE.TINY,
      name: `<${key}>`,
      object,
      equal: ": ",
      suppressQuotes: true
    }));

    // Interleave commas between elements
    if (i !== keys.length - 1) {
      res.push(", ");
    }

    return res;
  }, []);
}

// Registration
function supportsObject(object, noGrip = false) {
  if (noGrip === true || !isGrip(object)) {
    return false;
  }
  return getGripType(object, noGrip) == "Promise";
}

// Exports from this module
module.exports = {
  rep: wrapRender(PromiseRep),
  supportsObject
};

/***/ }),
/* 474 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// ReactJS
const PropTypes = __webpack_require__(0);

// Reps
const { getGripType, isGrip, wrapRender } = __webpack_require__(2);

const dom = __webpack_require__(1);
const { span } = dom;

/**
 * Renders a grip object with regular expression.
 */
RegExp.propTypes = {
  object: PropTypes.object.isRequired
};

function RegExp(props) {
  const { object } = props;

  return span({
    "data-link-actor-id": object.actor,
    className: "objectBox objectBox-regexp regexpSource"
  }, getSource(object));
}

function getSource(grip) {
  return grip.displayString;
}

// Registration
function supportsObject(object, noGrip = false) {
  if (noGrip === true || !isGrip(object)) {
    return false;
  }

  return getGripType(object, noGrip) == "RegExp";
}

// Exports from this module
module.exports = {
  rep: wrapRender(RegExp),
  supportsObject
};

/***/ }),
/* 475 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// ReactJS
const PropTypes = __webpack_require__(0);

// Reps
const {
  getGripType,
  isGrip,
  getURLDisplayString,
  wrapRender
} = __webpack_require__(2);

const dom = __webpack_require__(1);
const { span } = dom;

/**
 * Renders a grip representing CSSStyleSheet
 */
StyleSheet.propTypes = {
  object: PropTypes.object.isRequired
};

function StyleSheet(props) {
  const grip = props.object;

  return span({
    "data-link-actor-id": grip.actor,
    className: "objectBox objectBox-object"
  }, getTitle(grip), span({ className: "objectPropValue" }, getLocation(grip)));
}

function getTitle(grip) {
  const title = "StyleSheet ";
  return span({ className: "objectBoxTitle" }, title);
}

function getLocation(grip) {
  // Embedded stylesheets don't have URL and so, no preview.
  const url = grip.preview ? grip.preview.url : "";
  return url ? getURLDisplayString(url) : "";
}

// Registration
function supportsObject(object, noGrip = false) {
  if (noGrip === true || !isGrip(object)) {
    return false;
  }

  return getGripType(object, noGrip) == "CSSStyleSheet";
}

// Exports from this module

module.exports = {
  rep: wrapRender(StyleSheet),
  supportsObject
};

/***/ }),
/* 476 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// Dependencies
const PropTypes = __webpack_require__(0);
const {
  isGrip,
  cropString,
  cropMultipleLines,
  wrapRender
} = __webpack_require__(2);
const { MODE } = __webpack_require__(4);
const nodeConstants = __webpack_require__(190);
const dom = __webpack_require__(1);
const { span } = dom;

/**
 * Renders DOM comment node.
 */
CommentNode.propTypes = {
  object: PropTypes.object.isRequired,
  // @TODO Change this to Object.values when supported in Node's version of V8
  mode: PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key]))
};

function CommentNode(props) {
  const { object, mode = MODE.SHORT } = props;

  let { textContent } = object.preview;
  if (mode === MODE.TINY) {
    textContent = cropMultipleLines(textContent, 30);
  } else if (mode === MODE.SHORT) {
    textContent = cropString(textContent, 50);
  }

  return span({
    className: "objectBox theme-comment",
    "data-link-actor-id": object.actor
  }, `<!-- ${textContent} -->`);
}

// Registration
function supportsObject(object, noGrip = false) {
  if (noGrip === true || !isGrip(object)) {
    return false;
  }
  return object.preview && object.preview.nodeType === nodeConstants.COMMENT_NODE;
}

// Exports from this module
module.exports = {
  rep: wrapRender(CommentNode),
  supportsObject
};

/***/ }),
/* 477 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// ReactJS
const PropTypes = __webpack_require__(0);

// Utils
const { isGrip, wrapRender } = __webpack_require__(2);
const { rep: StringRep, isLongString } = __webpack_require__(25);
const { MODE } = __webpack_require__(4);
const nodeConstants = __webpack_require__(190);

const dom = __webpack_require__(1);
const { span } = dom;

const MAX_ATTRIBUTE_LENGTH = 50;

/**
 * Renders DOM element node.
 */
ElementNode.propTypes = {
  object: PropTypes.object.isRequired,
  inspectIconTitle: PropTypes.string,
  // @TODO Change this to Object.values when supported in Node's version of V8
  mode: PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key])),
  onDOMNodeClick: PropTypes.func,
  onDOMNodeMouseOver: PropTypes.func,
  onDOMNodeMouseOut: PropTypes.func,
  onInspectIconClick: PropTypes.func
};

function ElementNode(props) {
  const {
    object,
    inspectIconTitle,
    mode,
    onDOMNodeClick,
    onDOMNodeMouseOver,
    onDOMNodeMouseOut,
    onInspectIconClick
  } = props;
  const elements = getElements(object, mode);

  const isInTree = object.preview && object.preview.isConnected === true;

  const baseConfig = {
    "data-link-actor-id": object.actor,
    className: "objectBox objectBox-node"
  };
  let inspectIcon;
  if (isInTree) {
    if (onDOMNodeClick) {
      Object.assign(baseConfig, {
        onClick: _ => onDOMNodeClick(object),
        className: `${baseConfig.className} clickable`
      });
    }

    if (onDOMNodeMouseOver) {
      Object.assign(baseConfig, {
        onMouseOver: _ => onDOMNodeMouseOver(object)
      });
    }

    if (onDOMNodeMouseOut) {
      Object.assign(baseConfig, {
        onMouseOut: onDOMNodeMouseOut
      });
    }

    if (onInspectIconClick) {
      inspectIcon = dom.button({
        className: "open-inspector",
        // TODO: Localize this with "openNodeInInspector" when Bug 1317038 lands
        title: inspectIconTitle || "Click to select the node in the inspector",
        onClick: e => {
          if (onDOMNodeClick) {
            e.stopPropagation();
          }

          onInspectIconClick(object, e);
        }
      });
    }
  }

  return span(baseConfig, ...elements, inspectIcon);
}

function getElements(grip, mode) {
  const {
    attributes,
    nodeName,
    isAfterPseudoElement,
    isBeforePseudoElement,
    isMarkerPseudoElement
  } = grip.preview;
  const nodeNameElement = span({
    className: "tag-name"
  }, nodeName);

  let pseudoNodeName;
  if (isAfterPseudoElement) {
    pseudoNodeName = "after";
  } else if (isBeforePseudoElement) {
    pseudoNodeName = "before";
  } else if (isMarkerPseudoElement) {
    pseudoNodeName = "marker";
  }
  if (pseudoNodeName) {
    return [span({ className: "attrName" }, `::${pseudoNodeName}`)];
  }

  if (mode === MODE.TINY) {
    const elements = [nodeNameElement];
    if (attributes.id) {
      elements.push(span({ className: "attrName" }, `#${attributes.id}`));
    }
    if (attributes.class) {
      elements.push(span({ className: "attrName" }, attributes.class.trim().split(/\s+/).map(cls => `.${cls}`).join("")));
    }
    return elements;
  }

  const attributeKeys = Object.keys(attributes);
  if (attributeKeys.includes("class")) {
    attributeKeys.splice(attributeKeys.indexOf("class"), 1);
    attributeKeys.unshift("class");
  }
  if (attributeKeys.includes("id")) {
    attributeKeys.splice(attributeKeys.indexOf("id"), 1);
    attributeKeys.unshift("id");
  }
  const attributeElements = attributeKeys.reduce((arr, name, i, keys) => {
    const value = attributes[name];

    let title = isLongString(value) ? value.initial : value;
    if (title.length < MAX_ATTRIBUTE_LENGTH) {
      title = null;
    }

    const attribute = span({}, span({ className: "attrName" }, name), span({ className: "attrEqual" }, "="), StringRep({
      className: "attrValue",
      object: value,
      cropLimit: MAX_ATTRIBUTE_LENGTH,
      title
    }));

    return arr.concat([" ", attribute]);
  }, []);

  return [span({ className: "angleBracket" }, "<"), nodeNameElement, ...attributeElements, span({ className: "angleBracket" }, ">")];
}

// Registration
function supportsObject(object, noGrip = false) {
  if (noGrip === true || !isGrip(object)) {
    return false;
  }
  return object.preview && object.preview.nodeType === nodeConstants.ELEMENT_NODE;
}

// Exports from this module
module.exports = {
  rep: wrapRender(ElementNode),
  supportsObject,
  MAX_ATTRIBUTE_LENGTH
};

/***/ }),
/* 478 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// ReactJS
const PropTypes = __webpack_require__(0);

// Reps
const { isGrip, cropString, wrapRender } = __webpack_require__(2);
const { MODE } = __webpack_require__(4);

const dom = __webpack_require__(1);
const { span } = dom;

/**
 * Renders DOM #text node.
 */
TextNode.propTypes = {
  object: PropTypes.object.isRequired,
  // @TODO Change this to Object.values when supported in Node's version of V8
  mode: PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key])),
  onDOMNodeMouseOver: PropTypes.func,
  onDOMNodeMouseOut: PropTypes.func,
  onInspectIconClick: PropTypes.func
};

function TextNode(props) {
  const {
    object: grip,
    mode = MODE.SHORT,
    onDOMNodeMouseOver,
    onDOMNodeMouseOut,
    onInspectIconClick
  } = props;

  const baseConfig = {
    "data-link-actor-id": grip.actor,
    className: "objectBox objectBox-textNode"
  };
  let inspectIcon;
  const isInTree = grip.preview && grip.preview.isConnected === true;

  if (isInTree) {
    if (onDOMNodeMouseOver) {
      Object.assign(baseConfig, {
        onMouseOver: _ => onDOMNodeMouseOver(grip)
      });
    }

    if (onDOMNodeMouseOut) {
      Object.assign(baseConfig, {
        onMouseOut: onDOMNodeMouseOut
      });
    }

    if (onInspectIconClick) {
      inspectIcon = dom.button({
        className: "open-inspector",
        draggable: false,
        // TODO: Localize this with "openNodeInInspector" when Bug 1317038 lands
        title: "Click to select the node in the inspector",
        onClick: e => onInspectIconClick(grip, e)
      });
    }
  }

  if (mode === MODE.TINY) {
    return span(baseConfig, getTitle(grip), inspectIcon);
  }

  return span(baseConfig, getTitle(grip), span({ className: "nodeValue" }, " ", `"${getTextContent(grip)}"`), inspectIcon);
}

function getTextContent(grip) {
  return cropString(grip.preview.textContent);
}

function getTitle(grip) {
  const title = "#text";
  return span({}, title);
}

// Registration
function supportsObject(grip, noGrip = false) {
  if (noGrip === true || !isGrip(grip)) {
    return false;
  }

  return grip.preview && grip.class == "Text";
}

// Exports from this module
module.exports = {
  rep: wrapRender(TextNode),
  supportsObject
};

/***/ }),
/* 479 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// ReactJS
const PropTypes = __webpack_require__(0);

// Reps
const {
  getGripType,
  isGrip,
  getURLDisplayString,
  wrapRender
} = __webpack_require__(2);

const { MODE } = __webpack_require__(4);

const dom = __webpack_require__(1);
const { span } = dom;

/**
 * Renders a grip representing a window.
 */
WindowRep.propTypes = {
  // @TODO Change this to Object.values when supported in Node's version of V8
  mode: PropTypes.oneOf(Object.keys(MODE).map(key => MODE[key])),
  object: PropTypes.object.isRequired
};

function WindowRep(props) {
  const { mode, object } = props;

  const config = {
    "data-link-actor-id": object.actor,
    className: "objectBox objectBox-Window"
  };

  if (mode === MODE.TINY) {
    return span(config, getTitle(object));
  }

  return span(config, getTitle(object, true), span({ className: "location" }, getLocation(object)));
}

function getTitle(object, trailingSpace) {
  let title = object.displayClass || object.class || "Window";
  if (trailingSpace === true) {
    title = `${title} `;
  }
  return span({ className: "objectTitle" }, title);
}

function getLocation(object) {
  return getURLDisplayString(object.preview.url);
}

// Registration
function supportsObject(object, noGrip = false) {
  if (noGrip === true || !isGrip(object)) {
    return false;
  }

  return object.preview && getGripType(object, noGrip) == "Window";
}

// Exports from this module
module.exports = {
  rep: wrapRender(WindowRep),
  supportsObject
};

/***/ }),
/* 480 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// ReactJS
const PropTypes = __webpack_require__(0);

// Reps
const { isGrip, wrapRender } = __webpack_require__(2);

const String = __webpack_require__(25).rep;

const dom = __webpack_require__(1);
const { span } = dom;

/**
 * Renders a grip object with textual data.
 */
ObjectWithText.propTypes = {
  object: PropTypes.object.isRequired
};

function ObjectWithText(props) {
  const grip = props.object;
  return span({
    "data-link-actor-id": grip.actor,
    className: `objectTitle objectBox objectBox-${getType(grip)}`
  }, `${getType(grip)} `, getDescription(grip));
}

function getType(grip) {
  return grip.class;
}

function getDescription(grip) {
  return String({
    object: grip.preview.text
  });
}

// Registration
function supportsObject(grip, noGrip = false) {
  if (noGrip === true || !isGrip(grip)) {
    return false;
  }

  return grip.preview && grip.preview.kind == "ObjectWithText";
}

// Exports from this module
module.exports = {
  rep: wrapRender(ObjectWithText),
  supportsObject
};

/***/ }),
/* 481 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// ReactJS
const PropTypes = __webpack_require__(0);

// Reps
const { isGrip, getURLDisplayString, wrapRender } = __webpack_require__(2);

const dom = __webpack_require__(1);
const { span } = dom;

/**
 * Renders a grip object with URL data.
 */
ObjectWithURL.propTypes = {
  object: PropTypes.object.isRequired
};

function ObjectWithURL(props) {
  const grip = props.object;
  return span({
    "data-link-actor-id": grip.actor,
    className: `objectBox objectBox-${getType(grip)}`
  }, getTitle(grip), span({ className: "objectPropValue" }, getDescription(grip)));
}

function getTitle(grip) {
  return span({ className: "objectTitle" }, `${getType(grip)} `);
}

function getType(grip) {
  return grip.class;
}

function getDescription(grip) {
  return getURLDisplayString(grip.preview.url);
}

// Registration
function supportsObject(grip, noGrip = false) {
  if (noGrip === true || !isGrip(grip)) {
    return false;
  }

  return grip.preview && grip.preview.kind == "ObjectWithURL";
}

// Exports from this module
module.exports = {
  rep: wrapRender(ObjectWithURL),
  supportsObject
};

/***/ }),
/* 482 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const ObjectInspector = __webpack_require__(483);
const utils = __webpack_require__(116);
const reducer = __webpack_require__(115);

module.exports = { ObjectInspector, utils, reducer };

/***/ }),
/* 483 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _devtoolsComponents = __webpack_require__(108);

var _devtoolsComponents2 = _interopRequireDefault(_devtoolsComponents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const { Component, createFactory, createElement } = __webpack_require__(6);
const { connect } = __webpack_require__(484);
const actions = __webpack_require__(485);

const selectors = __webpack_require__(115);

const Tree = createFactory(_devtoolsComponents2.default.Tree);
__webpack_require__(486);

const ObjectInspectorItem = createFactory(__webpack_require__(487));

const classnames = __webpack_require__(67);

const Utils = __webpack_require__(116);
const { renderRep, shouldRenderRootsInReps } = Utils;
const {
  getChildrenWithEvaluations,
  getActor,
  getParent,
  getValue,
  nodeIsPrimitive,
  nodeHasGetter,
  nodeHasSetter
} = Utils.node;

// This implements a component that renders an interactive inspector
// for looking at JavaScript objects. It expects descriptions of
// objects from the protocol, and will dynamically fetch children
// properties as objects are expanded.
//
// If you want to inspect a single object, pass the name and the
// protocol descriptor of it:
//
//  ObjectInspector({
//    name: "foo",
//    desc: { writable: true, ..., { value: { actor: "1", ... }}},
//    ...
//  })
//
// If you want multiple top-level objects (like scopes), you can pass
// an array of manually constructed nodes as `roots`:
//
//  ObjectInspector({
//    roots: [{ name: ... }, ...],
//    ...
//  });

// There are 3 types of nodes: a simple node with a children array, an
// object that has properties that should be children when they are
// fetched, and a primitive value that should be displayed with no
// children.

class ObjectInspector extends Component {
  constructor(props) {
    super();
    this.cachedNodes = new Map();

    const self = this;

    self.getItemChildren = this.getItemChildren.bind(this);
    self.isNodeExpandable = this.isNodeExpandable.bind(this);
    self.setExpanded = this.setExpanded.bind(this);
    self.focusItem = this.focusItem.bind(this);
    self.activateItem = this.activateItem.bind(this);
    self.getRoots = this.getRoots.bind(this);
    self.getNodeKey = this.getNodeKey.bind(this);
    self.shouldItemUpdate = this.shouldItemUpdate.bind(this);
  }

  componentWillMount() {
    this.roots = this.props.roots;
    this.focusedItem = this.props.focusedItem;
    this.activeItem = this.props.activeItem;
  }

  componentWillUpdate(nextProps) {
    this.removeOutdatedNodesFromCache(nextProps);

    if (this.roots !== nextProps.roots) {
      // Since the roots changed, we assume the properties did as well,
      // so we need to cleanup the component internal state.
      this.roots = nextProps.roots;
      this.focusedItem = nextProps.focusedItem;
      this.activeItem = nextProps.activeItem;
      if (this.props.rootsChanged) {
        this.props.rootsChanged();
      }
    }
  }

  removeOutdatedNodesFromCache(nextProps) {
    // When the roots changes, we can wipe out everything.
    if (this.roots !== nextProps.roots) {
      this.cachedNodes.clear();
      return;
    }

    // If there are new evaluations, we want to remove the existing cached
    // nodes from the cache.
    if (nextProps.evaluations > this.props.evaluations) {
      for (const key of nextProps.evaluations.keys()) {
        if (!this.props.evaluations.has(key)) {
          this.cachedNodes.delete(key);
        }
      }
    }
  }

  shouldComponentUpdate(nextProps) {
    const { expandedPaths, loadedProperties, evaluations } = this.props;

    // We should update if:
    // - there are new loaded properties
    // - OR there are new evaluations
    // - OR the expanded paths number changed, and all of them have properties
    //      loaded
    // - OR the expanded paths number did not changed, but old and new sets
    //      differ
    // - OR the focused node changed.
    // - OR the active node changed.
    return loadedProperties.size !== nextProps.loadedProperties.size || evaluations.size !== nextProps.evaluations.size || expandedPaths.size !== nextProps.expandedPaths.size && [...nextProps.expandedPaths].every(path => nextProps.loadedProperties.has(path)) || expandedPaths.size === nextProps.expandedPaths.size && [...nextProps.expandedPaths].some(key => !expandedPaths.has(key)) || this.focusedItem !== nextProps.focusedItem || this.activeItem !== nextProps.activeItem || this.roots !== nextProps.roots;
  }

  componentWillUnmount() {
    this.props.closeObjectInspector();
  }

  getItemChildren(item) {
    const { loadedProperties, evaluations } = this.props;
    const { cachedNodes } = this;

    return getChildrenWithEvaluations({
      evaluations,
      loadedProperties,
      cachedNodes,
      item
    });
  }

  getRoots() {
    return this.props.roots;
  }

  getNodeKey(item) {
    return item.path && typeof item.path.toString === "function" ? item.path.toString() : JSON.stringify(item);
  }

  isNodeExpandable(item) {
    if (nodeIsPrimitive(item)) {
      return false;
    }

    if (nodeHasSetter(item) || nodeHasGetter(item)) {
      return false;
    }

    return true;
  }

  setExpanded(item, expand) {
    if (!this.isNodeExpandable(item)) {
      return;
    }

    const {
      nodeExpand,
      nodeCollapse,
      recordTelemetryEvent,
      roots
    } = this.props;

    if (expand === true) {
      const actor = getActor(item, roots);
      nodeExpand(item, actor);
      if (recordTelemetryEvent) {
        recordTelemetryEvent("object_expanded");
      }
    } else {
      nodeCollapse(item);
    }
  }

  focusItem(item) {
    const { focusable = true, onFocus } = this.props;

    if (focusable && this.focusedItem !== item) {
      this.focusedItem = item;
      this.forceUpdate();

      if (onFocus) {
        onFocus(item);
      }
    }
  }

  activateItem(item) {
    const { focusable = true, onActivate } = this.props;

    if (focusable && this.activeItem !== item) {
      this.activeItem = item;
      this.forceUpdate();

      if (onActivate) {
        onActivate(item);
      }
    }
  }

  shouldItemUpdate(prevItem, nextItem) {
    const value = getValue(nextItem);
    // Long string should always update because fullText loading will not
    // trigger item re-render.
    return value && value.type === "longString";
  }

  render() {
    const {
      autoExpandAll = true,
      autoExpandDepth = 1,
      focusable = true,
      disableWrap = false,
      expandedPaths,
      inline
    } = this.props;

    return Tree({
      className: classnames({
        inline,
        nowrap: disableWrap,
        "object-inspector": true
      }),

      autoExpandAll,
      autoExpandDepth,

      isExpanded: item => expandedPaths && expandedPaths.has(item.path),
      isExpandable: this.isNodeExpandable,
      focused: this.focusedItem,
      active: this.activeItem,

      getRoots: this.getRoots,
      getParent,
      getChildren: this.getItemChildren,
      getKey: this.getNodeKey,

      onExpand: item => this.setExpanded(item, true),
      onCollapse: item => this.setExpanded(item, false),
      onFocus: focusable ? this.focusItem : null,
      onActivate: focusable ? this.activateItem : null,

      shouldItemUpdate: this.shouldItemUpdate,
      renderItem: (item, depth, focused, arrow, expanded) => ObjectInspectorItem({
        ...this.props,
        item,
        depth,
        focused,
        arrow,
        expanded,
        setExpanded: this.setExpanded
      })
    });
  }
}

function mapStateToProps(state, props) {
  return {
    expandedPaths: selectors.getExpandedPaths(state),
    loadedProperties: selectors.getLoadedProperties(state),
    evaluations: selectors.getEvaluations(state)
  };
}

const OI = connect(mapStateToProps, actions)(ObjectInspector);

module.exports = props => {
  const { roots } = props;
  if (shouldRenderRootsInReps(roots)) {
    return renderRep(roots[0], props);
  }

  return createElement(OI, props);
};

/***/ }),
/* 484 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_484__;

/***/ }),
/* 485 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { loadItemProperties } = __webpack_require__(196); /* This Source Code Form is subject to the terms of the Mozilla Public
                                                                    * License, v. 2.0. If a copy of the MPL was not distributed with this
                                                                    * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const { getLoadedProperties, getActors } = __webpack_require__(115);

/**
 * This action is responsible for expanding a given node, which also means that
 * it will call the action responsible to fetch properties.
 */
function nodeExpand(node, actor) {
  return async ({ dispatch, getState }) => {
    dispatch({ type: "NODE_EXPAND", data: { node } });
    dispatch(nodeLoadProperties(node, actor));
  };
}

function nodeCollapse(node) {
  return {
    type: "NODE_COLLAPSE",
    data: { node }
  };
}

/*
 * This action checks if we need to fetch properties, entries, prototype and
 * symbols for a given node. If we do, it will call the appropriate ObjectClient
 * functions.
 */
function nodeLoadProperties(node, actor) {
  return async ({ dispatch, client, getState }) => {
    const state = getState();
    const loadedProperties = getLoadedProperties(state);
    if (loadedProperties.has(node.path)) {
      return;
    }

    try {
      const properties = await loadItemProperties(node, client.createObjectClient, client.createLongStringClient, loadedProperties);

      dispatch(nodePropertiesLoaded(node, actor, properties));
    } catch (e) {
      console.error(e);
    }
  };
}

function nodePropertiesLoaded(node, actor, properties) {
  return {
    type: "NODE_PROPERTIES_LOADED",
    data: { node, actor, properties }
  };
}

function closeObjectInspector() {
  return async ({ getState, client }) => {
    releaseActors(getState(), client);
  };
}

/*
 * This action is dispatched when the `roots` prop, provided by a consumer of
 * the ObjectInspector (inspector, console, …), is modified. It will clean the
 * internal state properties (expandedPaths, loadedProperties, …) and release
 * the actors consumed with the previous roots.
 * It takes a props argument which reflects what is passed by the upper-level
 * consumer.
 */
function rootsChanged(props) {
  return async ({ dispatch, client, getState }) => {
    releaseActors(getState(), client);
    dispatch({
      type: "ROOTS_CHANGED",
      data: props
    });
  };
}

function releaseActors(state, client) {
  const actors = getActors(state);
  for (const actor of actors) {
    client.releaseActor(actor);
  }
}

function invokeGetter(node, targetGrip, receiverId, getterName) {
  return async ({ dispatch, client, getState }) => {
    try {
      const objectClient = client.createObjectClient(targetGrip);
      const result = await objectClient.getPropertyValue(getterName, receiverId);
      dispatch({
        type: "GETTER_INVOKED",
        data: {
          node,
          result
        }
      });
    } catch (e) {
      console.error(e);
    }
  };
}

module.exports = {
  closeObjectInspector,
  invokeGetter,
  nodeExpand,
  nodeCollapse,
  nodeLoadProperties,
  nodePropertiesLoaded,
  rootsChanged
};

/***/ }),
/* 486 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 487 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _devtoolsServices = __webpack_require__(37);

var _devtoolsServices2 = _interopRequireDefault(_devtoolsServices);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const { Component } = __webpack_require__(6);
const dom = __webpack_require__(1);

const { appinfo } = _devtoolsServices2.default;
const isMacOS = appinfo.OS === "Darwin";

const classnames = __webpack_require__(67);
const { MODE } = __webpack_require__(4);

const Utils = __webpack_require__(116);

const {
  getValue,
  nodeHasAccessors,
  nodeHasProperties,
  nodeIsBlock,
  nodeIsDefaultProperties,
  nodeIsFunction,
  nodeIsGetter,
  nodeIsMapEntry,
  nodeIsMissingArguments,
  nodeIsOptimizedOut,
  nodeIsPrimitive,
  nodeIsPrototype,
  nodeIsSetter,
  nodeIsUninitializedBinding,
  nodeIsUnmappedBinding,
  nodeIsUnscopedBinding,
  nodeIsWindow,
  nodeIsLongString,
  nodeHasFullText,
  nodeHasGetter,
  getNonPrototypeParentGripValue,
  getParentGripValue
} = Utils.node;

class ObjectInspectorItem extends Component {
  // eslint-disable-next-line complexity
  getLabelAndValue() {
    const { item, depth, expanded, mode } = this.props;

    const label = item.name;
    const isPrimitive = nodeIsPrimitive(item);

    if (nodeIsOptimizedOut(item)) {
      return {
        label,
        value: dom.span({ className: "unavailable" }, "(optimized away)")
      };
    }

    if (nodeIsUninitializedBinding(item)) {
      return {
        label,
        value: dom.span({ className: "unavailable" }, "(uninitialized)")
      };
    }

    if (nodeIsUnmappedBinding(item)) {
      return {
        label,
        value: dom.span({ className: "unavailable" }, "(unmapped)")
      };
    }

    if (nodeIsUnscopedBinding(item)) {
      return {
        label,
        value: dom.span({ className: "unavailable" }, "(unscoped)")
      };
    }

    const itemValue = getValue(item);
    const unavailable = isPrimitive && itemValue && itemValue.hasOwnProperty && itemValue.hasOwnProperty("unavailable");

    if (nodeIsMissingArguments(item) || unavailable) {
      return {
        label,
        value: dom.span({ className: "unavailable" }, "(unavailable)")
      };
    }

    if (nodeIsFunction(item) && !nodeIsGetter(item) && !nodeIsSetter(item) && (mode === MODE.TINY || !mode)) {
      return {
        label: Utils.renderRep(item, {
          ...this.props,
          functionName: label
        })
      };
    }

    if (nodeHasProperties(item) || nodeHasAccessors(item) || nodeIsMapEntry(item) || nodeIsLongString(item) || isPrimitive) {
      const repProps = { ...this.props };
      if (depth > 0) {
        repProps.mode = mode === MODE.LONG ? MODE.SHORT : MODE.TINY;
      }
      if (expanded) {
        repProps.mode = MODE.TINY;
      }

      if (nodeIsLongString(item)) {
        repProps.member = {
          open: nodeHasFullText(item) && expanded
        };
      }

      if (nodeHasGetter(item)) {
        const targetGrip = getParentGripValue(item);
        const receiverGrip = getNonPrototypeParentGripValue(item);
        if (targetGrip && receiverGrip) {
          Object.assign(repProps, {
            onInvokeGetterButtonClick: () => this.props.invokeGetter(item, targetGrip, receiverGrip.actor, item.name)
          });
        }
      }

      return {
        label,
        value: Utils.renderRep(item, repProps)
      };
    }

    return {
      label
    };
  }

  getTreeItemProps() {
    const {
      item,
      depth,
      focused,
      expanded,
      onCmdCtrlClick,
      onDoubleClick,
      dimTopLevelWindow
    } = this.props;

    const parentElementProps = {
      className: classnames("node object-node", {
        focused,
        lessen: !expanded && (nodeIsDefaultProperties(item) || nodeIsPrototype(item) || nodeIsGetter(item) || nodeIsSetter(item) || dimTopLevelWindow === true && nodeIsWindow(item) && depth === 0),
        block: nodeIsBlock(item)
      }),
      onClick: e => {
        if (onCmdCtrlClick && (isMacOS && e.metaKey || !isMacOS && e.ctrlKey)) {
          onCmdCtrlClick(item, {
            depth,
            event: e,
            focused,
            expanded
          });
          e.stopPropagation();
          return;
        }

        // If this click happened because the user selected some text, bail out.
        // Note that if the user selected some text before and then clicks here,
        // the previously selected text will be first unselected, unless the
        // user clicked on the arrow itself. Indeed because the arrow is an
        // image, clicking on it does not remove any existing text selection.
        // So we need to also check if the arrow was clicked.
        if (Utils.selection.documentHasSelection() && !(e.target && e.target.matches && e.target.matches(".arrow"))) {
          e.stopPropagation();
        }
      }
    };

    if (onDoubleClick) {
      parentElementProps.onDoubleClick = e => {
        e.stopPropagation();
        onDoubleClick(item, {
          depth,
          focused,
          expanded
        });
      };
    }

    return parentElementProps;
  }

  renderLabel(label) {
    if (label === null || typeof label === "undefined") {
      return null;
    }

    const { item, depth, focused, expanded, onLabelClick } = this.props;
    return dom.span({
      className: "object-label",
      onClick: onLabelClick ? event => {
        event.stopPropagation();

        // If the user selected text, bail out.
        if (Utils.selection.documentHasSelection()) {
          return;
        }

        onLabelClick(item, {
          depth,
          focused,
          expanded,
          setExpanded: this.props.setExpanded
        });
      } : undefined
    }, label);
  }

  render() {
    const { arrow } = this.props;

    const { label, value } = this.getLabelAndValue();
    const labelElement = this.renderLabel(label);
    const delimiter = value && labelElement ? dom.span({ className: "object-delimiter" }, ": ") : null;

    return dom.div(this.getTreeItemProps(), arrow, labelElement, delimiter, value);
  }
}

module.exports = ObjectInspectorItem;

/***/ }),
/* 488 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function documentHasSelection() {
  const selection = getSelection();
  if (!selection) {
    return false;
  }

  return selection.type === "Range";
}

module.exports = {
  documentHasSelection
};

/***/ }),
/* 489 */,
/* 490 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getVisibleSelectedFrame = exports.getSelectedFrames = exports.getSelectedFrame = exports.shouldPauseOnAnyXHR = exports.getXHRBreakpoints = exports.getBreakpointSources = exports.getCallStackFrames = exports.isSelectedFrameVisible = exports.inComponent = exports.getFirstVisibleBreakpoints = exports.getVisibleBreakpoints = exports.getBreakpointsAtLine = exports.getBreakpointAtLocation = exports.getQuickOpenType = exports.getQuickOpenQuery = exports.getQuickOpenEnabled = exports.getSourceActorsForThread = exports.getSourceActors = exports.hasSourceActor = exports.getSourceActor = undefined;

var _expressions = __webpack_require__(569);

Object.keys(_expressions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _expressions[key];
    }
  });
});

var _sources = __webpack_require__(498);

Object.keys(_sources).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _sources[key];
    }
  });
});

var _tabs = __webpack_require__(545);

Object.keys(_tabs).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _tabs[key];
    }
  });
});

var _eventListeners = __webpack_require__(575);

Object.keys(_eventListeners).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _eventListeners[key];
    }
  });
});

var _pause = __webpack_require__(530);

Object.keys(_pause).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _pause[key];
    }
  });
});

var _debuggee = __webpack_require__(577);

Object.keys(_debuggee).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _debuggee[key];
    }
  });
});

var _breakpoints = __webpack_require__(518);

Object.keys(_breakpoints).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _breakpoints[key];
    }
  });
});

var _pendingBreakpoints = __webpack_require__(580);

Object.keys(_pendingBreakpoints).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _pendingBreakpoints[key];
    }
  });
});

var _ui = __webpack_require__(581);

Object.keys(_ui).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _ui[key];
    }
  });
});

var _fileSearch = __webpack_require__(582);

Object.keys(_fileSearch).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _fileSearch[key];
    }
  });
});

var _ast = __webpack_require__(583);

Object.keys(_ast).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _ast[key];
    }
  });
});

var _projectTextSearch = __webpack_require__(532);

Object.keys(_projectTextSearch).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _projectTextSearch[key];
    }
  });
});

var _sourceTree = __webpack_require__(584);

Object.keys(_sourceTree).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _sourceTree[key];
    }
  });
});

var _sourceActors = __webpack_require__(529);

Object.defineProperty(exports, "getSourceActor", {
  enumerable: true,
  get: function () {
    return _sourceActors.getSourceActor;
  }
});
Object.defineProperty(exports, "hasSourceActor", {
  enumerable: true,
  get: function () {
    return _sourceActors.hasSourceActor;
  }
});
Object.defineProperty(exports, "getSourceActors", {
  enumerable: true,
  get: function () {
    return _sourceActors.getSourceActors;
  }
});
Object.defineProperty(exports, "getSourceActorsForThread", {
  enumerable: true,
  get: function () {
    return _sourceActors.getSourceActorsForThread;
  }
});

var _quickOpen = __webpack_require__(585);

Object.defineProperty(exports, "getQuickOpenEnabled", {
  enumerable: true,
  get: function () {
    return _quickOpen.getQuickOpenEnabled;
  }
});
Object.defineProperty(exports, "getQuickOpenQuery", {
  enumerable: true,
  get: function () {
    return _quickOpen.getQuickOpenQuery;
  }
});
Object.defineProperty(exports, "getQuickOpenType", {
  enumerable: true,
  get: function () {
    return _quickOpen.getQuickOpenType;
  }
});

var _breakpointAtLocation = __webpack_require__(642);

Object.defineProperty(exports, "getBreakpointAtLocation", {
  enumerable: true,
  get: function () {
    return _breakpointAtLocation.getBreakpointAtLocation;
  }
});
Object.defineProperty(exports, "getBreakpointsAtLine", {
  enumerable: true,
  get: function () {
    return _breakpointAtLocation.getBreakpointsAtLine;
  }
});

var _visibleBreakpoints = __webpack_require__(587);

Object.defineProperty(exports, "getVisibleBreakpoints", {
  enumerable: true,
  get: function () {
    return _visibleBreakpoints.getVisibleBreakpoints;
  }
});
Object.defineProperty(exports, "getFirstVisibleBreakpoints", {
  enumerable: true,
  get: function () {
    return _visibleBreakpoints.getFirstVisibleBreakpoints;
  }
});

var _inComponent = __webpack_require__(643);

Object.defineProperty(exports, "inComponent", {
  enumerable: true,
  get: function () {
    return _inComponent.inComponent;
  }
});

var _isSelectedFrameVisible = __webpack_require__(644);

Object.defineProperty(exports, "isSelectedFrameVisible", {
  enumerable: true,
  get: function () {
    return _isSelectedFrameVisible.isSelectedFrameVisible;
  }
});

var _getCallStackFrames = __webpack_require__(645);

Object.defineProperty(exports, "getCallStackFrames", {
  enumerable: true,
  get: function () {
    return _getCallStackFrames.getCallStackFrames;
  }
});

var _breakpointSources = __webpack_require__(649);

Object.defineProperty(exports, "getBreakpointSources", {
  enumerable: true,
  get: function () {
    return _breakpointSources.getBreakpointSources;
  }
});

var _breakpoints2 = __webpack_require__(579);

Object.defineProperty(exports, "getXHRBreakpoints", {
  enumerable: true,
  get: function () {
    return _breakpoints2.getXHRBreakpoints;
  }
});
Object.defineProperty(exports, "shouldPauseOnAnyXHR", {
  enumerable: true,
  get: function () {
    return _breakpoints2.shouldPauseOnAnyXHR;
  }
});

var _visibleColumnBreakpoints = __webpack_require__(650);

Object.keys(_visibleColumnBreakpoints).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _visibleColumnBreakpoints[key];
    }
  });
});

var _pause2 = __webpack_require__(576);

Object.defineProperty(exports, "getSelectedFrame", {
  enumerable: true,
  get: function () {
    return _pause2.getSelectedFrame;
  }
});
Object.defineProperty(exports, "getSelectedFrames", {
  enumerable: true,
  get: function () {
    return _pause2.getSelectedFrames;
  }
});
Object.defineProperty(exports, "getVisibleSelectedFrame", {
  enumerable: true,
  get: function () {
    return _pause2.getVisibleSelectedFrame;
  }
});

var _devtoolsReps = __webpack_require__(457);

const { reducer } = _devtoolsReps.objectInspector;

// eslint-disable-next-line import/named


Object.keys(reducer).forEach(function (key) {
  if (key === "default" || key === "__esModule") {
    return;
  }
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: reducer[key]
  });
});

/***/ }),
/* 491 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.connect = connect;

var _reactRedux = __webpack_require__(484);

var _react = __webpack_require__(6);

var React = _interopRequireWildcard(_react);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */
function connect(mapStateToProps, mapDispatchToProps) {
  // $FlowFixMe
  return (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps);
}

/***/ }),
/* 492 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["verifyPrefSchema"] = verifyPrefSchema;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_devtools_modules__ = __webpack_require__(183);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_devtools_modules___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_devtools_modules__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_devtools_environment__ = __webpack_require__(102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_devtools_environment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_devtools_environment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_devtools_services__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_devtools_services___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_devtools_services__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__asyncStoreHelper__ = __webpack_require__(615);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__asyncStoreHelper___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__asyncStoreHelper__);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// @flow






// Schema version to bump when the async store format has changed incompatibly
// and old stores should be cleared. This needs to match the prefs schema
// version in devtools/client/preferences/debugger.js.
const prefsSchemaVersion = "1.0.9";
const pref = __WEBPACK_IMPORTED_MODULE_2_devtools_services___default.a.pref;

if (Object(__WEBPACK_IMPORTED_MODULE_1_devtools_environment__["isDevelopment"])()) {
  pref("devtools.debugger.logging", false);
  pref("devtools.debugger.alphabetize-outline", false);
  pref("devtools.debugger.auto-pretty-print", false);
  pref("devtools.source-map.client-service.enabled", true);
  pref("devtools.chrome.enabled", false);
  pref("devtools.debugger.pause-on-exceptions", false);
  pref("devtools.debugger.pause-on-caught-exceptions", false);
  pref("devtools.debugger.ignore-caught-exceptions", true);
  pref("devtools.debugger.call-stack-visible", true);
  pref("devtools.debugger.scopes-visible", true);
  pref("devtools.debugger.component-visible", true);
  pref("devtools.debugger.workers-visible", true);
  pref("devtools.debugger.expressions-visible", true);
  pref("devtools.debugger.xhr-breakpoints-visible", true);
  pref("devtools.debugger.breakpoints-visible", true);
  pref("devtools.debugger.event-listeners-visible", true);
  pref("devtools.debugger.start-panel-collapsed", false);
  pref("devtools.debugger.end-panel-collapsed", false);
  pref("devtools.debugger.start-panel-size", 300);
  pref("devtools.debugger.end-panel-size", 300);
  pref("devtools.debugger.tabsBlackBoxed", "[]");
  pref("devtools.debugger.ui.editor-wrapping", false);
  pref("devtools.debugger.ui.framework-grouping-on", true);
  pref("devtools.debugger.pending-selected-location", "{}");
  pref("devtools.debugger.expressions", "[]");
  pref("devtools.debugger.file-search-case-sensitive", false);
  pref("devtools.debugger.file-search-whole-word", false);
  pref("devtools.debugger.file-search-regex-match", false);
  pref("devtools.debugger.project-directory-root", "");
  pref("devtools.debugger.map-scopes-enabled", false);
  pref("devtools.debugger.prefs-schema-version", prefsSchemaVersion);
  pref("devtools.debugger.skip-pausing", false);
  pref("devtools.debugger.features.workers", true);
  pref("devtools.debugger.features.async-stepping", true);
  pref("devtools.debugger.features.wasm", true);
  pref("devtools.debugger.features.shortcuts", true);
  pref("devtools.debugger.features.root", true);
  pref("devtools.debugger.features.map-scopes", true);
  pref("devtools.debugger.features.remove-command-bar-options", true);
  pref("devtools.debugger.features.code-folding", false);
  pref("devtools.debugger.features.outline", true);
  pref("devtools.debugger.features.column-breakpoints", true);
  pref("devtools.debugger.features.skip-pausing", true);
  pref("devtools.debugger.features.component-pane", false);
  pref("devtools.debugger.features.autocomplete-expressions", false);
  pref("devtools.debugger.features.map-expression-bindings", true);
  pref("devtools.debugger.features.map-await-expression", true);
  pref("devtools.debugger.features.xhr-breakpoints", true);
  pref("devtools.debugger.features.original-blackbox", true);
  pref("devtools.debugger.features.windowless-workers", true);
  pref("devtools.debugger.features.event-listeners-breakpoints", true);
  pref("devtools.debugger.features.log-points", true);
  pref("devtools.debugger.log-actions", true);
}

const prefs = new __WEBPACK_IMPORTED_MODULE_0_devtools_modules__["PrefsHelper"]("devtools", {
  logging: ["Bool", "debugger.logging"],
  editorWrapping: ["Bool", "debugger.ui.editor-wrapping"],
  alphabetizeOutline: ["Bool", "debugger.alphabetize-outline"],
  autoPrettyPrint: ["Bool", "debugger.auto-pretty-print"],
  clientSourceMapsEnabled: ["Bool", "source-map.client-service.enabled"],
  chromeAndExtenstionsEnabled: ["Bool", "chrome.enabled"],
  pauseOnExceptions: ["Bool", "debugger.pause-on-exceptions"],
  pauseOnCaughtExceptions: ["Bool", "debugger.pause-on-caught-exceptions"],
  ignoreCaughtExceptions: ["Bool", "debugger.ignore-caught-exceptions"],
  callStackVisible: ["Bool", "debugger.call-stack-visible"],
  scopesVisible: ["Bool", "debugger.scopes-visible"],
  componentVisible: ["Bool", "debugger.component-visible"],
  workersVisible: ["Bool", "debugger.workers-visible"],
  breakpointsVisible: ["Bool", "debugger.breakpoints-visible"],
  expressionsVisible: ["Bool", "debugger.expressions-visible"],
  xhrBreakpointsVisible: ["Bool", "debugger.xhr-breakpoints-visible"],
  eventListenersVisible: ["Bool", "debugger.event-listeners-visible"],
  startPanelCollapsed: ["Bool", "debugger.start-panel-collapsed"],
  endPanelCollapsed: ["Bool", "debugger.end-panel-collapsed"],
  startPanelSize: ["Int", "debugger.start-panel-size"],
  endPanelSize: ["Int", "debugger.end-panel-size"],
  frameworkGroupingOn: ["Bool", "debugger.ui.framework-grouping-on"],
  tabsBlackBoxed: ["Json", "debugger.tabsBlackBoxed", []],
  pendingSelectedLocation: ["Json", "debugger.pending-selected-location", {}],
  expressions: ["Json", "debugger.expressions", []],
  fileSearchCaseSensitive: ["Bool", "debugger.file-search-case-sensitive"],
  fileSearchWholeWord: ["Bool", "debugger.file-search-whole-word"],
  fileSearchRegexMatch: ["Bool", "debugger.file-search-regex-match"],
  debuggerPrefsSchemaVersion: ["Char", "debugger.prefs-schema-version"],
  projectDirectoryRoot: ["Char", "debugger.project-directory-root", ""],
  skipPausing: ["Bool", "debugger.skip-pausing"],
  mapScopes: ["Bool", "debugger.map-scopes-enabled"],
  logActions: ["Bool", "debugger.log-actions"]
});
/* harmony export (immutable) */ __webpack_exports__["prefs"] = prefs;


const features = new __WEBPACK_IMPORTED_MODULE_0_devtools_modules__["PrefsHelper"]("devtools.debugger.features", {
  asyncStepping: ["Bool", "async-stepping"],
  wasm: ["Bool", "wasm"],
  shortcuts: ["Bool", "shortcuts"],
  root: ["Bool", "root"],
  columnBreakpoints: ["Bool", "column-breakpoints"],
  mapScopes: ["Bool", "map-scopes"],
  removeCommandBarOptions: ["Bool", "remove-command-bar-options"],
  workers: ["Bool", "workers"],
  windowlessWorkers: ["Bool", "windowless-workers"],
  outline: ["Bool", "outline"],
  codeFolding: ["Bool", "code-folding"],
  skipPausing: ["Bool", "skip-pausing"],
  autocompleteExpression: ["Bool", "autocomplete-expressions"],
  mapExpressionBindings: ["Bool", "map-expression-bindings"],
  mapAwaitExpression: ["Bool", "map-await-expression"],
  componentPane: ["Bool", "component-pane"],
  xhrBreakpoints: ["Bool", "xhr-breakpoints"],
  originalBlackbox: ["Bool", "original-blackbox"],
  eventListenersBreakpoints: ["Bool", "event-listeners-breakpoints"],
  logPoints: ["Bool", "log-points"]
});
/* harmony export (immutable) */ __webpack_exports__["features"] = features;


const asyncStore = Object(__WEBPACK_IMPORTED_MODULE_3__asyncStoreHelper__["asyncStoreHelper"])("debugger", {
  pendingBreakpoints: ["pending-breakpoints", {}],
  tabs: ["tabs", []],
  xhrBreakpoints: ["xhr-breakpoints", []],
  eventListenerBreakpoints: ["event-listener-breakpoints", []]
});
/* harmony export (immutable) */ __webpack_exports__["asyncStore"] = asyncStore;


function verifyPrefSchema() {
  if (prefs.debuggerPrefsSchemaVersion !== prefsSchemaVersion) {
    // clear pending Breakpoints
    asyncStore.pendingBreakpoints = {};
    asyncStore.tabs = [];
    asyncStore.xhrBreakpoints = [];
    prefs.debuggerPrefsSchemaVersion = prefsSchemaVersion;
  }
}


/***/ }),
/* 493 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _breakpoints = __webpack_require__(504);

var breakpoints = _interopRequireWildcard(_breakpoints);

var _expressions = __webpack_require__(511);

var expressions = _interopRequireWildcard(_expressions);

var _eventListeners = __webpack_require__(674);

var eventListeners = _interopRequireWildcard(_eventListeners);

var _pause = __webpack_require__(548);

var pause = _interopRequireWildcard(_pause);

var _navigation = __webpack_require__(675);

var navigation = _interopRequireWildcard(_navigation);

var _ui = __webpack_require__(538);

var ui = _interopRequireWildcard(_ui);

var _fileSearch = __webpack_require__(598);

var fileSearch = _interopRequireWildcard(_fileSearch);

var _ast = __webpack_require__(597);

var ast = _interopRequireWildcard(_ast);

var _projectTextSearch = __webpack_require__(676);

var projectTextSearch = _interopRequireWildcard(_projectTextSearch);

var _quickOpen = __webpack_require__(677);

var quickOpen = _interopRequireWildcard(_quickOpen);

var _sourceTree = __webpack_require__(678);

var sourceTree = _interopRequireWildcard(_sourceTree);

var _sources = __webpack_require__(505);

var sources = _interopRequireWildcard(_sources);

var _sourceActors = __webpack_require__(552);

var sourcesActors = _interopRequireWildcard(_sourceActors);

var _tabs = __webpack_require__(547);

var tabs = _interopRequireWildcard(_tabs);

var _debuggee = __webpack_require__(599);

var debuggee = _interopRequireWildcard(_debuggee);

var _toolbox = __webpack_require__(679);

var toolbox = _interopRequireWildcard(_toolbox);

var _preview = __webpack_require__(680);

var preview = _interopRequireWildcard(_preview);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = {
  ...navigation,
  ...breakpoints,
  ...expressions,
  ...eventListeners,
  ...sources,
  ...sourcesActors,
  ...tabs,
  ...pause,
  ...ui,
  ...fileSearch,
  ...ast,
  ...projectTextSearch,
  ...quickOpen,
  ...sourceTree,
  ...debuggee,
  ...toolbox,
  ...preview
}; /* This Source Code Form is subject to the terms of the Mozilla Public
    * License, v. 2.0. If a copy of the MPL was not distributed with this
    * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/***/ }),
/* 494 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sourceTypes = exports.isMinified = undefined;

var _isMinified = __webpack_require__(621);

Object.defineProperty(exports, "isMinified", {
  enumerable: true,
  get: function () {
    return _isMinified.isMinified;
  }
});
exports.shouldBlackbox = shouldBlackbox;
exports.shouldPrettyPrint = shouldPrettyPrint;
exports.isJavaScript = isJavaScript;
exports.isPretty = isPretty;
exports.isPrettyURL = isPrettyURL;
exports.isThirdParty = isThirdParty;
exports.getPrettySourceURL = getPrettySourceURL;
exports.getRawSourceURL = getRawSourceURL;
exports.getFormattedSourceId = getFormattedSourceId;
exports.getFilename = getFilename;
exports.getTruncatedFileName = getTruncatedFileName;
exports.getDisplayPath = getDisplayPath;
exports.getFileURL = getFileURL;
exports.getSourcePath = getSourcePath;
exports.getSourceLineCount = getSourceLineCount;
exports.getMode = getMode;
exports.isInlineScript = isInlineScript;
exports.getTextAtPosition = getTextAtPosition;
exports.getSourceClassnames = getSourceClassnames;
exports.getRelativeUrl = getRelativeUrl;
exports.underRoot = underRoot;
exports.isOriginal = isOriginal;
exports.isGenerated = isGenerated;
exports.getSourceQueryString = getSourceQueryString;
exports.isUrlExtension = isUrlExtension;
exports.getPlainUrl = getPlainUrl;

var _devtoolsSourceMap = __webpack_require__(182);

var _devtoolsModules = __webpack_require__(183);

var _utils = __webpack_require__(524);

var _text = __webpack_require__(514);

var _url = __webpack_require__(515);

var _wasm = __webpack_require__(516);

var _editor = __webpack_require__(496);

var _sourcesTree = __webpack_require__(526);

var _prefs = __webpack_require__(492);

var _asyncValue = __webpack_require__(497);

const sourceTypes = exports.sourceTypes = {
  coffee: "coffeescript",
  js: "javascript",
  jsx: "react",
  ts: "typescript",
  vue: "vue"
};

/**
 * Trims the query part or reference identifier of a url string, if necessary.
 *
 * @memberof utils/source
 * @static
 */
function trimUrlQuery(url) {
  const length = url.length;
  const q1 = url.indexOf("?");
  const q2 = url.indexOf("&");
  const q3 = url.indexOf("#");
  const q = Math.min(q1 != -1 ? q1 : length, q2 != -1 ? q2 : length, q3 != -1 ? q3 : length);

  return url.slice(0, q);
}

function shouldBlackbox(source) {
  if (!source) {
    return false;
  }

  if (!source.url) {
    return false;
  }

  if ((0, _devtoolsSourceMap.isOriginalId)(source.id) && !_prefs.features.originalBlackbox) {
    return false;
  }

  return true;
}

function shouldPrettyPrint(source, content) {
  if (!source || isPretty(source) || !isJavaScript(source, content) || isOriginal(source) || _prefs.prefs.clientSourceMapsEnabled && source.sourceMapURL) {
    return false;
  }

  return true;
}

/**
 * Returns true if the specified url and/or content type are specific to
 * javascript files.
 *
 * @return boolean
 *         True if the source is likely javascript.
 *
 * @memberof utils/source
 * @static
 */
function isJavaScript(source, content) {
  const url = source.url;
  const contentType = content.type === "wasm" ? null : content.contentType;
  return url && /\.(jsm|js)?$/.test(trimUrlQuery(url)) || !!(contentType && contentType.includes("javascript"));
}

/**
 * @memberof utils/source
 * @static
 */
function isPretty(source) {
  const url = source.url;
  return isPrettyURL(url);
}

function isPrettyURL(url) {
  return url ? /formatted$/.test(url) : false;
}

function isThirdParty(source) {
  const url = source.url;
  if (!source || !url) {
    return false;
  }

  return !!url.match(/(node_modules|bower_components)/);
}

/**
 * @memberof utils/source
 * @static
 */
function getPrettySourceURL(url) {
  if (!url) {
    url = "";
  }
  return `${url}:formatted`;
}

/**
 * @memberof utils/source
 * @static
 */
function getRawSourceURL(url) {
  return url ? url.replace(/:formatted$/, "") : url;
}

function resolveFileURL(url, transformUrl = initialUrl => initialUrl, truncate = true) {
  url = getRawSourceURL(url || "");
  const name = transformUrl(url);
  if (!truncate) {
    return name;
  }
  return (0, _utils.endTruncateStr)(name, 50);
}

function getFormattedSourceId(id) {
  const sourceId = id.split("/")[1];
  return `SOURCE${sourceId}`;
}

/**
 * Gets a readable filename from a source URL for display purposes.
 * If the source does not have a URL, the source ID will be returned instead.
 *
 * @memberof utils/source
 * @static
 */
function getFilename(source) {
  const { url, id } = source;
  if (!getRawSourceURL(url)) {
    return getFormattedSourceId(id);
  }

  const { filename } = (0, _sourcesTree.getURL)(source);
  return getRawSourceURL(filename);
}

/**
 * Provides a middle-trunated filename
 *
 * @memberof utils/source
 * @static
 */
function getTruncatedFileName(source, querystring = "", length = 30) {
  return (0, _text.truncateMiddleText)(`${getFilename(source)}${querystring}`, length);
}

/* Gets path for files with same filename for editor tabs, breakpoints, etc.
 * Pass the source, and list of other sources
 *
 * @memberof utils/source
 * @static
 */

function getDisplayPath(mySource, sources) {
  const filename = getFilename(mySource);

  // Find sources that have the same filename, but different paths
  // as the original source
  const similarSources = sources.filter(source => getRawSourceURL(mySource.url) != getRawSourceURL(source.url) && filename == getFilename(source));

  if (similarSources.length == 0) {
    return undefined;
  }

  // get an array of source path directories e.g. ['a/b/c.html'] => [['b', 'a']]
  const paths = [mySource, ...similarSources].map(source => (0, _sourcesTree.getURL)(source).path.split("/").reverse().slice(1));

  // create an array of similar path directories and one dis-similar directory
  // for example [`a/b/c.html`, `a1/b/c.html`] => ['b', 'a']
  // where 'b' is the similar directory and 'a' is the dis-similar directory.
  let similar = true;
  const displayPath = [];
  for (let i = 0; similar && i < paths[0].length; i++) {
    const [dir, ...dirs] = paths.map(path => path[i]);
    displayPath.push(dir);
    similar = dirs.includes(dir);
  }

  return displayPath.reverse().join("/");
}

/**
 * Gets a readable source URL for display purposes.
 * If the source does not have a URL, the source ID will be returned instead.
 *
 * @memberof utils/source
 * @static
 */
function getFileURL(source, truncate = true) {
  const { url, id } = source;
  if (!url) {
    return getFormattedSourceId(id);
  }

  return resolveFileURL(url, _devtoolsModules.getUnicodeUrl, truncate);
}

const contentTypeModeMap = {
  "text/javascript": { name: "javascript" },
  "text/typescript": { name: "javascript", typescript: true },
  "text/coffeescript": { name: "coffeescript" },
  "text/typescript-jsx": {
    name: "jsx",
    base: { name: "javascript", typescript: true }
  },
  "text/jsx": { name: "jsx" },
  "text/x-elm": { name: "elm" },
  "text/x-clojure": { name: "clojure" },
  "text/x-clojurescript": { name: "clojure" },
  "text/wasm": { name: "text" },
  "text/html": { name: "htmlmixed" }
};

function getSourcePath(url) {
  if (!url) {
    return "";
  }

  const { path, href } = (0, _url.parse)(url);
  // for URLs like "about:home" the path is null so we pass the full href
  return path || href;
}

/**
 * Returns amount of lines in the source. If source is a WebAssembly binary,
 * the function returns amount of bytes.
 */
function getSourceLineCount(content) {
  if (content.type === "wasm") {
    const { binary } = content.value;
    return binary.length;
  }

  return content.value.split("\n").length;
}

/**
 *
 * Checks if a source is minified based on some heuristics
 * @param key
 * @param text
 * @return boolean
 * @memberof utils/source
 * @static
 */

/**
 *
 * Returns Code Mirror mode for source content type
 * @param contentType
 * @return String
 * @memberof utils/source
 * @static
 */
// eslint-disable-next-line complexity
function getMode(source, content, symbols) {
  const { url } = source;

  if (content.type !== "text") {
    return { name: "text" };
  }

  const { contentType, value: text } = content;

  if (url && url.match(/\.jsx$/i) || symbols && symbols.hasJsx) {
    if (symbols && symbols.hasTypes) {
      return { name: "text/typescript-jsx" };
    }
    return { name: "jsx" };
  }

  if (symbols && symbols.hasTypes) {
    if (symbols.hasJsx) {
      return { name: "text/typescript-jsx" };
    }

    return { name: "text/typescript" };
  }

  const languageMimeMap = [{ ext: ".c", mode: "text/x-csrc" }, { ext: ".kt", mode: "text/x-kotlin" }, { ext: ".cpp", mode: "text/x-c++src" }, { ext: ".m", mode: "text/x-objectivec" }, { ext: ".rs", mode: "text/x-rustsrc" }, { ext: ".hx", mode: "text/x-haxe" }];

  // check for C and other non JS languages
  if (url) {
    const result = languageMimeMap.find(({ ext }) => url.endsWith(ext));

    if (result !== undefined) {
      return { name: result.mode };
    }
  }

  // if the url ends with .marko we set the name to Javascript so
  // syntax highlighting works for marko too
  if (url && url.match(/\.marko$/i)) {
    return { name: "javascript" };
  }

  // Use HTML mode for files in which the first non whitespace
  // character is `<` regardless of extension.
  const isHTMLLike = text.match(/^\s*</);
  if (!contentType) {
    if (isHTMLLike) {
      return { name: "htmlmixed" };
    }
    return { name: "text" };
  }

  // //  or /*  */
  if (text.match(/^\s*(\/\/ @flow|\/\* @flow \*\/)/)) {
    return contentTypeModeMap["text/typescript"];
  }

  if (/script|elm|jsx|clojure|wasm|html/.test(contentType)) {
    if (contentType in contentTypeModeMap) {
      return contentTypeModeMap[contentType];
    }

    return contentTypeModeMap["text/javascript"];
  }

  if (isHTMLLike) {
    return { name: "htmlmixed" };
  }

  return { name: "text" };
}

function isInlineScript(source) {
  return source.introductionType === "scriptElement";
}

function getTextAtPosition(sourceId, asyncContent, location) {
  if (!asyncContent || !(0, _asyncValue.isFulfilled)(asyncContent)) {
    return "";
  }

  const content = asyncContent.value;
  const line = location.line;
  const column = location.column || 0;

  if (content.type === "wasm") {
    const { line: editorLine } = (0, _editor.toEditorPosition)(location);
    const lines = (0, _wasm.renderWasmText)(sourceId, content);
    return lines[editorLine];
  }

  const lineText = content.value.split("\n")[line - 1];
  if (!lineText) {
    return "";
  }

  return lineText.slice(column, column + 100).trim();
}

function getSourceClassnames(source, symbols) {
  // Conditionals should be ordered by priority of icon!
  const defaultClassName = "file";

  if (!source || !source.url) {
    return defaultClassName;
  }

  if (isPretty(source)) {
    return "prettyPrint";
  }

  if (source.isBlackBoxed) {
    return "blackBox";
  }

  if (symbols && !symbols.loading && symbols.framework) {
    return symbols.framework.toLowerCase();
  }

  return sourceTypes[(0, _sourcesTree.getFileExtension)(source)] || defaultClassName;
}

function getRelativeUrl(source, root) {
  const { group, path } = (0, _sourcesTree.getURL)(source);
  if (!root) {
    return path;
  }

  // + 1 removes the leading "/"
  const url = group + path;
  return url.slice(url.indexOf(root) + root.length + 1);
}

function underRoot(source, root) {
  return source.url && source.url.includes(root);
}

function isOriginal(source) {
  // Pretty-printed sources are given original IDs, so no need
  // for any additional check
  return (0, _devtoolsSourceMap.isOriginalId)(source.id);
}

function isGenerated(source) {
  return (0, _devtoolsSourceMap.isGeneratedId)(source.id);
}

function getSourceQueryString(source) {
  if (!source) {
    return;
  }

  return (0, _url.parse)(getRawSourceURL(source.url)).search;
}

function isUrlExtension(url) {
  return (/\/?(chrome|moz)-extension:\//.test(url)
  );
}

function getPlainUrl(url) {
  const queryStart = url.indexOf("?");
  return queryStart !== -1 ? url.slice(0, queryStart) : url;
}

/***/ }),
/* 495 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(67);

var _classnames2 = _interopRequireDefault(_classnames);

__webpack_require__(697);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const AccessibleImage = props => {
  props = {
    ...props,
    className: (0, _classnames2.default)("img", props.className)
  };
  return _react2.default.createElement("span", props);
}; /* This Source Code Form is subject to the terms of the Mozilla Public
    * License, v. 2.0. If a copy of the MPL was not distributed with this
    * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

exports.default = AccessibleImage;

/***/ }),
/* 496 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.onMouseOver = undefined;

var _sourceDocuments = __webpack_require__(540);

Object.keys(_sourceDocuments).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _sourceDocuments[key];
    }
  });
});

var _getTokenLocation = __webpack_require__(624);

Object.keys(_getTokenLocation).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _getTokenLocation[key];
    }
  });
});

var _sourceSearch = __webpack_require__(625);

Object.keys(_sourceSearch).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _sourceSearch[key];
    }
  });
});

var _ui = __webpack_require__(525);

Object.keys(_ui).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _ui[key];
    }
  });
});

var _tokenEvents = __webpack_require__(626);

Object.defineProperty(exports, "onMouseOver", {
  enumerable: true,
  get: function () {
    return _tokenEvents.onMouseOver;
  }
});
exports.getEditor = getEditor;
exports.removeEditor = removeEditor;
exports.startOperation = startOperation;
exports.endOperation = endOperation;
exports.shouldShowPrettyPrint = shouldShowPrettyPrint;
exports.traverseResults = traverseResults;
exports.toEditorLine = toEditorLine;
exports.fromEditorLine = fromEditorLine;
exports.toEditorPosition = toEditorPosition;
exports.toEditorRange = toEditorRange;
exports.toSourceLine = toSourceLine;
exports.scrollToColumn = scrollToColumn;
exports.getLocationsInViewport = getLocationsInViewport;
exports.markText = markText;
exports.lineAtHeight = lineAtHeight;
exports.getSourceLocationFromMouseEvent = getSourceLocationFromMouseEvent;
exports.forEachLine = forEachLine;
exports.removeLineClass = removeLineClass;
exports.clearLineClass = clearLineClass;
exports.getTextForLine = getTextForLine;
exports.getCursorLine = getCursorLine;
exports.getTokenEnd = getTokenEnd;

var _createEditor = __webpack_require__(561);

var _source = __webpack_require__(494);

var _wasm = __webpack_require__(516);

let editor;

function getEditor() {
  if (editor) {
    return editor;
  }

  editor = (0, _createEditor.createEditor)();
  return editor;
}

function removeEditor() {
  editor = null;
}

function getCodeMirror() {
  return editor && editor.hasCodeMirror ? editor.codeMirror : null;
}

function startOperation() {
  const codeMirror = getCodeMirror();
  if (!codeMirror) {
    return;
  }

  codeMirror.startOperation();
}

function endOperation() {
  const codeMirror = getCodeMirror();
  if (!codeMirror) {
    return;
  }

  codeMirror.endOperation();
}

function shouldShowPrettyPrint(source, content) {
  return (0, _source.shouldPrettyPrint)(source, content);
}

function traverseResults(e, ctx, query, dir, modifiers) {
  e.stopPropagation();
  e.preventDefault();

  if (dir == "prev") {
    (0, _sourceSearch.findPrev)(ctx, query, true, modifiers);
  } else if (dir == "next") {
    (0, _sourceSearch.findNext)(ctx, query, true, modifiers);
  }
}

function toEditorLine(sourceId, lineOrOffset) {
  if ((0, _wasm.isWasm)(sourceId)) {
    // TODO ensure offset is always "mappable" to edit line.
    return (0, _wasm.wasmOffsetToLine)(sourceId, lineOrOffset) || 0;
  }

  return lineOrOffset ? lineOrOffset - 1 : 1;
}

function fromEditorLine(sourceId, line) {
  if ((0, _wasm.isWasm)(sourceId)) {
    return (0, _wasm.lineToWasmOffset)(sourceId, line) || 0;
  }

  return line + 1;
}

function toEditorPosition(location) {
  return {
    line: toEditorLine(location.sourceId, location.line),
    column: (0, _wasm.isWasm)(location.sourceId) || !location.column ? 0 : location.column
  };
}

function toEditorRange(sourceId, location) {
  const { start, end } = location;
  return {
    start: toEditorPosition({ ...start, sourceId }),
    end: toEditorPosition({ ...end, sourceId })
  };
}

function toSourceLine(sourceId, line) {
  return (0, _wasm.isWasm)(sourceId) ? (0, _wasm.lineToWasmOffset)(sourceId, line) : line + 1;
}

function scrollToColumn(codeMirror, line, column) {
  const { top, left } = codeMirror.charCoords({ line: line, ch: column }, "local");

  if (!isVisible(codeMirror, top, left)) {
    const scroller = codeMirror.getScrollerElement();
    const centeredX = Math.max(left - scroller.offsetWidth / 2, 0);
    const centeredY = Math.max(top - scroller.offsetHeight / 2, 0);

    codeMirror.scrollTo(centeredX, centeredY);
  }
}

function isVisible(codeMirror, top, left) {
  function withinBounds(x, min, max) {
    return x >= min && x <= max;
  }

  const scrollArea = codeMirror.getScrollInfo();
  const charWidth = codeMirror.defaultCharWidth();
  const fontHeight = codeMirror.defaultTextHeight();
  const { scrollTop, scrollLeft } = codeMirror.doc;

  const inXView = withinBounds(left, scrollLeft, scrollLeft + (scrollArea.clientWidth - 30) - charWidth);

  const inYView = withinBounds(top, scrollTop, scrollTop + scrollArea.clientHeight - fontHeight);

  return inXView && inYView;
}

function getLocationsInViewport({ codeMirror }) {
  // Get scroll position
  if (!codeMirror) {
    return {
      start: { line: 0, column: 0 },
      end: { line: 0, column: 0 }
    };
  }
  const charWidth = codeMirror.defaultCharWidth();
  const scrollArea = codeMirror.getScrollInfo();
  const { scrollLeft } = codeMirror.doc;
  const rect = codeMirror.getWrapperElement().getBoundingClientRect();
  const topVisibleLine = codeMirror.lineAtHeight(rect.top, "window");
  const bottomVisibleLine = codeMirror.lineAtHeight(rect.bottom, "window");

  const leftColumn = Math.floor(scrollLeft > 0 ? scrollLeft / charWidth : 0);
  const rightPosition = scrollLeft + (scrollArea.clientWidth - 30);
  const rightCharacter = Math.floor(rightPosition / charWidth);

  return {
    start: {
      line: topVisibleLine,
      column: leftColumn
    },
    end: {
      line: bottomVisibleLine,
      column: rightCharacter
    }
  };
}

function markText({ codeMirror }, className, { start, end }) {
  return codeMirror.markText({ ch: start.column, line: start.line }, { ch: end.column, line: end.line }, { className });
}

function lineAtHeight({ codeMirror }, sourceId, event) {
  const _editorLine = codeMirror.lineAtHeight(event.clientY);
  return toSourceLine(sourceId, _editorLine);
}

function getSourceLocationFromMouseEvent({ codeMirror }, source, e) {
  const { line, ch } = codeMirror.coordsChar({
    left: e.clientX,
    top: e.clientY
  });

  return {
    sourceId: source.id,
    line: line + 1,
    column: ch + 1
  };
}

function forEachLine(codeMirror, iter) {
  codeMirror.operation(() => {
    codeMirror.doc.iter(0, codeMirror.lineCount(), iter);
  });
}

function removeLineClass(codeMirror, line, className) {
  codeMirror.removeLineClass(line, "line", className);
}

function clearLineClass(codeMirror, className) {
  forEachLine(codeMirror, line => {
    removeLineClass(codeMirror, line, className);
  });
}

function getTextForLine(codeMirror, line) {
  return codeMirror.getLine(line - 1).trim();
}

function getCursorLine(codeMirror) {
  return codeMirror.getCursor().line;
}

function getTokenEnd(codeMirror, line, column) {
  const token = codeMirror.getTokenAt({
    line: line,
    ch: column + 1
  });

  return token.end;
}

/***/ }),
/* 497 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pending = pending;
exports.fulfilled = fulfilled;
exports.rejected = rejected;
exports.isPending = isPending;
exports.isFulfilled = isFulfilled;
exports.isRejected = isRejected;
function pending() {
  return { state: "pending" };
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function fulfilled(value) {
  return { state: "fulfilled", value };
}
function rejected(value) {
  return { state: "rejected", value };
}

function isPending(value) {
  return value.state === "pending";
}
function isFulfilled(value) {
  return value.state === "fulfilled";
}
function isRejected(value) {
  return value.state === "rejected";
}

/***/ }),
/* 498 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSelectedBreakableLines = exports.getDisplayedSources = exports.getSelectedSourceWithContent = exports.getSelectedSource = exports.getSelectedLocation = undefined;
exports.initialSourcesState = initialSourcesState;
exports.getBlackBoxList = getBlackBoxList;
exports.getSourceThreads = getSourceThreads;
exports.getSourceInSources = getSourceInSources;
exports.getSource = getSource;
exports.getSourceFromId = getSourceFromId;
exports.getSourceByActorId = getSourceByActorId;
exports.getSourcesByURLInSources = getSourcesByURLInSources;
exports.getSourcesByURL = getSourcesByURL;
exports.getSourceByURL = getSourceByURL;
exports.getSpecificSourceByURLInSources = getSpecificSourceByURLInSources;
exports.getSpecificSourceByURL = getSpecificSourceByURL;
exports.getOriginalSourceByURL = getOriginalSourceByURL;
exports.getGeneratedSourceByURL = getGeneratedSourceByURL;
exports.getGeneratedSource = getGeneratedSource;
exports.getGeneratedSourceById = getGeneratedSourceById;
exports.getPendingSelectedLocation = getPendingSelectedLocation;
exports.getPrettySource = getPrettySource;
exports.hasPrettySource = hasPrettySource;
exports.getSourcesUrlsInSources = getSourcesUrlsInSources;
exports.getHasSiblingOfSameName = getHasSiblingOfSameName;
exports.getSources = getSources;
exports.getSourcesEpoch = getSourcesEpoch;
exports.getUrls = getUrls;
exports.getPlainUrls = getPlainUrls;
exports.getSourceList = getSourceList;
exports.getDisplayedSourcesList = getDisplayedSourcesList;
exports.getSourceCount = getSourceCount;
exports.getSourceWithContent = getSourceWithContent;
exports.getSourceContent = getSourceContent;
exports.getSelectedSourceId = getSelectedSourceId;
exports.getProjectDirectoryRoot = getProjectDirectoryRoot;
exports.getSourceActorsForSource = getSourceActorsForSource;
exports.getBreakpointPositions = getBreakpointPositions;
exports.getBreakpointPositionsForSource = getBreakpointPositionsForSource;
exports.hasBreakpointPositions = hasBreakpointPositions;
exports.hasBreakpointPositionsForLine = hasBreakpointPositionsForLine;
exports.getBreakpointPositionsForLocation = getBreakpointPositionsForLocation;
exports.getBreakableLines = getBreakableLines;
exports.isSourceLoadingOrLoaded = isSourceLoadingOrLoaded;

var _reselect = __webpack_require__(444);

var _source = __webpack_require__(494);

var _resource = __webpack_require__(570);

var _breakpointPositions = __webpack_require__(574);

var _asyncValue = __webpack_require__(497);

var asyncValue = _interopRequireWildcard(_asyncValue);

var _devtoolsSourceMap = __webpack_require__(182);

var _prefs = __webpack_require__(492);

var _sourceActors = __webpack_require__(529);

var _lodash = __webpack_require__(417);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function initialSourcesState() {
  return {
    sources: (0, _resource.createInitial)(),
    urls: {},
    plainUrls: {},
    content: {},
    actors: {},
    breakpointPositions: {},
    breakableLines: {},
    epoch: 1,
    selectedLocation: undefined,
    pendingSelectedLocation: _prefs.prefs.pendingSelectedLocation,
    projectDirectoryRoot: _prefs.prefs.projectDirectoryRoot,
    chromeAndExtenstionsEnabled: _prefs.prefs.chromeAndExtenstionsEnabled,
    focusedItem: null
  };
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/**
 * Sources reducer
 * @module reducers/sources
 */

function update(state = initialSourcesState(), action) {
  let location = null;

  switch (action.type) {
    case "CLEAR_SOURCE_MAP_URL":
      return clearSourceMaps(state, action.sourceId);
    case "ADD_SOURCE":
      return addSources(state, [action.source]);

    case "ADD_SOURCES":
      return addSources(state, action.sources);

    case "INSERT_SOURCE_ACTORS":
      return insertSourceActors(state, action);

    case "REMOVE_SOURCE_ACTORS":
      return removeSourceActors(state, action);

    case "SET_SELECTED_LOCATION":
      location = {
        ...action.location,
        url: action.source.url
      };

      if (action.source.url) {
        _prefs.prefs.pendingSelectedLocation = location;
      }

      return {
        ...state,
        selectedLocation: {
          sourceId: action.source.id,
          ...action.location
        },
        pendingSelectedLocation: location
      };

    case "CLEAR_SELECTED_LOCATION":
      location = { url: "" };
      _prefs.prefs.pendingSelectedLocation = location;

      return {
        ...state,
        selectedLocation: null,
        pendingSelectedLocation: location
      };

    case "SET_PENDING_SELECTED_LOCATION":
      location = {
        url: action.url,
        line: action.line
      };

      _prefs.prefs.pendingSelectedLocation = location;
      return { ...state, pendingSelectedLocation: location };

    case "LOAD_SOURCE_TEXT":
      return updateLoadedState(state, action);

    case "BLACKBOX":
      if (action.status === "done") {
        const { id, url } = action.source;
        const { isBlackBoxed } = action.value;
        updateBlackBoxList(url, isBlackBoxed);
        return updateBlackboxFlag(state, id, isBlackBoxed);
      }
      break;

    case "SET_PROJECT_DIRECTORY_ROOT":
      return updateProjectDirectoryRoot(state, action.url);

    case "SET_BREAKABLE_LINES":
      {
        const { breakableLines, sourceId } = action;
        return {
          ...state,
          breakableLines: {
            ...state.breakableLines,
            [sourceId]: breakableLines
          }
        };
      }

    case "ADD_BREAKPOINT_POSITIONS":
      {
        const { source, positions } = action;
        const breakpointPositions = state.breakpointPositions[source.id];

        return {
          ...state,
          breakpointPositions: {
            ...state.breakpointPositions,
            [source.id]: { ...breakpointPositions, ...positions }
          }
        };
      }
    case "NAVIGATE":
      return {
        ...initialSourcesState(),
        epoch: state.epoch + 1
      };

    case "SET_FOCUSED_SOURCE_ITEM":
      return { ...state, focusedItem: action.item };
  }

  return state;
}

function resourceAsSource(r) {
  return r;
}

/*
 * Add sources to the sources store
 * - Add the source to the sources store
 * - Add the source URL to the urls map
 */
function addSources(state, sources) {
  state = {
    ...state,
    content: { ...state.content },
    urls: { ...state.urls },
    plainUrls: { ...state.plainUrls }
  };

  state.sources = (0, _resource.insertResources)(state.sources, sources);

  for (const source of sources) {
    // 1. Add the source to the sources map
    state.content[source.id] = null;

    // 2. Update the source url map
    const existing = state.urls[source.url] || [];
    if (!existing.includes(source.id)) {
      state.urls[source.url] = [...existing, source.id];
    }

    // 3. Update the plain url map
    if (source.url) {
      const plainUrl = (0, _source.getPlainUrl)(source.url);
      const existingPlainUrls = state.plainUrls[plainUrl] || [];
      if (!existingPlainUrls.includes(source.url)) {
        state.plainUrls[plainUrl] = [...existingPlainUrls, source.url];
      }
    }
  }

  state = updateRootRelativeValues(state, sources);

  return state;
}

function insertSourceActors(state, action) {
  const { items } = action;
  state = {
    ...state,
    actors: { ...state.actors }
  };

  for (const sourceActor of items) {
    state.actors[sourceActor.source] = [...(state.actors[sourceActor.source] || []), sourceActor.id];
  }

  const scriptActors = items.filter(item => item.introductionType === "scriptElement");
  if (scriptActors.length > 0) {
    const { ...breakpointPositions } = state.breakpointPositions;

    // If new HTML sources are being added, we need to clear the breakpoint
    // positions since the new source is a <script> with new breakpoints.
    for (const { source } of scriptActors) {
      delete breakpointPositions[source];
    }

    state = { ...state, breakpointPositions };
  }

  return state;
}

/*
 * Update sources when the worker list changes.
 * - filter source actor lists so that missing threads no longer appear
 * - NOTE: we do not remove sources for destroyed threads
 */
function removeSourceActors(state, action) {
  const { items } = action;

  const actors = new Set(items.map(item => item.id));
  const sources = new Set(items.map(item => item.source));

  state = {
    ...state,
    actors: { ...state.actors }
  };

  for (const source of sources) {
    state.actors[source] = state.actors[source].filter(id => !actors.has(id));
  }

  return state;
}

/*
 * Update sources when the project directory root changes
 */
function updateProjectDirectoryRoot(state, root) {
  _prefs.prefs.projectDirectoryRoot = root;

  return updateRootRelativeValues({
    ...state,
    projectDirectoryRoot: root
  });
}

function updateRootRelativeValues(state, sources) {
  const ids = sources ? sources.map(source => source.id) : (0, _resource.getResourceIds)(state.sources);

  state = {
    ...state
  };

  const relativeURLUpdates = [];
  for (const id of ids) {
    const source = (0, _resource.getResource)(state.sources, id);

    relativeURLUpdates.push({
      id,
      relativeUrl: (0, _source.getRelativeUrl)(source, state.projectDirectoryRoot)
    });
  }

  state.sources = (0, _resource.updateResources)(state.sources, relativeURLUpdates);

  return state;
}

/*
 * Update a source's loaded text content.
 */
function updateLoadedState(state, action) {
  const { sourceId } = action;

  // If there was a navigation between the time the action was started and
  // completed, we don't want to update the store.
  if (action.epoch !== state.epoch || !(sourceId in state.content)) {
    return state;
  }

  let content;
  if (action.status === "start") {
    content = asyncValue.pending();
  } else if (action.status === "error") {
    content = asyncValue.rejected(action.error);
  } else if (typeof action.value.text === "string") {
    content = asyncValue.fulfilled({
      type: "text",
      value: action.value.text,
      contentType: action.value.contentType
    });
  } else {
    content = asyncValue.fulfilled({
      type: "wasm",
      value: action.value.text
    });
  }

  return {
    ...state,
    content: {
      ...state.content,
      [sourceId]: content
    }
  };
}

function clearSourceMaps(state, sourceId) {
  if (!(0, _resource.hasResource)(state.sources, sourceId)) {
    return state;
  }

  return {
    ...state,
    sources: (0, _resource.updateResources)(state.sources, [{
      id: sourceId,
      sourceMapURL: ""
    }])
  };
}

/*
 * Update a source when its state changes
 * e.g. the text was loaded, it was blackboxed
 */
function updateBlackboxFlag(state, sourceId, isBlackBoxed) {
  // If there is no existing version of the source, it means that we probably
  // ended up here as a result of an async action, and the sources were cleared
  // between the action starting and the source being updated.
  if (!(0, _resource.hasResource)(state.sources, sourceId)) {
    // TODO: We may want to consider throwing here once we have a better
    // handle on async action flow control.
    return state;
  }

  return {
    ...state,
    sources: (0, _resource.updateResources)(state.sources, [{
      id: sourceId,
      isBlackBoxed
    }])
  };
}

function updateBlackBoxList(url, isBlackBoxed) {
  const tabs = getBlackBoxList();
  const i = tabs.indexOf(url);
  if (i >= 0) {
    if (!isBlackBoxed) {
      tabs.splice(i, 1);
    }
  } else if (isBlackBoxed) {
    tabs.push(url);
  }
  _prefs.prefs.tabsBlackBoxed = tabs;
}

function getBlackBoxList() {
  return _prefs.prefs.tabsBlackBoxed || [];
}

// Selectors

// Unfortunately, it's really hard to make these functions accept just
// the state that we care about and still type it with Flow. The
// problem is that we want to re-export all selectors from a single
// module for the UI, and all of those selectors should take the
// top-level app state, so we'd have to "wrap" them to automatically
// pick off the piece of state we're interested in. It's impossible
// (right now) to type those wrapped functions.


const getSourcesState = state => state.sources;

function getSourceThreads(state, source) {
  return (0, _lodash.uniq)((0, _sourceActors.getSourceActors)(state, state.sources.actors[source.id]).map(actor => actor.thread));
}

function getSourceInSources(sources, id) {
  return (0, _resource.hasResource)(sources, id) ? (0, _resource.getResource)(sources, id) : null;
}

function getSource(state, id) {
  return getSourceInSources(getSources(state), id);
}

function getSourceFromId(state, id) {
  const source = getSource(state, id);
  if (!source) {
    throw new Error(`source ${id} does not exist`);
  }
  return source;
}

function getSourceByActorId(state, actorId) {
  if (!(0, _sourceActors.hasSourceActor)(state, actorId)) {
    return null;
  }

  return getSource(state, (0, _sourceActors.getSourceActor)(state, actorId).source);
}

function getSourcesByURLInSources(sources, urls, url) {
  if (!url || !urls[url]) {
    return [];
  }
  return urls[url].map(id => (0, _resource.getResource)(sources, id));
}

function getSourcesByURL(state, url) {
  return getSourcesByURLInSources(getSources(state), getUrls(state), url);
}

function getSourceByURL(state, url) {
  const foundSources = getSourcesByURL(state, url);
  return foundSources ? foundSources[0] : null;
}

function getSpecificSourceByURLInSources(sources, urls, url, isOriginal) {
  const foundSources = getSourcesByURLInSources(sources, urls, url);
  if (foundSources) {
    return foundSources.find(source => (0, _source.isOriginal)(source) == isOriginal);
  }
  return null;
}

function getSpecificSourceByURL(state, url, isOriginal) {
  return getSpecificSourceByURLInSources(getSources(state), getUrls(state), url, isOriginal);
}

function getOriginalSourceByURL(state, url) {
  return getSpecificSourceByURL(state, url, true);
}

function getGeneratedSourceByURL(state, url) {
  return getSpecificSourceByURL(state, url, false);
}

function getGeneratedSource(state, source) {
  if (!source) {
    return null;
  }

  if ((0, _source.isGenerated)(source)) {
    return source;
  }

  return getSourceFromId(state, (0, _devtoolsSourceMap.originalToGeneratedId)(source.id));
}

function getGeneratedSourceById(state, sourceId) {
  const generatedSourceId = (0, _devtoolsSourceMap.originalToGeneratedId)(sourceId);
  return getSourceFromId(state, generatedSourceId);
}

function getPendingSelectedLocation(state) {
  return state.sources.pendingSelectedLocation;
}

function getPrettySource(state, id) {
  if (!id) {
    return;
  }

  const source = getSource(state, id);
  if (!source) {
    return;
  }

  return getOriginalSourceByURL(state, (0, _source.getPrettySourceURL)(source.url));
}

function hasPrettySource(state, id) {
  return !!getPrettySource(state, id);
}

function getSourcesUrlsInSources(state, url) {
  if (!url) {
    return [];
  }

  const plainUrl = (0, _source.getPlainUrl)(url);
  return getPlainUrls(state)[plainUrl] || [];
}

function getHasSiblingOfSameName(state, source) {
  if (!source) {
    return false;
  }

  return getSourcesUrlsInSources(state, source.url).length > 1;
}

const querySourceList = (0, _resource.makeReduceAllQuery)(resourceAsSource, sources => sources.slice());

function getSources(state) {
  return state.sources.sources;
}

function getSourcesEpoch(state) {
  return state.sources.epoch;
}

function getUrls(state) {
  return state.sources.urls;
}

function getPlainUrls(state) {
  return state.sources.plainUrls;
}

function getSourceList(state) {
  return querySourceList(getSources(state));
}

function getDisplayedSourcesList(state) {
  return Object.values(getDisplayedSources(state)).flatMap(Object.values);
}

function getSourceCount(state) {
  return getSourceList(state).length;
}

const getSelectedLocation = exports.getSelectedLocation = (0, _reselect.createSelector)(getSourcesState, sources => sources.selectedLocation);

const getSelectedSource = exports.getSelectedSource = (0, _reselect.createSelector)(getSelectedLocation, getSources, (selectedLocation, sources) => {
  if (!selectedLocation) {
    return;
  }

  return getSourceInSources(sources, selectedLocation.sourceId);
});

const getSelectedSourceWithContent = exports.getSelectedSourceWithContent = (0, _reselect.createSelector)(getSelectedLocation, getSources, state => state.sources.content, (selectedLocation, sources, content) => {
  const source = selectedLocation && getSourceInSources(sources, selectedLocation.sourceId);
  return source ? getSourceWithContentInner(sources, content, source.id) : null;
});
function getSourceWithContent(state, id) {
  return getSourceWithContentInner(state.sources.sources, state.sources.content, id);
}
function getSourceContent(state, id) {
  // Assert the resource exists.
  (0, _resource.getResource)(state.sources.sources, id);
  const content = state.sources.content[id];

  if (!content || content.state === "pending") {
    return null;
  }

  return content;
}

const contentLookup = new WeakMap();
function getSourceWithContentInner(sources, content, id) {
  const source = (0, _resource.getResource)(sources, id);
  let contentValue = content[source.id];

  let result = contentLookup.get(source);
  if (!result || result.content !== contentValue) {
    if (contentValue && contentValue.state === "pending") {
      contentValue = null;
    }
    result = {
      source,
      content: contentValue
    };
    contentLookup.set(source, result);
  }

  return result;
}

function getSelectedSourceId(state) {
  const source = getSelectedSource(state);
  return source && source.id;
}

function getProjectDirectoryRoot(state) {
  return state.sources.projectDirectoryRoot;
}

const queryAllDisplayedSources = (0, _resource.makeReduceQuery)((0, _resource.makeMapWithArgs)((resource, ident, { projectDirectoryRoot, chromeAndExtensionsEnabled }) => ({
  id: resource.id,
  displayed: (0, _source.underRoot)(resource, projectDirectoryRoot) && (!resource.isExtension || chromeAndExtensionsEnabled)
})), items => items.reduce((acc, { id, displayed }) => {
  if (displayed) {
    acc.push(id);
  }
  return acc;
}, []));

function getAllDisplayedSources(state) {
  return queryAllDisplayedSources(state.sources.sources, {
    projectDirectoryRoot: state.sources.projectDirectoryRoot,
    chromeAndExtensionsEnabled: state.sources.chromeAndExtenstionsEnabled
  });
}

const getDisplayedSourceIDs = (0, _reselect.createSelector)(_sourceActors.getThreadsBySource, getAllDisplayedSources, (threadsBySource, displayedSources) => {
  const sourceIDsByThread = {};

  for (const sourceId of displayedSources) {
    const threads = threadsBySource[sourceId] || threadsBySource[(0, _devtoolsSourceMap.originalToGeneratedId)(sourceId)] || [];

    for (const thread of threads) {
      if (!sourceIDsByThread[thread]) {
        sourceIDsByThread[thread] = new Set();
      }
      sourceIDsByThread[thread].add(sourceId);
    }
  }
  return sourceIDsByThread;
});

const getDisplayedSources = exports.getDisplayedSources = (0, _reselect.createSelector)(state => state.sources.sources, getDisplayedSourceIDs, (sources, idsByThread) => {
  const result = {};

  for (const thread of Object.keys(idsByThread)) {
    for (const id of idsByThread[thread]) {
      if (!result[thread]) {
        result[thread] = {};
      }
      result[thread][id] = (0, _resource.getResource)(sources, id);
    }
  }

  return result;
});

function getSourceActorsForSource(state, id) {
  const actors = state.sources.actors[id];
  if (!actors) {
    return [];
  }

  return (0, _sourceActors.getSourceActors)(state, actors);
}

function getBreakpointPositions(state) {
  return state.sources.breakpointPositions;
}

function getBreakpointPositionsForSource(state, sourceId) {
  const positions = getBreakpointPositions(state);
  return positions && positions[sourceId];
}

function hasBreakpointPositions(state, sourceId) {
  return !!getBreakpointPositionsForSource(state, sourceId);
}

function hasBreakpointPositionsForLine(state, sourceId, line) {
  const positions = getBreakpointPositionsForSource(state, sourceId);
  return !!(positions && positions[line]);
}

function getBreakpointPositionsForLocation(state, location) {
  const { sourceId } = location;
  const positions = getBreakpointPositionsForSource(state, sourceId);
  return (0, _breakpointPositions.findPosition)(positions, location);
}

function getBreakableLines(state, sourceId) {
  if (!sourceId) {
    return null;
  }

  return state.sources.breakableLines[sourceId];
}

const getSelectedBreakableLines = exports.getSelectedBreakableLines = (0, _reselect.createSelector)(state => {
  const sourceId = getSelectedSourceId(state);
  return sourceId && state.sources.breakableLines[sourceId];
}, breakableLines => new Set(breakableLines || []));

function isSourceLoadingOrLoaded(state, sourceId) {
  const content = state.sources.content[sourceId];
  return content !== null;
}

exports.default = update;

/***/ }),
/* 499 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _astBreakpointLocation = __webpack_require__(641);

Object.keys(_astBreakpointLocation).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _astBreakpointLocation[key];
    }
  });
});

var _breakpointPositions = __webpack_require__(574);

Object.keys(_breakpointPositions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _breakpointPositions[key];
    }
  });
});
exports.firstString = firstString;
exports.makeBreakpointId = makeBreakpointId;
exports.getLocationWithoutColumn = getLocationWithoutColumn;
exports.makePendingLocationId = makePendingLocationId;
exports.makeBreakpointLocation = makeBreakpointLocation;
exports.makeSourceActorLocation = makeSourceActorLocation;
exports.makeBreakpointActorId = makeBreakpointActorId;
exports.assertBreakpoint = assertBreakpoint;
exports.assertPendingBreakpoint = assertPendingBreakpoint;
exports.assertLocation = assertLocation;
exports.assertPendingLocation = assertPendingLocation;
exports.breakpointAtLocation = breakpointAtLocation;
exports.breakpointExists = breakpointExists;
exports.createXHRBreakpoint = createXHRBreakpoint;
exports.createPendingBreakpoint = createPendingBreakpoint;
exports.getSelectedText = getSelectedText;
exports.sortSelectedBreakpoints = sortSelectedBreakpoints;

var _selectors = __webpack_require__(490);

var _source = __webpack_require__(494);

var _location = __webpack_require__(509);

var _assert = __webpack_require__(385);

var _assert2 = _interopRequireDefault(_assert);

var _prefs = __webpack_require__(492);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Return the first argument that is a string, or null if nothing is a
// string.
function firstString(...args) {
  for (const arg of args) {
    if (typeof arg === "string") {
      return arg;
    }
  }
  return null;
}

// The ID for a Breakpoint is derived from its location in its Source.
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function makeBreakpointId(location) {
  const { sourceId, line, column } = location;
  const columnString = column || "";
  return `${sourceId}:${line}:${columnString}`;
}

function getLocationWithoutColumn(location) {
  const { sourceId, line } = location;
  return `${sourceId}:${line}`;
}

function makePendingLocationId(location) {
  assertPendingLocation(location);
  const { sourceUrl, line, column } = location;
  const sourceUrlString = sourceUrl || "";
  const columnString = column || "";

  return `${sourceUrlString}:${line}:${columnString}`;
}

function makeBreakpointLocation(state, location) {
  const source = (0, _selectors.getSource)(state, location.sourceId);
  if (!source) {
    throw new Error("no source");
  }
  const breakpointLocation = {
    line: location.line,
    column: location.column
  };
  if (source.url) {
    breakpointLocation.sourceUrl = source.url;
  } else {
    breakpointLocation.sourceId = (0, _selectors.getSourceActorsForSource)(state, source.id)[0].id;
  }
  return breakpointLocation;
}

function makeSourceActorLocation(sourceActor, location) {
  return {
    sourceActor,
    line: location.line,
    column: location.column
  };
}

// The ID for a BreakpointActor is derived from its location in its SourceActor.
function makeBreakpointActorId(location) {
  const { sourceActor, line, column } = location;
  const columnString = column || "";
  return `${sourceActor}:${line}:${columnString}`;
}

function assertBreakpoint(breakpoint) {
  assertLocation(breakpoint.location);
  assertLocation(breakpoint.generatedLocation);
}

function assertPendingBreakpoint(pendingBreakpoint) {
  assertPendingLocation(pendingBreakpoint.location);
  assertPendingLocation(pendingBreakpoint.generatedLocation);
}

function assertLocation(location) {
  assertPendingLocation(location);
  const { sourceId } = location;
  (0, _assert2.default)(!!sourceId, "location must have a source id");
}

function assertPendingLocation(location) {
  (0, _assert2.default)(!!location, "location must exist");

  const { sourceUrl } = location;

  // sourceUrl is null when the source does not have a url
  (0, _assert2.default)(sourceUrl !== undefined, "location must have a source url");
  (0, _assert2.default)(location.hasOwnProperty("line"), "location must have a line");
  (0, _assert2.default)(location.hasOwnProperty("column") != null, "location must have a column");
}

// syncing
function breakpointAtLocation(breakpoints, { line, column }) {
  return breakpoints.find(breakpoint => {
    const sameLine = breakpoint.location.line === line;
    if (!sameLine) {
      return false;
    }

    // NOTE: when column breakpoints are disabled we want to find
    // the first breakpoint
    if (!_prefs.features.columnBreakpoints) {
      return true;
    }

    return breakpoint.location.column === column;
  });
}

function breakpointExists(state, location) {
  const currentBp = (0, _selectors.getBreakpoint)(state, location);
  return currentBp && !currentBp.disabled;
}

function createXHRBreakpoint(path, method, overrides = {}) {
  const properties = {
    path,
    method,
    disabled: false,
    loading: false,
    text: L10N.getFormatStr("xhrBreakpoints.item.label", path)
  };

  return { ...properties, ...overrides };
}

function createPendingLocation(location) {
  const { sourceUrl, line, column } = location;
  return { sourceUrl, line, column };
}

function createPendingBreakpoint(bp) {
  const pendingLocation = createPendingLocation(bp.location);
  const pendingGeneratedLocation = createPendingLocation(bp.generatedLocation);

  assertPendingLocation(pendingLocation);

  return {
    options: bp.options,
    disabled: bp.disabled,
    location: pendingLocation,
    astLocation: bp.astLocation,
    generatedLocation: pendingGeneratedLocation
  };
}

function getSelectedText(breakpoint, selectedSource) {
  return selectedSource && (0, _source.isGenerated)(selectedSource) ? breakpoint.text : breakpoint.originalText;
}

function sortSelectedBreakpoints(breakpoints, selectedSource) {
  return (0, _location.sortSelectedLocations)(breakpoints, selectedSource);
}

/***/ }),
/* 500 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.promise = exports.PROMISE = undefined;

var _lodash = __webpack_require__(417);

var _DevToolsUtils = __webpack_require__(635);

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

let seqIdVal = 1;

function seqIdGen() {
  return seqIdVal++;
}

function filterAction(action) {
  return (0, _lodash.fromPairs)((0, _lodash.toPairs)(action).filter(pair => pair[0] !== PROMISE));
}

function promiseMiddleware({
  dispatch,
  getState
}) {
  return next => action => {
    if (!(PROMISE in action)) {
      return next(action);
    }

    const promiseInst = action[PROMISE];
    const seqId = seqIdGen().toString();

    // Create a new action that doesn't have the promise field and has
    // the `seqId` field that represents the sequence id
    action = { ...filterAction(action), seqId };

    dispatch({ ...action, status: "start" });

    // Return the promise so action creators can still compose if they
    // want to.
    return Promise.resolve(promiseInst).finally(() => new Promise(resolve => (0, _DevToolsUtils.executeSoon)(resolve))).then(value => {
      dispatch({ ...action, status: "done", value: value });
      return value;
    }, error => {
      dispatch({
        ...action,
        status: "error",
        error: error.message || error
      });
      return Promise.reject(error);
    });
  };
}

const PROMISE = exports.PROMISE = "@@dispatch/promise";
exports.promise = promiseMiddleware;

/***/ }),
/* 501 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSelectedLocation = getSelectedLocation;

var _devtoolsSourceMap = __webpack_require__(182);

function getSelectedLocation(mappedLocation, context) {
  if (!context) {
    return mappedLocation.location;
  }

  // $FlowIgnore
  const sourceId = context.sourceId || context.id;
  return (0, _devtoolsSourceMap.isOriginalId)(sourceId) ? mappedLocation.location : mappedLocation.generatedLocation;
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/***/ }),
/* 502 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PaneToggleButton = exports.debugBtn = exports.CommandBarButton = exports.CloseButton = undefined;

var _CloseButton = __webpack_require__(696);

var _CloseButton2 = _interopRequireDefault(_CloseButton);

var _CommandBarButton = __webpack_require__(554);

var _CommandBarButton2 = _interopRequireDefault(_CommandBarButton);

var _PaneToggleButton = __webpack_require__(700);

var _PaneToggleButton2 = _interopRequireDefault(_PaneToggleButton);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.CloseButton = _CloseButton2.default;
exports.CommandBarButton = _CommandBarButton2.default;
exports.debugBtn = _CommandBarButton.debugBtn;
exports.PaneToggleButton = _PaneToggleButton2.default; /* This Source Code Form is subject to the terms of the Mozilla Public
                                                        * License, v. 2.0. If a copy of the MPL was not distributed with this
                                                        * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/***/ }),
/* 503 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mapExpression = exports.hasSyntaxError = exports.clearSources = exports.setSource = exports.getSymbols = exports.clearSymbols = exports.clearScopes = exports.getScopes = exports.clearASTs = exports.getNextStep = exports.findOutOfScopeLocations = exports.stop = exports.start = undefined;

var _devtoolsUtils = __webpack_require__(7);

const { WorkerDispatcher } = _devtoolsUtils.workerUtils; /* This Source Code Form is subject to the terms of the Mozilla Public
                                                          * License, v. 2.0. If a copy of the MPL was not distributed with this
                                                          * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const dispatcher = new WorkerDispatcher();
const start = exports.start = (url, win = window) => dispatcher.start(url, win);
const stop = exports.stop = () => dispatcher.stop();

const findOutOfScopeLocations = exports.findOutOfScopeLocations = async (sourceId, position) => dispatcher.invoke("findOutOfScopeLocations", sourceId, position);

const getNextStep = exports.getNextStep = async (sourceId, pausedPosition) => dispatcher.invoke("getNextStep", sourceId, pausedPosition);

const clearASTs = exports.clearASTs = async () => dispatcher.invoke("clearASTs");

const getScopes = exports.getScopes = async location => dispatcher.invoke("getScopes", location);

const clearScopes = exports.clearScopes = async () => dispatcher.invoke("clearScopes");

const clearSymbols = exports.clearSymbols = async () => dispatcher.invoke("clearSymbols");

const getSymbols = exports.getSymbols = async sourceId => dispatcher.invoke("getSymbols", sourceId);

const setSource = exports.setSource = async (sourceId, content) => {
  const astSource = {
    id: sourceId,
    text: content.type === "wasm" ? "" : content.value,
    contentType: content.contentType || null,
    isWasm: content.type === "wasm"
  };

  await dispatcher.invoke("setSource", astSource);
};

const clearSources = exports.clearSources = async () => dispatcher.invoke("clearSources");

const hasSyntaxError = exports.hasSyntaxError = async input => dispatcher.invoke("hasSyntaxError", input);

const mapExpression = exports.mapExpression = async (expression, mappings, bindings, shouldMapBindings, shouldMapAwait) => dispatcher.invoke("mapExpression", expression, mappings, bindings, shouldMapBindings, shouldMapAwait);

/***/ }),
/* 504 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _breakpointPositions = __webpack_require__(534);

Object.keys(_breakpointPositions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _breakpointPositions[key];
    }
  });
});

var _modify = __webpack_require__(654);

Object.keys(_modify).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _modify[key];
    }
  });
});

var _syncBreakpoint = __webpack_require__(655);

Object.keys(_syncBreakpoint).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _syncBreakpoint[key];
    }
  });
});
exports.addHiddenBreakpoint = addHiddenBreakpoint;
exports.disableBreakpointsInSource = disableBreakpointsInSource;
exports.enableBreakpointsInSource = enableBreakpointsInSource;
exports.toggleAllBreakpoints = toggleAllBreakpoints;
exports.toggleBreakpoints = toggleBreakpoints;
exports.toggleBreakpointsAtLine = toggleBreakpointsAtLine;
exports.removeAllBreakpoints = removeAllBreakpoints;
exports.removeBreakpoints = removeBreakpoints;
exports.removeBreakpointsInSource = removeBreakpointsInSource;
exports.remapBreakpoints = remapBreakpoints;
exports.toggleBreakpointAtLine = toggleBreakpointAtLine;
exports.addBreakpointAtLine = addBreakpointAtLine;
exports.removeBreakpointsAtLine = removeBreakpointsAtLine;
exports.disableBreakpointsAtLine = disableBreakpointsAtLine;
exports.enableBreakpointsAtLine = enableBreakpointsAtLine;
exports.toggleDisabledBreakpoint = toggleDisabledBreakpoint;
exports.enableXHRBreakpoint = enableXHRBreakpoint;
exports.disableXHRBreakpoint = disableXHRBreakpoint;
exports.updateXHRBreakpoint = updateXHRBreakpoint;
exports.togglePauseOnAny = togglePauseOnAny;
exports.setXHRBreakpoint = setXHRBreakpoint;
exports.removeXHRBreakpoint = removeXHRBreakpoint;

var _promise = __webpack_require__(500);

var _selectors = __webpack_require__(490);

var _breakpoint = __webpack_require__(499);

var _remapLocations = __webpack_require__(673);

var _remapLocations2 = _interopRequireDefault(_remapLocations);

var _ui = __webpack_require__(538);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function addHiddenBreakpoint(cx, location) {
  return ({ dispatch }) => {
    return dispatch((0, _modify.addBreakpoint)(cx, location, { hidden: true }));
  };
}

/**
 * Disable all breakpoints in a source
 *
 * @memberof actions/breakpoints
 * @static
 */


// this will need to be changed so that addCLientBreakpoint is removed

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/**
 * Redux actions for breakpoints
 * @module actions/breakpoints
 */

function disableBreakpointsInSource(cx, source) {
  return async ({ dispatch, getState, client }) => {
    const breakpoints = (0, _selectors.getBreakpointsForSource)(getState(), source.id);
    for (const breakpoint of breakpoints) {
      if (!breakpoint.disabled) {
        dispatch((0, _modify.disableBreakpoint)(cx, breakpoint));
      }
    }
  };
}

/**
 * Enable all breakpoints in a source
 *
 * @memberof actions/breakpoints
 * @static
 */
function enableBreakpointsInSource(cx, source) {
  return async ({ dispatch, getState, client }) => {
    const breakpoints = (0, _selectors.getBreakpointsForSource)(getState(), source.id);
    for (const breakpoint of breakpoints) {
      if (breakpoint.disabled) {
        dispatch((0, _modify.enableBreakpoint)(cx, breakpoint));
      }
    }
  };
}

/**
 * Toggle All Breakpoints
 *
 * @memberof actions/breakpoints
 * @static
 */
function toggleAllBreakpoints(cx, shouldDisableBreakpoints) {
  return async ({ dispatch, getState, client }) => {
    const breakpoints = (0, _selectors.getBreakpointsList)(getState());

    for (const breakpoint of breakpoints) {
      if (shouldDisableBreakpoints) {
        dispatch((0, _modify.disableBreakpoint)(cx, breakpoint));
      } else {
        dispatch((0, _modify.enableBreakpoint)(cx, breakpoint));
      }
    }
  };
}

/**
 * Toggle Breakpoints
 *
 * @memberof actions/breakpoints
 * @static
 */
function toggleBreakpoints(cx, shouldDisableBreakpoints, breakpoints) {
  return async ({ dispatch }) => {
    const promises = breakpoints.map(breakpoint => shouldDisableBreakpoints ? dispatch((0, _modify.disableBreakpoint)(cx, breakpoint)) : dispatch((0, _modify.enableBreakpoint)(cx, breakpoint)));

    await Promise.all(promises);
  };
}

function toggleBreakpointsAtLine(cx, shouldDisableBreakpoints, line) {
  return async ({ dispatch, getState }) => {
    const breakpoints = (0, _selectors.getBreakpointsAtLine)(getState(), line);
    return dispatch(toggleBreakpoints(cx, shouldDisableBreakpoints, breakpoints));
  };
}

/**
 * Removes all breakpoints
 *
 * @memberof actions/breakpoints
 * @static
 */
function removeAllBreakpoints(cx) {
  return async ({ dispatch, getState }) => {
    const breakpointList = (0, _selectors.getBreakpointsList)(getState());
    return Promise.all(breakpointList.map(bp => dispatch((0, _modify.removeBreakpoint)(cx, bp))));
  };
}

/**
 * Removes breakpoints
 *
 * @memberof actions/breakpoints
 * @static
 */
function removeBreakpoints(cx, breakpoints) {
  return async ({ dispatch }) => {
    return Promise.all(breakpoints.map(bp => dispatch((0, _modify.removeBreakpoint)(cx, bp))));
  };
}

/**
 * Removes all breakpoints in a source
 *
 * @memberof actions/breakpoints
 * @static
 */
function removeBreakpointsInSource(cx, source) {
  return async ({ dispatch, getState, client }) => {
    const breakpoints = (0, _selectors.getBreakpointsForSource)(getState(), source.id);
    for (const breakpoint of breakpoints) {
      dispatch((0, _modify.removeBreakpoint)(cx, breakpoint));
    }
  };
}

function remapBreakpoints(cx, sourceId) {
  return async ({ dispatch, getState, sourceMaps }) => {
    const breakpoints = (0, _selectors.getBreakpointsForSource)(getState(), sourceId);
    const newBreakpoints = await (0, _remapLocations2.default)(breakpoints, sourceId, sourceMaps);

    // Normally old breakpoints will be clobbered if we re-add them, but when
    // remapping we have changed the source maps and the old breakpoints will
    // have different locations than the new ones. Manually remove the
    // old breakpoints before adding the new ones.
    for (const bp of breakpoints) {
      dispatch((0, _modify.removeBreakpoint)(cx, bp));
    }

    for (const bp of newBreakpoints) {
      await dispatch((0, _modify.addBreakpoint)(cx, bp.location, bp.options, bp.disabled));
    }
  };
}

function toggleBreakpointAtLine(cx, line) {
  return ({ dispatch, getState, client, sourceMaps }) => {
    const state = getState();
    const selectedSource = (0, _selectors.getSelectedSource)(state);

    if (!selectedSource) {
      return;
    }

    if ((0, _selectors.getConditionalPanelLocation)(getState())) {
      dispatch((0, _ui.closeConditionalPanel)());
    }

    const bp = (0, _selectors.getBreakpointAtLocation)(state, { line, column: undefined });
    if (bp) {
      return dispatch((0, _modify.removeBreakpoint)(cx, bp));
    }
    return dispatch((0, _modify.addBreakpoint)(cx, {
      sourceId: selectedSource.id,
      sourceUrl: selectedSource.url,
      line: line
    }));
  };
}

function addBreakpointAtLine(cx, line, shouldLog = false, disabled = false) {
  return ({ dispatch, getState, client, sourceMaps }) => {
    const state = getState();
    const source = (0, _selectors.getSelectedSource)(state);

    if (!source) {
      return;
    }
    const breakpointLocation = {
      sourceId: source.id,
      sourceUrl: source.url,
      column: undefined,
      line
    };

    const options = {};
    if (shouldLog) {
      options.logValue = "displayName";
    }

    return dispatch((0, _modify.addBreakpoint)(cx, breakpointLocation, options, disabled));
  };
}

function removeBreakpointsAtLine(cx, sourceId, line) {
  return ({ dispatch, getState, client, sourceMaps }) => {
    const breakpointsAtLine = (0, _selectors.getBreakpointsForSource)(getState(), sourceId, line);
    return dispatch(removeBreakpoints(cx, breakpointsAtLine));
  };
}

function disableBreakpointsAtLine(cx, sourceId, line) {
  return ({ dispatch, getState, client, sourceMaps }) => {
    const breakpointsAtLine = (0, _selectors.getBreakpointsForSource)(getState(), sourceId, line);
    return dispatch(toggleBreakpoints(cx, true, breakpointsAtLine));
  };
}

function enableBreakpointsAtLine(cx, sourceId, line) {
  return ({ dispatch, getState, client, sourceMaps }) => {
    const breakpointsAtLine = (0, _selectors.getBreakpointsForSource)(getState(), sourceId, line);
    return dispatch(toggleBreakpoints(cx, false, breakpointsAtLine));
  };
}

function toggleDisabledBreakpoint(cx, breakpoint) {
  return ({ dispatch, getState, client, sourceMaps }) => {
    if (!breakpoint.disabled) {
      return dispatch((0, _modify.disableBreakpoint)(cx, breakpoint));
    }
    return dispatch((0, _modify.enableBreakpoint)(cx, breakpoint));
  };
}

function enableXHRBreakpoint(index, bp) {
  return ({ dispatch, getState, client }) => {
    const xhrBreakpoints = (0, _selectors.getXHRBreakpoints)(getState());
    const breakpoint = bp || xhrBreakpoints[index];
    const enabledBreakpoint = {
      ...breakpoint,
      disabled: false
    };

    return dispatch({
      type: "ENABLE_XHR_BREAKPOINT",
      breakpoint: enabledBreakpoint,
      index,
      [_promise.PROMISE]: client.setXHRBreakpoint(breakpoint.path, breakpoint.method)
    });
  };
}

function disableXHRBreakpoint(index, bp) {
  return ({ dispatch, getState, client }) => {
    const xhrBreakpoints = (0, _selectors.getXHRBreakpoints)(getState());
    const breakpoint = bp || xhrBreakpoints[index];
    const disabledBreakpoint = {
      ...breakpoint,
      disabled: true
    };

    return dispatch({
      type: "DISABLE_XHR_BREAKPOINT",
      breakpoint: disabledBreakpoint,
      index,
      [_promise.PROMISE]: client.removeXHRBreakpoint(breakpoint.path, breakpoint.method)
    });
  };
}

function updateXHRBreakpoint(index, path, method) {
  return ({ dispatch, getState, client }) => {
    const xhrBreakpoints = (0, _selectors.getXHRBreakpoints)(getState());
    const breakpoint = xhrBreakpoints[index];

    const updatedBreakpoint = {
      ...breakpoint,
      path,
      method,
      text: L10N.getFormatStr("xhrBreakpoints.item.label", path)
    };

    return dispatch({
      type: "UPDATE_XHR_BREAKPOINT",
      breakpoint: updatedBreakpoint,
      index,
      [_promise.PROMISE]: Promise.all([client.removeXHRBreakpoint(breakpoint.path, breakpoint.method), client.setXHRBreakpoint(path, method)])
    });
  };
}
function togglePauseOnAny() {
  return ({ dispatch, getState }) => {
    const xhrBreakpoints = (0, _selectors.getXHRBreakpoints)(getState());
    const index = xhrBreakpoints.findIndex(({ path }) => path.length === 0);
    if (index < 0) {
      return dispatch(setXHRBreakpoint("", "ANY"));
    }

    const bp = xhrBreakpoints[index];
    if (bp.disabled) {
      return dispatch(enableXHRBreakpoint(index, bp));
    }

    return dispatch(disableXHRBreakpoint(index, bp));
  };
}

function setXHRBreakpoint(path, method) {
  return ({ dispatch, getState, client }) => {
    const breakpoint = (0, _breakpoint.createXHRBreakpoint)(path, method);

    return dispatch({
      type: "SET_XHR_BREAKPOINT",
      breakpoint,
      [_promise.PROMISE]: client.setXHRBreakpoint(path, method)
    });
  };
}

function removeXHRBreakpoint(index) {
  return ({ dispatch, getState, client }) => {
    const xhrBreakpoints = (0, _selectors.getXHRBreakpoints)(getState());
    const breakpoint = xhrBreakpoints[index];
    return dispatch({
      type: "REMOVE_XHR_BREAKPOINT",
      breakpoint,
      index,
      [_promise.PROMISE]: client.removeXHRBreakpoint(breakpoint.path, breakpoint.method)
    });
  };
}

/***/ }),
/* 505 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _blackbox = __webpack_require__(589);

Object.keys(_blackbox).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _blackbox[key];
    }
  });
});

var _breakableLines = __webpack_require__(590);

Object.keys(_breakableLines).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _breakableLines[key];
    }
  });
});

var _loadSourceText = __webpack_require__(507);

Object.keys(_loadSourceText).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _loadSourceText[key];
    }
  });
});

var _newSources = __webpack_require__(672);

Object.keys(_newSources).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _newSources[key];
    }
  });
});

var _prettyPrint = __webpack_require__(535);

Object.keys(_prettyPrint).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _prettyPrint[key];
    }
  });
});

var _select = __webpack_require__(551);

Object.keys(_select).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _select[key];
    }
  });
});

var _symbols = __webpack_require__(521);

Object.defineProperty(exports, "setSymbols", {
  enumerable: true,
  get: function () {
    return _symbols.setSymbols;
  }
});

/***/ }),
/* 506 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nodeHasChildren = nodeHasChildren;
exports.isExactUrlMatch = isExactUrlMatch;
exports.isPathDirectory = isPathDirectory;
exports.isDirectory = isDirectory;
exports.getSourceFromNode = getSourceFromNode;
exports.isSource = isSource;
exports.getFileExtension = getFileExtension;
exports.isNotJavaScript = isNotJavaScript;
exports.isInvalidUrl = isInvalidUrl;
exports.partIsFile = partIsFile;
exports.createDirectoryNode = createDirectoryNode;
exports.createSourceNode = createSourceNode;
exports.createParentMap = createParentMap;
exports.getRelativePath = getRelativePath;

var _url = __webpack_require__(515);

var _source = __webpack_require__(494);

var _getURL = __webpack_require__(541);

const IGNORED_URLS = ["debugger eval code", "XStringBundle"]; /* This Source Code Form is subject to the terms of the Mozilla Public
                                                               * License, v. 2.0. If a copy of the MPL was not distributed with this
                                                               * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function nodeHasChildren(item) {
  return Array.isArray(item.contents) && item.type == "directory";
}

function isExactUrlMatch(pathPart, debuggeeUrl) {
  // compare to hostname with an optional 'www.' prefix
  const { host } = (0, _url.parse)(debuggeeUrl);
  if (!host) {
    return false;
  }
  return host.replace(/^www\./, "") === pathPart.replace(/^www\./, "");
}

function isPathDirectory(path) {
  // Assume that all urls point to files except when they end with '/'
  // Or directory node has children
  const parts = path.split("/").filter(p => p !== "");
  return parts.length === 0 || path.slice(-1) === "/";
}

function isDirectory(item) {
  return (isPathDirectory(item.path) || item.type === "directory") && item.name != "(index)";
}

function getSourceFromNode(item) {
  const { contents } = item;
  if (!isDirectory(item) && !Array.isArray(contents)) {
    return contents;
  }
}

function isSource(item) {
  return item.type === "source";
}

function getFileExtension(source) {
  const parsedUrl = (0, _getURL.getURL)(source).path;
  if (!parsedUrl) {
    return "";
  }
  return parsedUrl.split(".").pop();
}

function isNotJavaScript(source) {
  return ["css", "svg", "png"].includes(getFileExtension(source));
}

function isInvalidUrl(url, source) {
  return IGNORED_URLS.includes(url) || !source.url || !url.group || (0, _source.isPretty)(source) || isNotJavaScript(source);
}

function partIsFile(index, parts, url) {
  const isLastPart = index === parts.length - 1;
  return !isDirectory(url) && isLastPart;
}

function createDirectoryNode(name, path, contents) {
  return {
    type: "directory",
    name,
    path,
    contents
  };
}

function createSourceNode(name, path, contents) {
  return {
    type: "source",
    name,
    path,
    contents
  };
}

function createParentMap(tree) {
  const map = new WeakMap();

  function _traverse(subtree) {
    if (subtree.type === "directory") {
      for (const child of subtree.contents) {
        map.set(child, subtree);
        _traverse(child);
      }
    }
  }

  if (tree.type === "directory") {
    // Don't link each top-level path to the "root" node because the
    // user never sees the root
    tree.contents.forEach(_traverse);
  }

  return map;
}

function getRelativePath(url) {
  const { pathname } = (0, _url.parse)(url);
  if (!pathname) {
    return url;
  }
  const path = pathname.split("/");
  path.shift();
  return path.join("/");
}

/***/ }),
/* 507 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadSourceText = undefined;
exports.loadSourceById = loadSourceById;

var _promise = __webpack_require__(500);

var _selectors = __webpack_require__(490);

var _breakpoints = __webpack_require__(504);

var _prettyPrint = __webpack_require__(535);

var _breakableLines = __webpack_require__(590);

var _asyncValue = __webpack_require__(497);

var _parser = __webpack_require__(503);

var parser = _interopRequireWildcard(_parser);

var _source = __webpack_require__(494);

var _memoizableAction = __webpack_require__(546);

var _devtoolsModules = __webpack_require__(183);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// Measures the time it takes for a source to load
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const loadSourceHistogram = "DEVTOOLS_DEBUGGER_LOAD_SOURCE_MS";
const telemetry = new _devtoolsModules.Telemetry();

async function loadSource(state, source, { sourceMaps, client, getState }) {
  if ((0, _source.isPretty)(source) && (0, _source.isOriginal)(source)) {
    const generatedSource = (0, _selectors.getGeneratedSource)(state, source);
    if (!generatedSource) {
      throw new Error("Unable to find minified original.");
    }
    const content = (0, _selectors.getSourceContent)(state, generatedSource.id);
    if (!content || !(0, _asyncValue.isFulfilled)(content)) {
      throw new Error("Cannot pretty-print a file that has not loaded");
    }

    return (0, _prettyPrint.prettyPrintSource)(sourceMaps, generatedSource, content.value, (0, _selectors.getSourceActorsForSource)(state, generatedSource.id));
  }

  if ((0, _source.isOriginal)(source)) {
    const result = await sourceMaps.getOriginalSourceText(source);
    if (!result) {
      // The way we currently try to load and select a pending
      // selected location, it is possible that we will try to fetch the
      // original source text right after the source map has been cleared
      // after a navigation event.
      throw new Error("Original source text unavailable");
    }
    return result;
  }

  const actors = (0, _selectors.getSourceActorsForSource)(state, source.id);
  if (!actors.length) {
    throw new Error("No source actor for loadSource");
  }

  telemetry.start(loadSourceHistogram, source);
  const response = await client.sourceContents(actors[0]);
  telemetry.finish(loadSourceHistogram, source);

  return {
    text: response.source,
    contentType: response.contentType || "text/javascript"
  };
}

async function loadSourceTextPromise(cx, source, { dispatch, getState, client, sourceMaps }) {
  const epoch = (0, _selectors.getSourcesEpoch)(getState());
  await dispatch({
    type: "LOAD_SOURCE_TEXT",
    sourceId: source.id,
    epoch,
    [_promise.PROMISE]: loadSource(getState(), source, { sourceMaps, client, getState })
  });

  const newSource = (0, _selectors.getSource)(getState(), source.id);

  if (!newSource) {
    return;
  }
  const content = (0, _selectors.getSourceContent)(getState(), newSource.id);

  if (!newSource.isWasm && content) {
    parser.setSource(newSource.id, (0, _asyncValue.isFulfilled)(content) ? content.value : { type: "text", value: "", contentType: undefined });

    await dispatch((0, _breakableLines.setBreakableLines)(cx, source.id));
    // Update the text in any breakpoints for this source by re-adding them.
    const breakpoints = (0, _selectors.getBreakpointsForSource)(getState(), source.id);
    for (const { location, options, disabled } of breakpoints) {
      await dispatch((0, _breakpoints.addBreakpoint)(cx, location, options, disabled));
    }
  }

  return newSource;
}

function loadSourceById(cx, sourceId) {
  return ({ getState, dispatch }) => {
    const source = (0, _selectors.getSourceFromId)(getState(), sourceId);
    return dispatch(loadSourceText({ cx, source }));
  };
}

const loadSourceText = exports.loadSourceText = (0, _memoizableAction.memoizeableAction)("loadSourceText", {
  exitEarly: ({ source }) => !source,
  hasValue: ({ source }, { getState }) => {
    return !!((0, _selectors.getSource)(getState(), source.id) && (0, _selectors.getSourceWithContent)(getState(), source.id).content);
  },
  getValue: ({ source }, { getState }) => (0, _selectors.getSource)(getState(), source.id),
  createKey: ({ source }, { getState }) => {
    const epoch = (0, _selectors.getSourcesEpoch)(getState());
    return `${epoch}:${source.id}`;
  },
  action: ({ cx, source }, thunkArgs) => loadSourceTextPromise(cx, source, thunkArgs)
});

/***/ }),
/* 508 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clientEvents = exports.clientCommands = exports.createObjectClient = undefined;
exports.onConnect = onConnect;

var _commands = __webpack_require__(558);

var _events = __webpack_require__(559);

var _prefs = __webpack_require__(492);

let DebuggerClient; /* This Source Code Form is subject to the terms of the Mozilla Public
                     * License, v. 2.0. If a copy of the MPL was not distributed with this
                     * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function createObjectClient(grip) {
  return DebuggerClient.createObjectClient(grip);
}

async function onConnect(connection, actions) {
  const {
    tabConnection: { tabTarget, threadClient, debuggerClient }
  } = connection;

  DebuggerClient = debuggerClient;

  if (!tabTarget || !threadClient || !debuggerClient) {
    return;
  }

  const supportsWasm = _prefs.features.wasm && !!debuggerClient.mainRoot.traits.wasmBinarySource;

  (0, _commands.setupCommands)({
    threadClient,
    tabTarget,
    debuggerClient,
    supportsWasm
  });

  (0, _events.setupEvents)({ threadClient, tabTarget, actions, supportsWasm });

  tabTarget.on("will-navigate", actions.willNavigate);
  tabTarget.on("navigate", actions.navigated);

  await threadClient.reconfigure({
    observeAsmJS: true,
    pauseWorkersUntilAttach: true,
    wasmBinarySource: supportsWasm,
    skipBreakpoints: _prefs.prefs.skipPausing
  });

  // In Firefox, we need to initially request all of the sources. This
  // usually fires off individual `newSource` notifications as the
  // debugger finds them, but there may be existing sources already in
  // the debugger (if it's paused already, or if loading the page from
  // bfcache) so explicity fire `newSource` events for all returned
  // sources.
  const sourceInfo = await _commands.clientCommands.fetchSources();
  const traits = tabTarget.traits;
  await actions.connect(tabTarget.url, threadClient.actor, traits && traits.canRewind);
  await actions.newGeneratedSources(sourceInfo);

  // If the threadClient is already paused, make sure to show a
  // paused state.
  const pausedPacket = threadClient.getLastPausePacket();
  if (pausedPacket) {
    _events.clientEvents.paused(threadClient, "paused", pausedPacket);
  }
}

exports.createObjectClient = createObjectClient;
exports.clientCommands = _commands.clientCommands;
exports.clientEvents = _events.clientEvents;

/***/ }),
/* 509 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.comparePosition = comparePosition;
exports.createLocation = createLocation;
exports.sortSelectedLocations = sortSelectedLocations;

var _lodash = __webpack_require__(417);

var _selectedLocation = __webpack_require__(501);

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function comparePosition(a, b) {
  return a && b && a.line == b.line && a.column == b.column;
}

function createLocation({
  sourceId,
  line = 1,
  column,
  sourceUrl = ""
}) {
  return {
    sourceId,
    line,
    column,
    sourceUrl
  };
}

function sortSelectedLocations(locations, selectedSource) {
  return (0, _lodash.sortBy)(locations, [
  // Priority: line number, undefined column, column number
  location => (0, _selectedLocation.getSelectedLocation)(location, selectedSource).line, location => {
    const selectedLocation = (0, _selectedLocation.getSelectedLocation)(location, selectedSource);
    return selectedLocation.column === undefined || selectedLocation.column;
  }]);
}

/***/ }),
/* 510 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _annotateFrames = __webpack_require__(646);

Object.keys(_annotateFrames).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _annotateFrames[key];
    }
  });
});

var _collapseFrames = __webpack_require__(647);

Object.keys(_collapseFrames).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _collapseFrames[key];
    }
  });
});

var _displayName = __webpack_require__(648);

Object.keys(_displayName).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _displayName[key];
    }
  });
});

var _getFrameUrl = __webpack_require__(533);

Object.keys(_getFrameUrl).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _getFrameUrl[key];
    }
  });
});

var _getLibraryFromUrl = __webpack_require__(588);

Object.keys(_getLibraryFromUrl).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _getLibraryFromUrl[key];
    }
  });
});

/***/ }),
/* 511 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addExpression = addExpression;
exports.autocomplete = autocomplete;
exports.clearAutocomplete = clearAutocomplete;
exports.clearExpressionError = clearExpressionError;
exports.updateExpression = updateExpression;
exports.deleteExpression = deleteExpression;
exports.evaluateExpressions = evaluateExpressions;
exports.getMappedExpression = getMappedExpression;

var _selectors = __webpack_require__(490);

var _promise = __webpack_require__(500);

var _expressions = __webpack_require__(592);

var _prefs = __webpack_require__(492);

var _source = __webpack_require__(494);

var _parser = __webpack_require__(503);

var parser = _interopRequireWildcard(_parser);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Add expression for debugger to watch
 *
 * @param {object} expression
 * @param {number} expression.id
 * @memberof actions/pause
 * @static
 */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function addExpression(cx, input) {
  return async ({ dispatch, getState }) => {
    if (!input) {
      return;
    }

    const expressionError = await parser.hasSyntaxError(input);

    const expression = (0, _selectors.getExpression)(getState(), input);
    if (expression) {
      return dispatch(evaluateExpression(cx, expression));
    }

    dispatch({ type: "ADD_EXPRESSION", cx, input, expressionError });

    const newExpression = (0, _selectors.getExpression)(getState(), input);
    if (newExpression) {
      return dispatch(evaluateExpression(cx, newExpression));
    }
  };
}

function autocomplete(cx, input, cursor) {
  return async ({ dispatch, getState, client }) => {
    if (!input) {
      return;
    }
    const frameId = (0, _selectors.getSelectedFrameId)(getState(), cx.thread);
    const result = await client.autocomplete(input, cursor, frameId);
    await dispatch({ type: "AUTOCOMPLETE", cx, input, result });
  };
}

function clearAutocomplete() {
  return { type: "CLEAR_AUTOCOMPLETE" };
}

function clearExpressionError() {
  return { type: "CLEAR_EXPRESSION_ERROR" };
}

function updateExpression(cx, input, expression) {
  return async ({ dispatch, getState }) => {
    if (!input) {
      return;
    }

    const expressionError = await parser.hasSyntaxError(input);
    dispatch({
      type: "UPDATE_EXPRESSION",
      cx,
      expression,
      input: expressionError ? expression.input : input,
      expressionError
    });

    dispatch(evaluateExpressions(cx));
  };
}

/**
 *
 * @param {object} expression
 * @param {number} expression.id
 * @memberof actions/pause
 * @static
 */
function deleteExpression(expression) {
  return ({ dispatch }) => {
    dispatch({
      type: "DELETE_EXPRESSION",
      input: expression.input
    });
  };
}

/**
 *
 * @memberof actions/pause
 * @param {number} selectedFrameId
 * @static
 */
function evaluateExpressions(cx) {
  return async function ({ dispatch, getState, client }) {
    const expressions = (0, _selectors.getExpressions)(getState()).toJS();
    const inputs = expressions.map(({ input }) => input);
    const frameId = (0, _selectors.getSelectedFrameId)(getState(), cx.thread);
    const results = await client.evaluateExpressions(inputs, {
      frameId,
      thread: cx.thread
    });
    dispatch({ type: "EVALUATE_EXPRESSIONS", cx, inputs, results });
  };
}

function evaluateExpression(cx, expression) {
  return async function ({ dispatch, getState, client, sourceMaps }) {
    if (!expression.input) {
      console.warn("Expressions should not be empty");
      return;
    }

    let input = expression.input;
    const frame = (0, _selectors.getSelectedFrame)(getState(), cx.thread);

    if (frame) {
      const { location } = frame;
      const source = (0, _selectors.getSourceFromId)(getState(), location.sourceId);

      const selectedSource = (0, _selectors.getSelectedSource)(getState());

      if (selectedSource && (0, _source.isOriginal)(source) && (0, _source.isOriginal)(selectedSource)) {
        const mapResult = await dispatch(getMappedExpression(input));
        if (mapResult) {
          input = mapResult.expression;
        }
      }
    }

    const frameId = (0, _selectors.getSelectedFrameId)(getState(), cx.thread);

    return dispatch({
      type: "EVALUATE_EXPRESSION",
      cx,
      thread: cx.thread,
      input: expression.input,
      [_promise.PROMISE]: client.evaluateInFrame((0, _expressions.wrapExpression)(input), {
        frameId,
        thread: cx.thread
      })
    });
  };
}

/**
 * Gets information about original variable names from the source map
 * and replaces all posible generated names.
 */
function getMappedExpression(expression) {
  return async function ({ dispatch, getState, client, sourceMaps }) {
    const thread = (0, _selectors.getCurrentThread)(getState());
    const mappings = (0, _selectors.getSelectedScopeMappings)(getState(), thread);
    const bindings = (0, _selectors.getSelectedFrameBindings)(getState(), thread);

    // We bail early if we do not need to map the expression. This is important
    // because mapping an expression can be slow if the parser worker is
    // busy doing other work.
    //
    // 1. there are no mappings - we do not need to map original expressions
    // 2. does not contain `await` - we do not need to map top level awaits
    // 3. does not contain `=` - we do not need to map assignments
    const shouldMapScopes = (0, _selectors.isMapScopesEnabled)(getState()) && mappings;
    if (!shouldMapScopes && !expression.match(/(await|=)/)) {
      return null;
    }

    return parser.mapExpression(expression, mappings, bindings || [], _prefs.features.mapExpressionBindings && (0, _selectors.getIsPaused)(getState(), thread), _prefs.features.mapAwaitExpression);
  };
}

/***/ }),
/* 512 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.copyToTheClipboard = copyToTheClipboard;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/**
 * Clipboard function taken from
 * https://dxr.mozilla.org/mozilla-central/source/devtools/shared/platform/content/clipboard.js
 */

function copyToTheClipboard(string) {
  const doCopy = function (e) {
    e.clipboardData.setData("text/plain", string);
    e.preventDefault();
  };

  document.addEventListener("copy", doCopy);
  document.execCommand("copy", false, null);
  document.removeEventListener("copy", doCopy);
}

/***/ }),
/* 513 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _lodash = __webpack_require__(417);

let newQueuedSources; /* This Source Code Form is subject to the terms of the Mozilla Public
                       * License, v. 2.0. If a copy of the MPL was not distributed with this
                       * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

let queuedSources;
let currentWork;

async function dispatchNewSources() {
  const sources = queuedSources;
  queuedSources = [];
  currentWork = await newQueuedSources(sources);
}

const queue = (0, _lodash.throttle)(dispatchNewSources, 100);

exports.default = {
  initialize: actions => {
    newQueuedSources = actions.newQueuedSources;
    queuedSources = [];
  },
  queue: source => {
    queuedSources.push(source);
    queue();
  },
  queueSources: sources => {
    if (sources.length > 0) {
      queuedSources = queuedSources.concat(sources);
      queue();
    }
  },

  flush: () => Promise.all([queue.flush(), currentWork]),
  clear: () => {
    queuedSources = [];
    queue.cancel();
  }
};

/***/ }),
/* 514 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatKeyShortcut = formatKeyShortcut;
exports.truncateMiddleText = truncateMiddleText;

var _devtoolsServices = __webpack_require__(37);

var _devtoolsServices2 = _interopRequireDefault(_devtoolsServices);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const { appinfo } = _devtoolsServices2.default; /* This Source Code Form is subject to the terms of the Mozilla Public
                                                 * License, v. 2.0. If a copy of the MPL was not distributed with this
                                                 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/**
 * Utils for keyboard command strings
 * @module utils/text
 */


const isMacOS = appinfo.OS === "Darwin";

/**
 * Formats key for use in tooltips
 * For macOS we use the following unicode
 *
 * cmd ⌘ = \u2318
 * shift ⇧ – \u21E7
 * option (alt) ⌥ \u2325
 *
 * For Win/Lin this replaces CommandOrControl or CmdOrCtrl with Ctrl
 *
 * @memberof utils/text
 * @static
 */
function formatKeyShortcut(shortcut) {
  if (isMacOS) {
    return shortcut.replace(/Shift\+/g, "\u21E7").replace(/Command\+|Cmd\+/g, "\u2318").replace(/CommandOrControl\+|CmdOrCtrl\+/g, "\u2318").replace(/Alt\+/g, "\u2325");
  }
  return shortcut.replace(/CommandOrControl\+|CmdOrCtrl\+/g, `${L10N.getStr("ctrl")}+`).replace(/Shift\+/g, "Shift+");
}

/**
 * Truncates the received text to the maxLength in the format:
 * Original: 'this is a very long text and ends here'
 * Truncated: 'this is a ver...and ends here'
 * @param {String} sourceText - Source text
 * @param {Number} maxLength - Max allowed length
 * @memberof utils/text
 * @static
 */
function truncateMiddleText(sourceText, maxLength) {
  let truncatedText = sourceText;
  if (sourceText.length > maxLength) {
    truncatedText = `${sourceText.substring(0, Math.round(maxLength / 2) - 2)}…${sourceText.substring(sourceText.length - Math.round(maxLength / 2 - 1))}`;
  }
  return truncatedText;
}

/***/ }),
/* 515 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parse = undefined;

var _lodash = __webpack_require__(417);

const defaultUrl = {
  hash: "",
  host: "",
  hostname: "",
  href: "",
  origin: "null",
  password: "",
  path: "",
  pathname: "",
  port: "",
  protocol: "",
  search: "",
  // This should be a "URLSearchParams" object
  searchParams: {},
  username: ""
}; /* This Source Code Form is subject to the terms of the Mozilla Public
    * License, v. 2.0. If a copy of the MPL was not distributed with this
    * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const parse = exports.parse = (0, _lodash.memoize)(function parse(url) {
  try {
    const urlObj = new URL(url);
    urlObj.path = urlObj.pathname + urlObj.search;
    return urlObj;
  } catch (err) {
    // If we're given simply a filename...
    if (url) {
      return { ...defaultUrl, path: url, pathname: url };
    }

    return defaultUrl;
  }
});

/***/ }),
/* 516 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getWasmText = getWasmText;
exports.getWasmLineNumberFormatter = getWasmLineNumberFormatter;
exports.isWasm = isWasm;
exports.lineToWasmOffset = lineToWasmOffset;
exports.wasmOffsetToLine = wasmOffsetToLine;
exports.clearWasmStates = clearWasmStates;
exports.renderWasmText = renderWasmText;

var _WasmParser = __webpack_require__(622);

var _WasmDis = __webpack_require__(623);

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

var wasmStates = Object.create(null);

function maybeWasmSectionNameResolver(data) {
  try {
    const parser = new _WasmParser.BinaryReader();
    parser.setData(data.buffer, 0, data.length);
    const reader = new _WasmDis.NameSectionReader();
    reader.read(parser);
    return reader.hasValidNames() ? reader.getNameResolver() : null;
  } catch (ex) {
    // Ignoring any errors during names section retrival.
    return null;
  }
}

/**
 * @memberof utils/wasm
 * @static
 */
function getWasmText(sourceId, data) {
  const nameResolver = maybeWasmSectionNameResolver(data);
  const parser = new _WasmParser.BinaryReader();
  parser.setData(data.buffer, 0, data.length);
  const dis = new _WasmDis.WasmDisassembler();
  if (nameResolver) {
    dis.nameResolver = nameResolver;
  }
  dis.addOffsets = true;
  const done = dis.disassembleChunk(parser);
  let result = dis.getResult();
  if (result.lines.length === 0) {
    result = { lines: ["No luck with wast conversion"], offsets: [0], done };
  }

  const offsets = result.offsets;
  const lines = [];
  for (let i = 0; i < offsets.length; i++) {
    lines[offsets[i]] = i;
  }

  wasmStates[sourceId] = { offsets, lines };

  return { lines: result.lines, done: result.done };
}

/**
 * @memberof utils/wasm
 * @static
 */
function getWasmLineNumberFormatter(sourceId) {
  const codeOf0 = 48,
        codeOfA = 65;
  const buffer = [codeOf0, codeOf0, codeOf0, codeOf0, codeOf0, codeOf0, codeOf0, codeOf0];
  let last0 = 7;
  return function (number) {
    const offset = lineToWasmOffset(sourceId, number - 1);
    if (offset == undefined) {
      return "";
    }
    let i = 7;
    for (let n = offset; n !== 0 && i >= 0; n >>= 4, i--) {
      const nibble = n & 15;
      buffer[i] = nibble < 10 ? codeOf0 + nibble : codeOfA - 10 + nibble;
    }
    for (let j = i; j > last0; j--) {
      buffer[j] = codeOf0;
    }
    last0 = i;
    return String.fromCharCode.apply(null, buffer);
  };
}

/**
 * @memberof utils/wasm
 * @static
 */
function isWasm(sourceId) {
  return sourceId in wasmStates;
}

/**
 * @memberof utils/wasm
 * @static
 */
function lineToWasmOffset(sourceId, number) {
  const wasmState = wasmStates[sourceId];
  if (!wasmState) {
    return undefined;
  }
  let offset = wasmState.offsets[number];
  while (offset === undefined && number > 0) {
    offset = wasmState.offsets[--number];
  }
  return offset;
}

/**
 * @memberof utils/wasm
 * @static
 */
function wasmOffsetToLine(sourceId, offset) {
  const wasmState = wasmStates[sourceId];
  if (!wasmState) {
    return undefined;
  }
  return wasmState.lines[offset];
}

/**
 * @memberof utils/wasm
 * @static
 */
function clearWasmStates() {
  wasmStates = Object.create(null);
}

const wasmLines = new WeakMap();
function renderWasmText(sourceId, content) {
  if (wasmLines.has(content)) {
    return wasmLines.get(content) || [];
  }

  // binary does not survive as Uint8Array, converting from string
  const { binary } = content.value;
  const data = new Uint8Array(binary.length);
  for (let i = 0; i < data.length; i++) {
    data[i] = binary.charCodeAt(i);
  }
  const { lines } = getWasmText(sourceId, data);
  const MAX_LINES = 1000000;
  if (lines.length > MAX_LINES) {
    lines.splice(MAX_LINES, lines.length - MAX_LINES);
    lines.push(";; .... text is truncated due to the size");
  }

  wasmLines.set(content, lines);
  return lines;
}

/***/ }),
/* 517 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_517__;

/***/ }),
/* 518 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initialBreakpointsState = initialBreakpointsState;
exports.getBreakpointsMap = getBreakpointsMap;
exports.getBreakpointsList = getBreakpointsList;
exports.getBreakpointCount = getBreakpointCount;
exports.getBreakpoint = getBreakpoint;
exports.getBreakpointsDisabled = getBreakpointsDisabled;
exports.getBreakpointsForSource = getBreakpointsForSource;
exports.getBreakpointForLocation = getBreakpointForLocation;
exports.getHiddenBreakpoint = getHiddenBreakpoint;

var _devtoolsSourceMap = __webpack_require__(182);

var _lodash = __webpack_require__(417);

var _breakpoint = __webpack_require__(499);

var _breakpoints = __webpack_require__(579);

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/**
 * Breakpoints reducer
 * @module reducers/breakpoints
 */

function initialBreakpointsState(xhrBreakpoints = []) {
  return {
    breakpoints: {},
    xhrBreakpoints: xhrBreakpoints,
    breakpointsDisabled: false
  };
}

// eslint-disable-next-line max-len


function update(state = initialBreakpointsState(), action) {
  switch (action.type) {
    case "SET_BREAKPOINT":
      {
        return setBreakpoint(state, action);
      }

    case "REMOVE_BREAKPOINT":
      {
        return removeBreakpoint(state, action);
      }

    case "NAVIGATE":
      {
        return initialBreakpointsState(state.xhrBreakpoints);
      }

    case "SET_XHR_BREAKPOINT":
      {
        return addXHRBreakpoint(state, action);
      }

    case "REMOVE_XHR_BREAKPOINT":
      {
        return removeXHRBreakpoint(state, action);
      }

    case "UPDATE_XHR_BREAKPOINT":
      {
        return updateXHRBreakpoint(state, action);
      }

    case "ENABLE_XHR_BREAKPOINT":
      {
        return updateXHRBreakpoint(state, action);
      }

    case "DISABLE_XHR_BREAKPOINT":
      {
        return updateXHRBreakpoint(state, action);
      }
  }

  return state;
}

function addXHRBreakpoint(state, action) {
  const { xhrBreakpoints } = state;
  const { breakpoint } = action;
  const { path, method } = breakpoint;

  const existingBreakpointIndex = state.xhrBreakpoints.findIndex(bp => bp.path === path && bp.method === method);

  if (existingBreakpointIndex === -1) {
    return {
      ...state,
      xhrBreakpoints: [...xhrBreakpoints, breakpoint]
    };
  } else if (xhrBreakpoints[existingBreakpointIndex] !== breakpoint) {
    const newXhrBreakpoints = [...xhrBreakpoints];
    newXhrBreakpoints[existingBreakpointIndex] = breakpoint;
    return {
      ...state,
      xhrBreakpoints: newXhrBreakpoints
    };
  }

  return state;
}

function removeXHRBreakpoint(state, action) {
  const { breakpoint } = action;
  const { xhrBreakpoints } = state;

  if (action.status === "start") {
    return state;
  }

  return {
    ...state,
    xhrBreakpoints: xhrBreakpoints.filter(bp => !(0, _lodash.isEqual)(bp, breakpoint))
  };
}

function updateXHRBreakpoint(state, action) {
  const { breakpoint, index } = action;
  const { xhrBreakpoints } = state;
  const newXhrBreakpoints = [...xhrBreakpoints];
  newXhrBreakpoints[index] = breakpoint;
  return {
    ...state,
    xhrBreakpoints: newXhrBreakpoints
  };
}

function setBreakpoint(state, { breakpoint }) {
  const id = (0, _breakpoint.makeBreakpointId)(breakpoint.location);
  const breakpoints = { ...state.breakpoints, [id]: breakpoint };
  return { ...state, breakpoints };
}

function removeBreakpoint(state, { location }) {
  const id = (0, _breakpoint.makeBreakpointId)(location);
  const breakpoints = { ...state.breakpoints };
  delete breakpoints[id];
  return { ...state, breakpoints };
}

function isMatchingLocation(location1, location2) {
  return (0, _lodash.isEqual)(location1, location2);
}

// Selectors
// TODO: these functions should be moved out of the reducer

function getBreakpointsMap(state) {
  return state.breakpoints.breakpoints;
}

function getBreakpointsList(state) {
  return (0, _breakpoints.getBreakpointsList)(state);
}

function getBreakpointCount(state) {
  return getBreakpointsList(state).length;
}

function getBreakpoint(state, location) {
  const breakpoints = getBreakpointsMap(state);
  return breakpoints[(0, _breakpoint.makeBreakpointId)(location)];
}

function getBreakpointsDisabled(state) {
  const breakpoints = getBreakpointsList(state);
  return breakpoints.every(breakpoint => breakpoint.disabled);
}

function getBreakpointsForSource(state, sourceId, line) {
  if (!sourceId) {
    return [];
  }

  const isGeneratedSource = (0, _devtoolsSourceMap.isGeneratedId)(sourceId);
  const breakpoints = getBreakpointsList(state);
  return breakpoints.filter(bp => {
    const location = isGeneratedSource ? bp.generatedLocation : bp.location;
    return location.sourceId === sourceId && (!line || line == location.line);
  });
}

function getBreakpointForLocation(state, location) {
  if (!location || !location.sourceId) {
    return undefined;
  }

  const isGeneratedSource = (0, _devtoolsSourceMap.isGeneratedId)(location.sourceId);
  return getBreakpointsList(state).find(bp => {
    const loc = isGeneratedSource ? bp.generatedLocation : bp.location;
    return isMatchingLocation(loc, location);
  });
}

function getHiddenBreakpoint(state) {
  const breakpoints = getBreakpointsList(state);
  return breakpoints.find(bp => bp.options.hidden);
}

exports.default = update;

/***/ }),
/* 519 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findBestMatchExpression = findBestMatchExpression;
exports.containsPosition = containsPosition;
exports.findClosestFunction = findClosestFunction;
exports.findClosestClass = findClosestClass;
function findBestMatchExpression(symbols, tokenPos) {
  if (symbols.loading) {
    return null;
  }

  const { line, column } = tokenPos;
  const { memberExpressions, identifiers, literals } = symbols;
  const members = memberExpressions.filter(({ computed }) => !computed);

  return [].concat(identifiers, members, literals).reduce((found, expression) => {
    const overlaps = expression.location.start.line == line && expression.location.start.column <= column && expression.location.end.column >= column;

    if (overlaps) {
      return expression;
    }

    return found;
  }, null);
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function containsPosition(a, b) {
  const startsBefore = a.start.line < b.line || a.start.line === b.line && a.start.column <= b.column;
  const endsAfter = a.end.line > b.line || a.end.line === b.line && a.end.column >= b.column;

  return startsBefore && endsAfter;
}

function findClosestofSymbol(declarations, location) {
  if (!declarations) {
    return null;
  }

  return declarations.reduce((found, currNode) => {
    if (currNode.name === "anonymous" || !containsPosition(currNode.location, {
      line: location.line,
      column: location.column || 0
    })) {
      return found;
    }

    if (!found) {
      return currNode;
    }

    if (found.location.start.line > currNode.location.start.line) {
      return found;
    }
    if (found.location.start.line === currNode.location.start.line && found.location.start.column > currNode.location.start.column) {
      return found;
    }

    return currNode;
  }, null);
}

function findClosestFunction(symbols, location) {
  if (!symbols || symbols.loading) {
    return null;
  }

  return findClosestofSymbol(symbols.functions, location);
}

function findClosestClass(symbols, location) {
  if (!symbols || symbols.loading) {
    return null;
  }

  return findClosestofSymbol(symbols.classes, location);
}

/***/ }),
/* 520 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.recordEvent = recordEvent;

var _devtoolsModules = __webpack_require__(183);

var _devtoolsEnvironment = __webpack_require__(102);

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/**
 * Usage:
 *
 * import { recordEvent } from "src/utils/telemetry";
 *
 * // Event without extra properties
 * recordEvent("add_breakpoint");
 *
 * // Event with extra properties
 * recordEvent("pause", {
 *   "reason": "debugger-statement",
 *   "collapsed_callstacks": 1
 * });
 *
 * // If the properties are in multiple code paths and you can't send them all
 * // in one go you will need to use the full telemetry API.
 *
 * import { Telemetry } from "devtools-modules";
 *
 * const telemetry = new Telemetry();
 *
 * // Prepare the event and define which properties to expect.
 * //
 * // NOTE: You CAN send properties before preparing the event.
 * //
 *  telemetry.preparePendingEvent(this, "pause", "debugger", null, [
 *   "reason", "collapsed_callstacks"
 * ]);
 *
 * // Elsewhere in another codepath send the reason property
 * telemetry.addEventProperty(
 *   this, "pause", "debugger", null, "reason", "debugger-statement"
 * );
 *
 * // Elsewhere in another codepath send the collapsed_callstacks property
 * telemetry.addEventProperty(
 *   this, "pause", "debugger", null, "collapsed_callstacks", 1
 * );
 */

const telemetry = new _devtoolsModules.Telemetry();

/**
 * @memberof utils/telemetry
 * @static
 */
function recordEvent(eventName, fields = {}) {
  let sessionId = -1;

  if (typeof window !== "object") {
    return;
  }

  if (window.parent.frameElement) {
    sessionId = window.parent.frameElement.getAttribute("session_id");
  }

  /* eslint-disable camelcase */
  telemetry.recordEvent(eventName, "debugger", null, {
    session_id: sessionId,
    ...fields
  });
  /* eslint-enable camelcase */

  if (!(0, _devtoolsEnvironment.isFirefoxPanel)() && window.dbg) {
    const events = window.dbg._telemetry.events;
    if (!events[eventName]) {
      events[eventName] = [];
    }
    events[eventName].push(fields);
  }
}

/***/ }),
/* 521 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setSymbols = undefined;

var _selectors = __webpack_require__(490);

var _promise = __webpack_require__(500);

var _tabs = __webpack_require__(547);

var _loadSourceText = __webpack_require__(507);

var _parser = __webpack_require__(503);

var parser = _interopRequireWildcard(_parser);

var _memoizableAction = __webpack_require__(546);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

async function doSetSymbols(cx, source, { dispatch, getState }) {
  const sourceId = source.id;

  await dispatch((0, _loadSourceText.loadSourceText)({ cx, source }));

  await dispatch({
    type: "SET_SYMBOLS",
    cx,
    sourceId,
    [_promise.PROMISE]: parser.getSymbols(sourceId)
  });

  const symbols = (0, _selectors.getSymbols)(getState(), source);
  if (symbols && symbols.framework) {
    dispatch((0, _tabs.updateTab)(source, symbols.framework));
  }

  return symbols;
}

const setSymbols = exports.setSymbols = (0, _memoizableAction.memoizeableAction)("setSymbols", {
  exitEarly: ({ source }) => source.isWasm,
  hasValue: ({ source }, { getState }) => (0, _selectors.hasSymbols)(getState(), source),
  getValue: ({ source }, { getState }) => (0, _selectors.getSymbols)(getState(), source),
  createKey: ({ source }) => source.id,
  action: ({ cx, source }, thunkArgs) => doSetSymbols(cx, source, thunkArgs)
});

/***/ }),
/* 522 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.locColumn = locColumn;
function locColumn(loc) {
  if (typeof loc.column !== "number") {
    // This shouldn't really happen with locations from the AST, but
    // the datatype we are using allows null/undefined column.
    return 0;
  }

  return loc.column;
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/***/ }),
/* 523 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.disableBreakpointsOnLineItem = exports.enableBreakpointsOnLineItem = exports.removeBreakpointsOnLineItem = exports.toggleDisabledBreakpointItem = exports.logPointItem = exports.editLogPointItem = exports.addLogPointItem = exports.conditionalBreakpointItem = exports.editConditionalBreakpointItem = exports.addConditionalBreakpointItem = exports.removeBreakpointItem = exports.addBreakpointItem = undefined;
exports.breakpointItems = breakpointItems;
exports.createBreakpointItems = createBreakpointItems;
exports.breakpointItemActions = breakpointItemActions;

var _actions = __webpack_require__(493);

var _actions2 = _interopRequireDefault(_actions);

var _redux = __webpack_require__(517);

var _prefs = __webpack_require__(492);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const addBreakpointItem = exports.addBreakpointItem = (cx, location, breakpointActions) => ({
  id: "node-menu-add-breakpoint",
  label: L10N.getStr("editor.addBreakpoint"),
  accesskey: L10N.getStr("shortcuts.toggleBreakpoint.accesskey"),
  disabled: false,
  click: () => breakpointActions.addBreakpoint(cx, location),
  accelerator: L10N.getStr("toggleBreakpoint.key")
}); /* This Source Code Form is subject to the terms of the Mozilla Public
     * License, v. 2.0. If a copy of the MPL was not distributed with this
     * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const removeBreakpointItem = exports.removeBreakpointItem = (cx, breakpoint, breakpointActions) => ({
  id: "node-menu-remove-breakpoint",
  label: L10N.getStr("editor.removeBreakpoint"),
  accesskey: L10N.getStr("shortcuts.toggleBreakpoint.accesskey"),
  disabled: false,
  click: () => breakpointActions.removeBreakpoint(cx, breakpoint),
  accelerator: L10N.getStr("toggleBreakpoint.key")
});

const addConditionalBreakpointItem = exports.addConditionalBreakpointItem = (location, breakpointActions) => ({
  id: "node-menu-add-conditional-breakpoint",
  label: L10N.getStr("editor.addConditionBreakpoint"),
  accelerator: L10N.getStr("toggleCondPanel.breakpoint.key"),
  accesskey: L10N.getStr("editor.addConditionBreakpoint.accesskey"),
  disabled: false,
  click: () => breakpointActions.openConditionalPanel(location)
});

const editConditionalBreakpointItem = exports.editConditionalBreakpointItem = (location, breakpointActions) => ({
  id: "node-menu-edit-conditional-breakpoint",
  label: L10N.getStr("editor.editConditionBreakpoint"),
  accelerator: L10N.getStr("toggleCondPanel.breakpoint.key"),
  accesskey: L10N.getStr("editor.addConditionBreakpoint.accesskey"),
  disabled: false,
  click: () => breakpointActions.openConditionalPanel(location)
});

const conditionalBreakpointItem = exports.conditionalBreakpointItem = (breakpoint, breakpointActions) => {
  const {
    options: { condition },
    location
  } = breakpoint;
  return condition ? editConditionalBreakpointItem(location, breakpointActions) : addConditionalBreakpointItem(location, breakpointActions);
};

const addLogPointItem = exports.addLogPointItem = (location, breakpointActions) => ({
  id: "node-menu-add-log-point",
  label: L10N.getStr("editor.addLogPoint"),
  accesskey: L10N.getStr("editor.addLogPoint.accesskey"),
  disabled: false,
  click: () => breakpointActions.openConditionalPanel(location, true),
  accelerator: L10N.getStr("toggleCondPanel.logPoint.key")
});

const editLogPointItem = exports.editLogPointItem = (location, breakpointActions) => ({
  id: "node-menu-edit-log-point",
  label: L10N.getStr("editor.editLogPoint"),
  accesskey: L10N.getStr("editor.editLogPoint.accesskey"),
  disabled: false,
  click: () => breakpointActions.openConditionalPanel(location, true),
  accelerator: L10N.getStr("toggleCondPanel.logPoint.key")
});

const logPointItem = exports.logPointItem = (breakpoint, breakpointActions) => {
  const {
    options: { logValue },
    location
  } = breakpoint;
  return logValue ? editLogPointItem(location, breakpointActions) : addLogPointItem(location, breakpointActions);
};

const toggleDisabledBreakpointItem = exports.toggleDisabledBreakpointItem = (cx, breakpoint, breakpointActions) => {
  return {
    accesskey: L10N.getStr("editor.disableBreakpoint.accesskey"),
    disabled: false,
    click: () => breakpointActions.toggleDisabledBreakpoint(cx, breakpoint),
    ...(breakpoint.disabled ? {
      id: "node-menu-enable-breakpoint",
      label: L10N.getStr("editor.enableBreakpoint")
    } : {
      id: "node-menu-disable-breakpoint",
      label: L10N.getStr("editor.disableBreakpoint")
    })
  };
};

function breakpointItems(cx, breakpoint, breakpointActions) {
  const items = [removeBreakpointItem(cx, breakpoint, breakpointActions), toggleDisabledBreakpointItem(cx, breakpoint, breakpointActions)];

  if (_prefs.features.columnBreakpoints) {
    items.push({ type: "separator" }, removeBreakpointsOnLineItem(cx, breakpoint.location, breakpointActions), breakpoint.disabled ? enableBreakpointsOnLineItem(cx, breakpoint.location, breakpointActions) : disableBreakpointsOnLineItem(cx, breakpoint.location, breakpointActions), { type: "separator" });
  }

  items.push(conditionalBreakpointItem(breakpoint, breakpointActions));

  if (_prefs.features.logPoints) {
    items.push(logPointItem(breakpoint, breakpointActions));
  }

  return items;
}

function createBreakpointItems(cx, location, breakpointActions) {
  const items = [addBreakpointItem(cx, location, breakpointActions), addConditionalBreakpointItem(location, breakpointActions)];

  if (_prefs.features.logPoints) {
    items.push(addLogPointItem(location, breakpointActions));
  }
  return items;
}

// ToDo: Only enable if there are more than one breakpoints on a line?
const removeBreakpointsOnLineItem = exports.removeBreakpointsOnLineItem = (cx, location, breakpointActions) => ({
  id: "node-menu-remove-breakpoints-on-line",
  label: L10N.getStr("breakpointMenuItem.removeAllAtLine.label"),
  accesskey: L10N.getStr("breakpointMenuItem.removeAllAtLine.accesskey"),
  disabled: false,
  click: () => breakpointActions.removeBreakpointsAtLine(cx, location.sourceId, location.line)
});

const enableBreakpointsOnLineItem = exports.enableBreakpointsOnLineItem = (cx, location, breakpointActions) => ({
  id: "node-menu-remove-breakpoints-on-line",
  label: L10N.getStr("breakpointMenuItem.enableAllAtLine.label"),
  accesskey: L10N.getStr("breakpointMenuItem.enableAllAtLine.accesskey"),
  disabled: false,
  click: () => breakpointActions.enableBreakpointsAtLine(cx, location.sourceId, location.line)
});

const disableBreakpointsOnLineItem = exports.disableBreakpointsOnLineItem = (cx, location, breakpointActions) => ({
  id: "node-menu-remove-breakpoints-on-line",
  label: L10N.getStr("breakpointMenuItem.disableAllAtLine.label"),
  accesskey: L10N.getStr("breakpointMenuItem.disableAllAtLine.accesskey"),
  disabled: false,
  click: () => breakpointActions.disableBreakpointsAtLine(cx, location.sourceId, location.line)
});

function breakpointItemActions(dispatch) {
  return (0, _redux.bindActionCreators)({
    addBreakpoint: _actions2.default.addBreakpoint,
    removeBreakpoint: _actions2.default.removeBreakpoint,
    removeBreakpointsAtLine: _actions2.default.removeBreakpointsAtLine,
    enableBreakpointsAtLine: _actions2.default.enableBreakpointsAtLine,
    disableBreakpointsAtLine: _actions2.default.disableBreakpointsAtLine,
    disableBreakpoint: _actions2.default.disableBreakpoint,
    toggleDisabledBreakpoint: _actions2.default.toggleDisabledBreakpoint,
    toggleBreakpointsAtLine: _actions2.default.toggleBreakpointsAtLine,
    openConditionalPanel: _actions2.default.openConditionalPanel
  }, dispatch);
}

/***/ }),
/* 524 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.handleError = handleError;
exports.promisify = promisify;
exports.endTruncateStr = endTruncateStr;
exports.waitForMs = waitForMs;
exports.downloadFile = downloadFile;


/**
 * Utils for utils, by utils
 * @module utils/utils
 */

/**
 * @memberof utils/utils
 * @static
 */
function handleError(err) {
  console.log("ERROR: ", err);
}

/**
 * @memberof utils/utils
 * @static
 */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function promisify(context, method, ...args) {
  return new Promise((resolve, reject) => {
    args.push(response => {
      if (response.error) {
        reject(response);
      } else {
        resolve(response);
      }
    });
    method.apply(context, args);
  });
}

/**
 * @memberof utils/utils
 * @static
 */
function endTruncateStr(str, size) {
  if (str.length > size) {
    return `…${str.slice(str.length - size)}`;
  }
  return str;
}

function waitForMs(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function downloadFile(content, fileName) {
  if (content.type !== "text") {
    return;
  }

  const data = content.value;
  const { body } = document;
  if (!body) {
    return;
  }

  const a = document.createElement("a");
  body.appendChild(a);
  a.className = "download-anchor";
  a.href = window.URL.createObjectURL(new Blob([data], { type: "text/javascript" }));
  a.setAttribute("download", fileName);
  a.click();
  body.removeChild(a);
}

/***/ }),
/* 525 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isVisible = isVisible;
exports.getLineNumberWidth = getLineNumberWidth;
exports.resizeBreakpointGutter = resizeBreakpointGutter;
exports.resizeToggleButton = resizeToggleButton;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */


/* Checks to see if the root element is available and
 * if the element is visible. We check the width of the element
 * because it is more reliable than either checking a focus state or
 * the visibleState or hidden property.
 */
function isVisible() {
  const el = document.querySelector("#mount");
  return el && el.getBoundingClientRect().width;
}

/* Gets the line numbers width in the code editor
 */
function getLineNumberWidth(editor) {
  const gutters = editor.display.gutters;
  const lineNumbers = gutters.querySelector(".CodeMirror-linenumbers");
  return lineNumbers && lineNumbers.clientWidth;
}

/**
 * Forces the breakpoint gutter to be the same size as the line
 * numbers gutter. Editor CSS will absolutely position the gutter
 * beneath the line numbers. This makes it easy to be flexible with
 * how we overlay breakpoints.
 */
function resizeBreakpointGutter(editor) {
  const gutters = editor.display.gutters;
  const breakpoints = gutters.querySelector(".breakpoints");
  if (breakpoints) {
    breakpoints.style.width = `${getLineNumberWidth(editor)}px`;
  }
}

/**
 * Forces the left toggle button in source header to be the same size
 * as the line numbers gutter.
 */
function resizeToggleButton(editor) {
  const toggleButton = document.querySelector(".source-header .toggle-button-start");
  if (toggleButton) {
    toggleButton.style.width = `${getLineNumberWidth(editor)}px`;
  }
}

/***/ }),
/* 526 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _addToTree = __webpack_require__(563);

Object.defineProperty(exports, "addToTree", {
  enumerable: true,
  get: function () {
    return _addToTree.addToTree;
  }
});

var _collapseTree = __webpack_require__(565);

Object.defineProperty(exports, "collapseTree", {
  enumerable: true,
  get: function () {
    return _collapseTree.collapseTree;
  }
});

var _formatTree = __webpack_require__(627);

Object.defineProperty(exports, "formatTree", {
  enumerable: true,
  get: function () {
    return _formatTree.formatTree;
  }
});

var _getDirectories = __webpack_require__(628);

Object.defineProperty(exports, "getDirectories", {
  enumerable: true,
  get: function () {
    return _getDirectories.getDirectories;
  }
});

var _getURL = __webpack_require__(541);

Object.defineProperty(exports, "getFilenameFromPath", {
  enumerable: true,
  get: function () {
    return _getURL.getFilenameFromPath;
  }
});
Object.defineProperty(exports, "getURL", {
  enumerable: true,
  get: function () {
    return _getURL.getURL;
  }
});

var _sortTree = __webpack_require__(629);

Object.defineProperty(exports, "sortTree", {
  enumerable: true,
  get: function () {
    return _sortTree.sortTree;
  }
});

var _updateTree = __webpack_require__(630);

Object.defineProperty(exports, "createTree", {
  enumerable: true,
  get: function () {
    return _updateTree.createTree;
  }
});
Object.defineProperty(exports, "updateTree", {
  enumerable: true,
  get: function () {
    return _updateTree.updateTree;
  }
});

var _utils = __webpack_require__(506);

Object.keys(_utils).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _utils[key];
    }
  });
});

/***/ }),
/* 527 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _immutable = __webpack_require__(543);

var I = _interopRequireWildcard(_immutable);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Make an immutable record type
 *
 * @param spec - the keys and their default values
 * @return a state record factory function
 * @memberof utils/makeRecord
 * @static
 */


/**
 * @memberof utils/makeRecord
 * @static
 */
function makeRecord(spec) {
  return I.Record(spec);
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/**
 * When Flow 0.29 is released (very soon), we can use this Record type
 * instead of the builtin immutable.js Record type. This is better
 * because all the fields are actually typed, unlike the builtin one.
 * This depends on a performance fix that will go out in 0.29 though;
 * @module utils/makeRecord
 */

exports.default = makeRecord;

/***/ }),
/* 528 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.strictEqual = strictEqual;
exports.shallowEqual = shallowEqual;
exports.arrayShallowEqual = arrayShallowEqual;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function strictEqual(value, other) {
  return value === other;
}

function shallowEqual(value, other) {
  return value === other || Array.isArray(value) && Array.isArray(other) && arrayShallowEqual(value, other) || isObject(value) && isObject(other) && objectShallowEqual(value, other);
}

function arrayShallowEqual(value, other) {
  return value.length === other.length && value.every((k, i) => k === other[i]);
}

function objectShallowEqual(value, other) {
  const existingKeys = Object.keys(other);
  const keys = Object.keys(value);

  return keys.length === existingKeys.length && keys.every((k, i) => k === existingKeys[i]) && keys.every(k => value[k] === other[k]);
}

function isObject(value) {
  return typeof value === "object" && !!value;
}

/***/ }),
/* 529 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = update;
exports.resourceAsSourceActor = resourceAsSourceActor;
exports.stringToSourceActorId = stringToSourceActorId;
exports.hasSourceActor = hasSourceActor;
exports.getSourceActor = getSourceActor;
exports.getSourceActors = getSourceActors;
exports.getSourceActorsForThread = getSourceActorsForThread;
exports.getThreadsBySource = getThreadsBySource;

var _resource = __webpack_require__(570);

const initial = (0, _resource.createInitial)(); /* This Source Code Form is subject to the terms of the Mozilla Public
                                                 * License, v. 2.0. If a copy of the MPL was not distributed with this
                                                 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function update(state = initial, action) {
  switch (action.type) {
    case "INSERT_SOURCE_ACTORS":
      {
        const { items } = action;
        state = (0, _resource.insertResources)(state, items);
        break;
      }
    case "REMOVE_SOURCE_ACTORS":
      {
        const { items } = action;
        state = (0, _resource.removeResources)(state, items);
        break;
      }

    case "NAVIGATE":
      {
        state = initial;
        break;
      }
  }

  return state;
}

function resourceAsSourceActor(r) {
  return r;
}

// Because we are using an opaque type for our source actor IDs, these
// functions are required to convert back and forth in order to get a string
// version of the IDs. That should be super rarely used, but it means that
// we can very easily see where we're relying on the string version of IDs.
function stringToSourceActorId(s) {
  return s;
}

function hasSourceActor(state, id) {
  return (0, _resource.hasResource)(state.sourceActors, id);
}

function getSourceActor(state, id) {
  return (0, _resource.getResource)(state.sourceActors, id);
}

/**
 * Get all of the source actors for a set of IDs. Caches based on the identity
 * of "ids" when possible.
 */
const querySourceActorsById = (0, _resource.makeIdQuery)(resourceAsSourceActor);

function getSourceActors(state, ids) {
  return querySourceActorsById(state.sourceActors, ids);
}

const querySourcesByThreadID = (0, _resource.makeReduceAllQuery)(resourceAsSourceActor, actors => {
  return actors.reduce((acc, actor) => {
    acc[actor.thread] = acc[actor.thread] || [];
    acc[actor.thread].push(actor);
    return acc;
  }, {});
});
function getSourceActorsForThread(state, ids) {
  const sourcesByThread = querySourcesByThreadID(state.sourceActors);

  let sources = [];
  for (const id of Array.isArray(ids) ? ids : [ids]) {
    sources = sources.concat(sourcesByThread[id] || []);
  }
  return sources;
}

const queryThreadsBySourceObject = (0, _resource.makeReduceAllQuery)(actor => ({ thread: actor.thread, source: actor.source }), actors => actors.reduce((acc, { source, thread }) => {
  let sourceThreads = acc[source];
  if (!sourceThreads) {
    sourceThreads = [];
    acc[source] = sourceThreads;
  }

  sourceThreads.push(thread);
  return acc;
}, {}));

function getThreadsBySource(state) {
  return queryThreadsBySourceObject(state.sourceActors);
}

/***/ }),
/* 530 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getContext = getContext;
exports.getThreadContext = getThreadContext;
exports.getPauseReason = getPauseReason;
exports.getPauseCommand = getPauseCommand;
exports.wasStepping = wasStepping;
exports.isStepping = isStepping;
exports.getCurrentThread = getCurrentThread;
exports.getIsPaused = getIsPaused;
exports.getPreviousPauseFrameLocation = getPreviousPauseFrameLocation;
exports.isEvaluatingExpression = isEvaluatingExpression;
exports.getIsWaitingOnBreak = getIsWaitingOnBreak;
exports.getShouldPauseOnExceptions = getShouldPauseOnExceptions;
exports.getShouldPauseOnCaughtExceptions = getShouldPauseOnCaughtExceptions;
exports.getCanRewind = getCanRewind;
exports.getFrames = getFrames;
exports.getCurrentThreadFrames = getCurrentThreadFrames;
exports.getGeneratedFrameScope = getGeneratedFrameScope;
exports.getOriginalFrameScope = getOriginalFrameScope;
exports.getFrameScopes = getFrameScopes;
exports.getSelectedFrameBindings = getSelectedFrameBindings;
exports.getFrameScope = getFrameScope;
exports.getSelectedScope = getSelectedScope;
exports.getSelectedOriginalScope = getSelectedOriginalScope;
exports.getSelectedGeneratedScope = getSelectedGeneratedScope;
exports.getSelectedScopeMappings = getSelectedScopeMappings;
exports.getSelectedFrameId = getSelectedFrameId;
exports.getTopFrame = getTopFrame;
exports.getSkipPausing = getSkipPausing;
exports.isMapScopesEnabled = isMapScopesEnabled;
exports.getChromeScopes = getChromeScopes;

var _devtoolsSourceMap = __webpack_require__(182);

var _prefs = __webpack_require__(492);

var _sources = __webpack_require__(498);

var _pause = __webpack_require__(576);

// Pause state associated with an individual thread.


// Pause state describing all threads.
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/* eslint complexity: ["error", 30]*/

/**
 * Pause reducer
 * @module reducers/pause
 */

function createPauseState(thread = "UnknownThread") {
  return {
    cx: {
      navigateCounter: 0
    },
    threadcx: {
      navigateCounter: 0,
      thread,
      isPaused: false,
      pauseCounter: 0
    },
    threads: {},
    canRewind: false,
    skipPausing: _prefs.prefs.skipPausing,
    mapScopes: _prefs.prefs.mapScopes,
    shouldPauseOnExceptions: _prefs.prefs.pauseOnExceptions,
    shouldPauseOnCaughtExceptions: _prefs.prefs.pauseOnCaughtExceptions
  };
}

const resumedPauseState = {
  frames: null,
  frameScopes: {
    generated: {},
    original: {},
    mappings: {}
  },
  selectedFrameId: null,
  why: null
};

const createInitialPauseState = () => ({
  ...resumedPauseState,
  isWaitingOnBreak: false,
  canRewind: false,
  command: null,
  lastCommand: null,
  previousLocation: null
});

function getThreadPauseState(state, thread) {
  // Thread state is lazily initialized so that we don't have to keep track of
  // the current set of worker threads.
  return state.threads[thread] || createInitialPauseState();
}

function update(state = createPauseState(), action) {
  // Actions need to specify any thread they are operating on. These helpers
  // manage updating the pause state for that thread.
  const threadState = () => {
    if (!action.thread) {
      throw new Error(`Missing thread in action ${action.type}`);
    }
    return getThreadPauseState(state, action.thread);
  };

  const updateThreadState = newThreadState => {
    if (!action.thread) {
      throw new Error(`Missing thread in action ${action.type}`);
    }
    return {
      ...state,
      threads: {
        ...state.threads,
        [action.thread]: { ...threadState(), ...newThreadState }
      }
    };
  };

  switch (action.type) {
    case "SELECT_THREAD":
      {
        return {
          ...state,
          threadcx: {
            ...state.threadcx,
            thread: action.thread,
            isPaused: !!threadState().frames,
            pauseCounter: state.threadcx.pauseCounter + 1
          }
        };
      }

    case "PAUSED":
      {
        const { thread, selectedFrameId, frames, why } = action;

        state = {
          ...state,
          threadcx: {
            ...state.threadcx,
            pauseCounter: state.threadcx.pauseCounter + 1,
            thread,
            isPaused: true
          }
        };
        return updateThreadState({
          isWaitingOnBreak: false,
          selectedFrameId,
          frames,
          frameScopes: { ...resumedPauseState.frameScopes },
          why
        });
      }

    case "MAP_FRAMES":
      {
        const { selectedFrameId, frames } = action;
        return updateThreadState({ frames, selectedFrameId });
      }

    case "ADD_SCOPES":
      {
        const { frame, status, value } = action;
        const selectedFrameId = frame.id;

        const generated = {
          ...threadState().frameScopes.generated,
          [selectedFrameId]: {
            pending: status !== "done",
            scope: value
          }
        };

        return updateThreadState({
          frameScopes: {
            ...threadState().frameScopes,
            generated
          }
        });
      }

    case "MAP_SCOPES":
      {
        const { frame, status, value } = action;
        const selectedFrameId = frame.id;

        const original = {
          ...threadState().frameScopes.original,
          [selectedFrameId]: {
            pending: status !== "done",
            scope: value && value.scope
          }
        };

        const mappings = {
          ...threadState().frameScopes.mappings,
          [selectedFrameId]: value && value.mappings
        };

        return updateThreadState({
          frameScopes: {
            ...threadState().frameScopes,
            original,
            mappings
          }
        });
      }

    case "BREAK_ON_NEXT":
      return updateThreadState({ isWaitingOnBreak: true });

    case "SELECT_FRAME":
      return updateThreadState({ selectedFrameId: action.frame.id });

    case "CONNECT":
      return {
        ...createPauseState(action.mainThread.actor),
        canRewind: action.canRewind
      };

    case "PAUSE_ON_EXCEPTIONS":
      {
        const { shouldPauseOnExceptions, shouldPauseOnCaughtExceptions } = action;

        _prefs.prefs.pauseOnExceptions = shouldPauseOnExceptions;
        _prefs.prefs.pauseOnCaughtExceptions = shouldPauseOnCaughtExceptions;

        // Preserving for the old debugger
        _prefs.prefs.ignoreCaughtExceptions = !shouldPauseOnCaughtExceptions;

        return {
          ...state,
          shouldPauseOnExceptions,
          shouldPauseOnCaughtExceptions
        };
      }

    case "COMMAND":
      if (action.status === "start") {
        return updateThreadState({
          ...resumedPauseState,
          command: action.command,
          lastCommand: action.command,
          previousLocation: getPauseLocation(threadState(), action)
        });
      }
      return updateThreadState({ command: null });

    case "RESUME":
      {
        if (action.thread == state.threadcx.thread) {
          state = {
            ...state,
            threadcx: {
              ...state.threadcx,
              pauseCounter: state.threadcx.pauseCounter + 1,
              isPaused: false
            }
          };
        }
        return updateThreadState({
          ...resumedPauseState,
          wasStepping: !!action.wasStepping
        });
      }

    case "EVALUATE_EXPRESSION":
      return updateThreadState({
        command: action.status === "start" ? "expression" : null
      });

    case "NAVIGATE":
      {
        const navigateCounter = state.cx.navigateCounter + 1;
        return {
          ...state,
          cx: {
            navigateCounter
          },
          threadcx: {
            navigateCounter,
            thread: action.mainThread.actor,
            pauseCounter: 0,
            isPaused: false
          },
          threads: {
            [action.mainThread.actor]: {
              ...state.threads[action.mainThread.actor],
              ...resumedPauseState
            }
          }
        };
      }

    case "TOGGLE_SKIP_PAUSING":
      {
        const { skipPausing } = action;
        _prefs.prefs.skipPausing = skipPausing;

        return { ...state, skipPausing };
      }

    case "TOGGLE_MAP_SCOPES":
      {
        const { mapScopes } = action;
        _prefs.prefs.mapScopes = mapScopes;
        return { ...state, mapScopes };
      }
  }

  return state;
}

function getPauseLocation(state, action) {
  const { frames, previousLocation } = state;

  // NOTE: We store the previous location so that we ensure that we
  // do not stop at the same location twice when we step over.
  if (action.command !== "stepOver") {
    return null;
  }

  const frame = frames && frames[0];
  if (!frame) {
    return previousLocation;
  }

  return {
    location: frame.location,
    generatedLocation: frame.generatedLocation
  };
}

// Selectors

function getContext(state) {
  return state.pause.cx;
}

function getThreadContext(state) {
  return state.pause.threadcx;
}

function getPauseReason(state, thread) {
  return getThreadPauseState(state.pause, thread).why;
}

function getPauseCommand(state, thread) {
  return getThreadPauseState(state.pause, thread).command;
}

function wasStepping(state, thread) {
  return getThreadPauseState(state.pause, thread).wasStepping;
}

function isStepping(state, thread) {
  return ["stepIn", "stepOver", "stepOut"].includes(getPauseCommand(state, thread));
}

function getCurrentThread(state) {
  return getThreadContext(state).thread;
}

function getIsPaused(state, thread) {
  return !!getThreadPauseState(state.pause, thread).frames;
}

function getPreviousPauseFrameLocation(state, thread) {
  return getThreadPauseState(state.pause, thread).previousLocation;
}

function isEvaluatingExpression(state, thread) {
  return getThreadPauseState(state.pause, thread).command === "expression";
}

function getIsWaitingOnBreak(state, thread) {
  return getThreadPauseState(state.pause, thread).isWaitingOnBreak;
}

function getShouldPauseOnExceptions(state) {
  return state.pause.shouldPauseOnExceptions;
}

function getShouldPauseOnCaughtExceptions(state) {
  return state.pause.shouldPauseOnCaughtExceptions;
}

function getCanRewind(state) {
  return state.pause.canRewind;
}

function getFrames(state, thread) {
  return getThreadPauseState(state.pause, thread).frames;
}

function getCurrentThreadFrames(state) {
  return getThreadPauseState(state.pause, getCurrentThread(state)).frames;
}

function getGeneratedFrameId(frameId) {
  if (frameId.includes("-originalFrame")) {
    // The mapFrames can add original stack frames -- get generated frameId.
    return frameId.substr(0, frameId.lastIndexOf("-originalFrame"));
  }
  return frameId;
}

function getGeneratedFrameScope(state, thread, frameId) {
  if (!frameId) {
    return null;
  }

  return getFrameScopes(state, thread).generated[getGeneratedFrameId(frameId)];
}

function getOriginalFrameScope(state, thread, sourceId, frameId) {
  if (!frameId || !sourceId) {
    return null;
  }

  const isGenerated = (0, _devtoolsSourceMap.isGeneratedId)(sourceId);
  const original = getFrameScopes(state, thread).original[getGeneratedFrameId(frameId)];

  if (!isGenerated && original && (original.pending || original.scope)) {
    return original;
  }

  return null;
}

function getFrameScopes(state, thread) {
  return getThreadPauseState(state.pause, thread).frameScopes;
}

function getSelectedFrameBindings(state, thread) {
  const scopes = getFrameScopes(state, thread);
  const selectedFrameId = getSelectedFrameId(state, thread);
  if (!scopes || !selectedFrameId) {
    return null;
  }

  const frameScope = scopes.generated[selectedFrameId];
  if (!frameScope || frameScope.pending) {
    return;
  }

  let currentScope = frameScope.scope;
  let frameBindings = [];
  while (currentScope && currentScope.type != "object") {
    if (currentScope.bindings) {
      const bindings = Object.keys(currentScope.bindings.variables);
      const args = [].concat(...currentScope.bindings.arguments.map(argument => Object.keys(argument)));

      frameBindings = [...frameBindings, ...bindings, ...args];
    }
    currentScope = currentScope.parent;
  }

  return frameBindings;
}

function getFrameScope(state, thread, sourceId, frameId) {
  return getOriginalFrameScope(state, thread, sourceId, frameId) || getGeneratedFrameScope(state, thread, frameId);
}

function getSelectedScope(state, thread) {
  const sourceId = (0, _sources.getSelectedSourceId)(state);
  const frameId = getSelectedFrameId(state, thread);

  const frameScope = getFrameScope(state, thread, sourceId, frameId);
  if (!frameScope) {
    return null;
  }

  return frameScope.scope || null;
}

function getSelectedOriginalScope(state, thread) {
  const sourceId = (0, _sources.getSelectedSourceId)(state);
  const frameId = getSelectedFrameId(state, thread);
  return getOriginalFrameScope(state, thread, sourceId, frameId);
}

function getSelectedGeneratedScope(state, thread) {
  const frameId = getSelectedFrameId(state, thread);
  return getGeneratedFrameScope(state, thread, frameId);
}

function getSelectedScopeMappings(state, thread) {
  const frameId = getSelectedFrameId(state, thread);
  if (!frameId) {
    return null;
  }

  return getFrameScopes(state, thread).mappings[frameId];
}

function getSelectedFrameId(state, thread) {
  return getThreadPauseState(state.pause, thread).selectedFrameId;
}

function getTopFrame(state, thread) {
  const frames = getFrames(state, thread);
  return frames && frames[0];
}

function getSkipPausing(state) {
  return state.pause.skipPausing;
}

function isMapScopesEnabled(state) {
  return state.pause.mapScopes;
}

// NOTE: currently only used for chrome
function getChromeScopes(state, thread) {
  const frame = (0, _pause.getSelectedFrame)(state, thread);
  return frame ? frame.scopeChain : undefined;
}

exports.default = update;

/***/ }),
/* 531 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDisplayName = getDisplayName;
exports.isWorker = isWorker;

var _path = __webpack_require__(578);

function getDisplayName(thread) {
  return (0, _path.basename)(thread.url);
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function isWorker(thread) {
  return thread.actor.includes("workerTarget");
}

/***/ }),
/* 532 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initialProjectTextSearchState = initialProjectTextSearchState;
exports.getTextSearchOperation = getTextSearchOperation;
exports.getTextSearchResults = getTextSearchResults;
exports.getTextSearchStatus = getTextSearchStatus;
exports.getTextSearchQuery = getTextSearchQuery;
const statusType = exports.statusType = {
  initial: "INITIAL",
  fetching: "FETCHING",
  cancelled: "CANCELLED",
  done: "DONE",
  error: "ERROR"
}; /* This Source Code Form is subject to the terms of the Mozilla Public
    * License, v. 2.0. If a copy of the MPL was not distributed with this
    * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// @format

/**
 * Project text search reducer
 * @module reducers/project-text-search
 */

function initialProjectTextSearchState() {
  return {
    query: "",
    results: [],
    ongoingSearch: null,
    status: statusType.initial
  };
}

function update(state = initialProjectTextSearchState(), action) {
  switch (action.type) {
    case "ADD_QUERY":
      return { ...state, query: action.query };

    case "ADD_SEARCH_RESULT":
      const results = state.results;
      if (action.result.matches.length === 0) {
        return state;
      }

      const result = {
        type: "RESULT",
        ...action.result,
        matches: action.result.matches.map(m => ({ type: "MATCH", ...m }))
      };
      return { ...state, results: [...results, result] };

    case "UPDATE_STATUS":
      const ongoingSearch = action.status == statusType.fetching ? state.ongoingSearch : null;
      return { ...state, status: action.status, ongoingSearch };

    case "CLEAR_SEARCH_RESULTS":
      return { ...state, results: [] };

    case "ADD_ONGOING_SEARCH":
      return { ...state, ongoingSearch: action.ongoingSearch };

    case "CLEAR_SEARCH":
    case "CLOSE_PROJECT_SEARCH":
    case "NAVIGATE":
      return initialProjectTextSearchState();
  }
  return state;
}

function getTextSearchOperation(state) {
  return state.projectTextSearch.ongoingSearch;
}

function getTextSearchResults(state) {
  return state.projectTextSearch.results;
}

function getTextSearchStatus(state) {
  return state.projectTextSearch.status;
}

function getTextSearchQuery(state) {
  return state.projectTextSearch.query;
}

exports.default = update;

/***/ }),
/* 533 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFrameUrl = getFrameUrl;

var _lodash = __webpack_require__(417);

function getFrameUrl(frame) {
  return (0, _lodash.get)(frame, "source.url", "") || "";
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/***/ }),
/* 534 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setBreakpointPositions = undefined;

var _devtoolsSourceMap = __webpack_require__(182);

var _lodash = __webpack_require__(417);

var _selectors = __webpack_require__(490);

var _breakpoint = __webpack_require__(499);

var _memoizableAction = __webpack_require__(546);

async function mapLocations(generatedLocations, { sourceMaps }) {
  if (generatedLocations.length == 0) {
    return [];
  }

  const { sourceId } = generatedLocations[0];
  const originalLocations = await sourceMaps.getOriginalLocations(sourceId, generatedLocations);

  return (0, _lodash.zip)(originalLocations, generatedLocations).map(([location, generatedLocation]) => ({ location, generatedLocation }));
}

// Filter out positions, that are not in the original source Id
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function filterBySource(positions, sourceId) {
  if (!(0, _devtoolsSourceMap.isOriginalId)(sourceId)) {
    return positions;
  }
  return positions.filter(position => position.location.sourceId == sourceId);
}

function filterByUniqLocation(positions) {
  return (0, _lodash.uniqBy)(positions, ({ location }) => (0, _breakpoint.makeBreakpointId)(location));
}

function convertToList(results, source) {
  const { id, url } = source;
  const positions = [];

  for (const line in results) {
    for (const column of results[line]) {
      positions.push({
        line: Number(line),
        column: column,
        sourceId: id,
        sourceUrl: url
      });
    }
  }

  return positions;
}

function groupByLine(results, sourceId, line) {
  const isOriginal = (0, _devtoolsSourceMap.isOriginalId)(sourceId);
  const positions = {};

  // Ensure that we have an entry for the line fetched
  if (typeof line === "number") {
    positions[line] = [];
  }

  for (const result of results) {
    const location = isOriginal ? result.location : result.generatedLocation;

    if (!positions[location.line]) {
      positions[location.line] = [];
    }

    positions[location.line].push(result);
  }

  return positions;
}

async function _setBreakpointPositions(cx, sourceId, line, thunkArgs) {
  const { client, dispatch, getState, sourceMaps } = thunkArgs;
  let generatedSource = (0, _selectors.getSource)(getState(), sourceId);
  if (!generatedSource) {
    return;
  }

  let results = {};
  if ((0, _devtoolsSourceMap.isOriginalId)(sourceId)) {
    // Explicitly typing ranges is required to work around the following issue
    const ranges = await sourceMaps.getGeneratedRangesForOriginal(sourceId, generatedSource.url, true);
    const generatedSourceId = (0, _devtoolsSourceMap.originalToGeneratedId)(sourceId);
    generatedSource = (0, _selectors.getSourceFromId)(getState(), generatedSourceId);

    // Note: While looping here may not look ideal, in the vast majority of
    // cases, the number of ranges here should be very small, and is quite
    // likely to only be a single range.
    for (const range of ranges) {
      // Wrap infinite end positions to the next line to keep things simple
      // and because we know we don't care about the end-line whitespace
      // in this case.
      if (range.end.column === Infinity) {
        range.end = {
          line: range.end.line + 1,
          column: 0
        };
      }

      const bps = await client.getBreakpointPositions((0, _selectors.getSourceActorsForSource)(getState(), generatedSource.id), range);
      for (const bpLine in bps) {
        results[bpLine] = (results[bpLine] || []).concat(bps[bpLine]);
      }
    }
  } else {
    if (typeof line !== "number") {
      throw new Error("Line is required for generated sources");
    }

    results = await client.getBreakpointPositions((0, _selectors.getSourceActorsForSource)(getState(), generatedSource.id), { start: { line, column: 0 }, end: { line: line + 1, column: 0 } });
  }

  let positions = convertToList(results, generatedSource);
  positions = await mapLocations(positions, thunkArgs);

  positions = filterBySource(positions, sourceId);
  positions = filterByUniqLocation(positions);
  positions = groupByLine(positions, sourceId, line);

  const source = (0, _selectors.getSource)(getState(), sourceId);
  // NOTE: it's possible that the source was removed during a navigate
  if (!source) {
    return;
  }

  dispatch({
    type: "ADD_BREAKPOINT_POSITIONS",
    cx,
    source: source,
    positions
  });

  return positions;
}

function generatedSourceActorKey(state, sourceId) {
  const generatedSource = (0, _selectors.getSource)(state, (0, _devtoolsSourceMap.isOriginalId)(sourceId) ? (0, _devtoolsSourceMap.originalToGeneratedId)(sourceId) : sourceId);
  const actors = generatedSource ? (0, _selectors.getSourceActorsForSource)(state, generatedSource.id).map(({ actor }) => actor) : [];
  return [sourceId, ...actors].join(":");
}

const setBreakpointPositions = exports.setBreakpointPositions = (0, _memoizableAction.memoizeableAction)("setBreakpointPositions", {
  hasValue: ({ sourceId, line }, { getState }) => (0, _devtoolsSourceMap.isGeneratedId)(sourceId) && line ? (0, _selectors.hasBreakpointPositionsForLine)(getState(), sourceId, line) : (0, _selectors.hasBreakpointPositions)(getState(), sourceId),
  getValue: ({ sourceId, line }, { getState }) => (0, _selectors.getBreakpointPositionsForSource)(getState(), sourceId),
  createKey({ sourceId, line }, { getState }) {
    const key = generatedSourceActorKey(getState(), sourceId);
    return (0, _devtoolsSourceMap.isGeneratedId)(sourceId) && line ? `${key}-${line}` : key;
  },
  action: async ({ cx, sourceId, line }, thunkArgs) => _setBreakpointPositions(cx, sourceId, line, thunkArgs)
});

/***/ }),
/* 535 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prettyPrintSource = prettyPrintSource;
exports.createPrettySource = createPrettySource;
exports.togglePrettyPrint = togglePrettyPrint;

var _devtoolsSourceMap = __webpack_require__(182);

var _devtoolsSourceMap2 = _interopRequireDefault(_devtoolsSourceMap);

var _assert = __webpack_require__(385);

var _assert2 = _interopRequireDefault(_assert);

var _telemetry = __webpack_require__(520);

var _breakpoints = __webpack_require__(504);

var _symbols = __webpack_require__(521);

var _prettyPrint = __webpack_require__(567);

var _source = __webpack_require__(494);

var _loadSourceText = __webpack_require__(507);

var _pause = __webpack_require__(548);

var _sources = __webpack_require__(505);

var _selectors = __webpack_require__(490);

var _select = __webpack_require__(551);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

async function prettyPrintSource(sourceMaps, generatedSource, content, actors) {
  if (!(0, _source.isJavaScript)(generatedSource, content) || content.type !== "text") {
    throw new Error("Can't prettify non-javascript files.");
  }

  const url = (0, _source.getPrettySourceURL)(generatedSource.url);
  const { code, mappings } = await (0, _prettyPrint.prettyPrint)({
    text: content.value,
    url: url
  });
  await sourceMaps.applySourceMap(generatedSource.id, url, code, mappings);

  // The source map URL service used by other devtools listens to changes to
  // sources based on their actor IDs, so apply the mapping there too.
  for (const { actor } of actors) {
    await sourceMaps.applySourceMap(actor, url, code, mappings);
  }
  return {
    text: code,
    contentType: "text/javascript"
  };
}

function createPrettySource(cx, sourceId) {
  return async ({ dispatch, getState, sourceMaps }) => {
    const source = (0, _selectors.getSourceFromId)(getState(), sourceId);
    const url = (0, _source.getPrettySourceURL)(source.url);
    const id = (0, _devtoolsSourceMap.generatedToOriginalId)(sourceId, url);

    const prettySource = {
      id,
      url,
      relativeUrl: url,
      isBlackBoxed: false,
      isPrettyPrinted: true,
      isWasm: false,
      introductionUrl: null,
      introductionType: undefined,
      isExtension: false
    };

    dispatch({ type: "ADD_SOURCE", cx, source: prettySource });
    await dispatch((0, _select.selectSource)(cx, prettySource.id));

    return prettySource;
  };
}

function selectPrettyLocation(cx, prettySource) {
  return async ({ dispatch, sourceMaps, getState }) => {
    let location = (0, _selectors.getSelectedLocation)(getState());

    if (location) {
      location = await sourceMaps.getOriginalLocation(location);
      return dispatch((0, _sources.selectSpecificLocation)(cx, { ...location, sourceId: prettySource.id }));
    }

    return dispatch((0, _select.selectSource)(cx, prettySource.id));
  };
}

/**
 * Toggle the pretty printing of a source's text. All subsequent calls to
 * |getText| will return the pretty-toggled text. Nothing will happen for
 * non-javascript files.
 *
 * @memberof actions/sources
 * @static
 * @param string id The source form from the RDP.
 * @returns Promise
 *          A promise that resolves to [aSource, prettyText] or rejects to
 *          [aSource, error].
 */
function togglePrettyPrint(cx, sourceId) {
  return async ({ dispatch, getState, client, sourceMaps }) => {
    const source = (0, _selectors.getSource)(getState(), sourceId);
    if (!source) {
      return {};
    }

    if (!source.isPrettyPrinted) {
      (0, _telemetry.recordEvent)("pretty_print");
    }

    await dispatch((0, _loadSourceText.loadSourceText)({ cx, source }));

    (0, _assert2.default)((0, _source.isGenerated)(source), "Pretty-printing only allowed on generated sources");

    const url = (0, _source.getPrettySourceURL)(source.url);
    const prettySource = (0, _selectors.getSourceByURL)(getState(), url);

    if (prettySource) {
      return dispatch(selectPrettyLocation(cx, prettySource));
    }

    const newPrettySource = await dispatch(createPrettySource(cx, sourceId));
    await dispatch(selectPrettyLocation(cx, newPrettySource));

    const threadcx = (0, _selectors.getThreadContext)(getState());
    await dispatch((0, _pause.mapFrames)(threadcx));

    await dispatch((0, _symbols.setSymbols)({ cx, source: newPrettySource }));

    await dispatch((0, _breakpoints.remapBreakpoints)(cx, sourceId));

    return newPrettySource;
  };
}

/***/ }),
/* 536 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getIndentation = getIndentation;
exports.correctIndentation = correctIndentation;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function getIndentation(line) {
  if (!line) {
    return 0;
  }

  const lineMatch = line.match(/^\s*/);
  if (!lineMatch) {
    return 0;
  }

  return lineMatch[0].length;
}

function getMaxIndentation(lines) {
  const firstLine = lines[0];
  const secondLine = lines[1];
  const lastLine = lines[lines.length - 1];

  const indentations = [getIndentation(firstLine), getIndentation(secondLine), getIndentation(lastLine)];

  return Math.max(...indentations);
}

function correctIndentation(text) {
  const lines = text.trim().split("\n");
  const indentation = getMaxIndentation(lines);
  const formattedLines = lines.map(_line => _line.replace(new RegExp(`^\\s{0,${indentation - 1}}`), ""));

  return formattedLines.join("\n");
}

/***/ }),
/* 537 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fetchScopes = fetchScopes;

var _selectors = __webpack_require__(490);

var _mapScopes = __webpack_require__(593);

var _promise = __webpack_require__(500);

function fetchScopes(cx) {
  return async function ({ dispatch, getState, client, sourceMaps }) {
    const frame = (0, _selectors.getSelectedFrame)(getState(), cx.thread);
    if (!frame || (0, _selectors.getGeneratedFrameScope)(getState(), frame.id)) {
      return;
    }

    const scopes = dispatch({
      type: "ADD_SCOPES",
      cx,
      thread: cx.thread,
      frame,
      [_promise.PROMISE]: client.getFrameScopes(frame)
    });

    await dispatch((0, _mapScopes.mapScopes)(cx, scopes, frame));
  };
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/***/ }),
/* 538 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setPrimaryPaneTab = setPrimaryPaneTab;
exports.closeActiveSearch = closeActiveSearch;
exports.setActiveSearch = setActiveSearch;
exports.updateActiveFileSearch = updateActiveFileSearch;
exports.toggleFrameworkGrouping = toggleFrameworkGrouping;
exports.showSource = showSource;
exports.togglePaneCollapse = togglePaneCollapse;
exports.highlightLineRange = highlightLineRange;
exports.flashLineRange = flashLineRange;
exports.clearHighlightLineRange = clearHighlightLineRange;
exports.openConditionalPanel = openConditionalPanel;
exports.closeConditionalPanel = closeConditionalPanel;
exports.clearProjectDirectoryRoot = clearProjectDirectoryRoot;
exports.setProjectDirectoryRoot = setProjectDirectoryRoot;
exports.updateViewport = updateViewport;
exports.setOrientation = setOrientation;

var _selectors = __webpack_require__(490);

var _select = __webpack_require__(551);

var _editor = __webpack_require__(496);

var _fileSearch = __webpack_require__(598);

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function setPrimaryPaneTab(tabName) {
  return { type: "SET_PRIMARY_PANE_TAB", tabName };
}

function closeActiveSearch() {
  return {
    type: "TOGGLE_ACTIVE_SEARCH",
    value: null
  };
}

function setActiveSearch(activeSearch) {
  return ({ dispatch, getState }) => {
    const activeSearchState = (0, _selectors.getActiveSearch)(getState());
    if (activeSearchState === activeSearch) {
      return;
    }

    if ((0, _selectors.getQuickOpenEnabled)(getState())) {
      dispatch({ type: "CLOSE_QUICK_OPEN" });
    }

    dispatch({
      type: "TOGGLE_ACTIVE_SEARCH",
      value: activeSearch
    });
  };
}

function updateActiveFileSearch(cx) {
  return ({ dispatch, getState }) => {
    const isFileSearchOpen = (0, _selectors.getActiveSearch)(getState()) === "file";
    const fileSearchQuery = (0, _selectors.getFileSearchQuery)(getState());
    if (isFileSearchOpen && fileSearchQuery) {
      const editor = (0, _editor.getEditor)();
      dispatch((0, _fileSearch.searchContents)(cx, fileSearchQuery, editor, false));
    }
  };
}

function toggleFrameworkGrouping(toggleValue) {
  return ({ dispatch, getState }) => {
    dispatch({
      type: "TOGGLE_FRAMEWORK_GROUPING",
      value: toggleValue
    });
  };
}

function showSource(cx, sourceId) {
  return ({ dispatch, getState }) => {
    const source = (0, _selectors.getSource)(getState(), sourceId);
    if (!source) {
      return;
    }

    if ((0, _selectors.getPaneCollapse)(getState(), "start")) {
      dispatch({
        type: "TOGGLE_PANE",
        position: "start",
        paneCollapsed: false
      });
    }

    dispatch(setPrimaryPaneTab("sources"));

    dispatch({ type: "SHOW_SOURCE", source: null });
    dispatch((0, _select.selectSource)(cx, source.id));
    dispatch({ type: "SHOW_SOURCE", source });
  };
}

function togglePaneCollapse(position, paneCollapsed) {
  return ({ dispatch, getState }) => {
    const prevPaneCollapse = (0, _selectors.getPaneCollapse)(getState(), position);
    if (prevPaneCollapse === paneCollapsed) {
      return;
    }

    dispatch({
      type: "TOGGLE_PANE",
      position,
      paneCollapsed
    });
  };
}

/**
 * @memberof actions/sources
 * @static
 */
function highlightLineRange(location) {
  return {
    type: "HIGHLIGHT_LINES",
    location
  };
}

function flashLineRange(location) {
  return ({ dispatch }) => {
    dispatch(highlightLineRange(location));
    setTimeout(() => dispatch(clearHighlightLineRange()), 200);
  };
}

/**
 * @memberof actions/sources
 * @static
 */
function clearHighlightLineRange() {
  return {
    type: "CLEAR_HIGHLIGHT_LINES"
  };
}

function openConditionalPanel(location, log = false) {
  if (!location) {
    return;
  }

  return {
    type: "OPEN_CONDITIONAL_PANEL",
    location,
    log
  };
}

function closeConditionalPanel() {
  return {
    type: "CLOSE_CONDITIONAL_PANEL"
  };
}

function clearProjectDirectoryRoot(cx) {
  return {
    type: "SET_PROJECT_DIRECTORY_ROOT",
    cx,
    url: ""
  };
}

function setProjectDirectoryRoot(cx, newRoot) {
  return ({ dispatch, getState }) => {
    const curRoot = (0, _selectors.getProjectDirectoryRoot)(getState());
    if (newRoot && curRoot) {
      const newRootArr = newRoot.replace(/\/+/g, "/").split("/");
      const curRootArr = curRoot.replace(/^\//, "").replace(/\/+/g, "/").split("/");
      if (newRootArr[0] !== curRootArr[0]) {
        newRootArr.splice(0, 2);
        newRoot = `${curRoot}/${newRootArr.join("/")}`;
      }
    }

    dispatch({
      type: "SET_PROJECT_DIRECTORY_ROOT",
      cx,
      url: newRoot
    });
  };
}

function updateViewport() {
  return {
    type: "SET_VIEWPORT",
    viewport: (0, _editor.getLocationsInViewport)((0, _editor.getEditor)())
  };
}

function setOrientation(orientation) {
  return { type: "SET_ORIENTATION", orientation };
}

/***/ }),
/* 539 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prepareSourcePayload = prepareSourcePayload;
exports.createFrame = createFrame;
exports.makeSourceId = makeSourceId;
exports.createPause = createPause;
exports.createWorker = createWorker;

var _commands = __webpack_require__(558);

function prepareSourcePayload(client, source) {
  // We populate the set of sources as soon as we hear about them. Note that
  // this means that we have seen an actor, but it might still be in the
  // debounced queue for creation, so the Redux store itself might not have
  // a source actor with this ID yet.
  _commands.clientCommands.registerSourceActor(source.actor, makeSourceId(source));

  return { thread: client.actor, source };
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// This module converts Firefox specific types to the generic types

function createFrame(thread, frame) {
  if (!frame) {
    return null;
  }

  const location = {
    sourceId: _commands.clientCommands.getSourceForActor(frame.where.actor),
    line: frame.where.line,
    column: frame.where.column
  };

  return {
    id: frame.actor,
    thread,
    displayName: frame.displayName,
    location,
    generatedLocation: location,
    this: frame.this,
    source: null,
    scope: frame.environment
  };
}

function makeSourceId(source) {
  return source.url ? `sourceURL-${source.url}` : `source-${source.actor}`;
}

function createPause(thread, packet, response) {
  // NOTE: useful when the debugger is already paused
  const frame = packet.frame || response.frames[0];

  return {
    ...packet,
    thread,
    frame: createFrame(thread, frame),
    frames: response.frames.map(createFrame.bind(null, thread))
  };
}

function createWorker(actor, url) {
  return {
    actor,
    url,
    // Ci.nsIWorkerDebugger.TYPE_DEDICATED
    type: 0,
    name: ""
  };
}

/***/ }),
/* 540 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDocument = getDocument;
exports.hasDocument = hasDocument;
exports.setDocument = setDocument;
exports.removeDocument = removeDocument;
exports.clearDocuments = clearDocuments;
exports.updateLineNumberFormat = updateLineNumberFormat;
exports.updateDocument = updateDocument;
exports.clearEditor = clearEditor;
exports.showLoading = showLoading;
exports.showErrorMessage = showErrorMessage;
exports.showSourceText = showSourceText;

var _source = __webpack_require__(494);

var _wasm = __webpack_require__(516);

var _ui = __webpack_require__(525);

var _sourceEditor = __webpack_require__(562);

var _sourceEditor2 = _interopRequireDefault(_sourceEditor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

let sourceDocs = {};

function getDocument(key) {
  return sourceDocs[key];
}

function hasDocument(key) {
  return !!getDocument(key);
}

function setDocument(key, doc) {
  sourceDocs[key] = doc;
}

function removeDocument(key) {
  delete sourceDocs[key];
}

function clearDocuments() {
  sourceDocs = {};
}

function resetLineNumberFormat(editor) {
  const cm = editor.codeMirror;
  cm.setOption("lineNumberFormatter", number => number);
  (0, _ui.resizeBreakpointGutter)(cm);
  (0, _ui.resizeToggleButton)(cm);
}

function updateLineNumberFormat(editor, sourceId) {
  if (!(0, _wasm.isWasm)(sourceId)) {
    return resetLineNumberFormat(editor);
  }
  const cm = editor.codeMirror;
  const lineNumberFormatter = (0, _wasm.getWasmLineNumberFormatter)(sourceId);
  cm.setOption("lineNumberFormatter", lineNumberFormatter);
  (0, _ui.resizeBreakpointGutter)(cm);
  (0, _ui.resizeToggleButton)(cm);
}

function updateDocument(editor, source) {
  if (!source) {
    return;
  }

  const sourceId = source.id;
  const doc = getDocument(sourceId) || editor.createDocument();
  editor.replaceDocument(doc);

  updateLineNumberFormat(editor, sourceId);
}

function clearEditor(editor) {
  const doc = editor.createDocument();
  editor.replaceDocument(doc);
  editor.setText("");
  editor.setMode({ name: "text" });
  resetLineNumberFormat(editor);
}

function showLoading(editor) {
  let doc = getDocument("loading");

  if (doc) {
    editor.replaceDocument(doc);
  } else {
    doc = editor.createDocument();
    setDocument("loading", doc);
    doc.setValue(L10N.getStr("loadingText"));
    editor.replaceDocument(doc);
    editor.setMode({ name: "text" });
  }
}

function showErrorMessage(editor, msg) {
  let error;
  if (msg.includes("WebAssembly binary source is not available")) {
    error = L10N.getStr("wasmIsNotAvailable");
  } else {
    error = L10N.getFormatStr("errorLoadingText3", msg);
  }
  const doc = editor.createDocument();
  editor.replaceDocument(doc);
  editor.setText(error);
  editor.setMode({ name: "text" });
  resetLineNumberFormat(editor);
}

function setEditorText(editor, sourceId, content) {
  if (content.type === "wasm") {
    const wasmLines = (0, _wasm.renderWasmText)(sourceId, content);
    // cm will try to split into lines anyway, saving memory
    const wasmText = { split: () => wasmLines, match: () => false };
    editor.setText(wasmText);
  } else {
    editor.setText(content.value);
  }
}

function setMode(editor, source, content, symbols) {
  const mode = (0, _source.getMode)(source, content, symbols);
  const currentMode = editor.codeMirror.getOption("mode");
  if (!currentMode || currentMode.name != mode.name) {
    editor.setMode(mode);
  }
}

/**
 * Handle getting the source document or creating a new
 * document with the correct mode and text.
 */
function showSourceText(editor, source, content, symbols) {
  if (hasDocument(source.id)) {
    const doc = getDocument(source.id);
    if (editor.codeMirror.doc === doc) {
      setMode(editor, source, content, symbols);
      return;
    }

    editor.replaceDocument(doc);
    updateLineNumberFormat(editor, source.id);
    setMode(editor, source, content, symbols);
    return doc;
  }

  const doc = editor.createDocument();
  setDocument(source.id, doc);
  editor.replaceDocument(doc);

  setEditorText(editor, source.id, content);
  setMode(editor, source, content, symbols);
  updateLineNumberFormat(editor, source.id);
}

/***/ }),
/* 541 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFilenameFromPath = getFilenameFromPath;
exports.getURL = getURL;

var _url = __webpack_require__(515);

var _devtoolsModules = __webpack_require__(183);

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function getFilenameFromPath(pathname) {
  let filename = "";
  if (pathname) {
    filename = pathname.substring(pathname.lastIndexOf("/") + 1);
    // This file does not have a name. Default should be (index).
    if (filename == "") {
      filename = "(index)";
    }
  }
  return filename;
}

const NoDomain = "(no domain)";
const def = { path: "", group: "", filename: "" };

function getURL(source, defaultDomain = "") {
  const { url } = source;
  if (!url) {
    return def;
  }

  const { pathname, protocol, host } = (0, _url.parse)(url);
  const filename = (0, _devtoolsModules.getUnicodeUrlPath)(getFilenameFromPath(pathname));

  switch (protocol) {
    case "javascript:":
      // Ignore `javascript:` URLs for now
      return def;

    case "moz-extension:":
    case "resource:":
      return {
        ...def,
        path: pathname,
        filename,
        group: `${protocol}//${host || ""}`
      };

    case "webpack:":
    case "ng:":
      return {
        ...def,
        path: pathname,
        filename,
        group: `${protocol}//`
      };

    case "about:":
      // An about page is a special case
      return {
        ...def,
        path: "/",
        filename,
        group: url
      };

    case "data:":
      return {
        ...def,
        path: "/",
        group: NoDomain,
        filename: url
      };

    case "":
      if (pathname && pathname.startsWith("/")) {
        // use file protocol for a URL like "/foo/bar.js"
        return {
          ...def,
          path: pathname,
          filename,
          group: "file://"
        };
      } else if (!host) {
        return {
          ...def,
          path: url,
          group: defaultDomain || "",
          filename
        };
      }
      break;

    case "http:":
    case "https:":
      return {
        ...def,
        path: pathname,
        filename,
        group: (0, _devtoolsModules.getUnicodeHostname)(host)
      };
  }

  return {
    ...def,
    path: pathname,
    group: protocol ? `${protocol}//` : "",
    filename
  };
}

/***/ }),
/* 542 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findSourceMatches = exports.getMatches = exports.stop = exports.start = undefined;

var _devtoolsUtils = __webpack_require__(7);

const { WorkerDispatcher } = _devtoolsUtils.workerUtils; /* This Source Code Form is subject to the terms of the Mozilla Public
                                                          * License, v. 2.0. If a copy of the MPL was not distributed with this
                                                          * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const dispatcher = new WorkerDispatcher();
const start = exports.start = dispatcher.start.bind(dispatcher);
const stop = exports.stop = dispatcher.stop.bind(dispatcher);

const getMatches = exports.getMatches = dispatcher.task("getMatches");
const findSourceMatches = exports.findSourceMatches = dispatcher.task("findSourceMatches");

/***/ }),
/* 543 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_543__;

/***/ }),
/* 544 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createInitial = createInitial;
exports.insertResources = insertResources;
exports.removeResources = removeResources;
exports.updateResources = updateResources;
exports.makeIdentity = makeIdentity;
exports.getResourcePair = getResourcePair;
exports.getResourceValues = getResourceValues;
function createInitial() {
  return {
    identity: {},
    values: {}
  };
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function insertResources(state, resources) {
  if (resources.length === 0) {
    return state;
  }

  state = {
    identity: { ...state.identity },
    values: { ...state.values }
  };

  for (const resource of resources) {
    const { id } = resource;
    if (state.identity[id]) {
      throw new Error(`Resource "${id}" already exists, cannot insert`);
    }
    if (state.values[id]) {
      throw new Error(`Resource state corrupt: ${id} has value but no identity`);
    }

    state.identity[resource.id] = makeIdentity();
    state.values[resource.id] = resource;
  }
  return state;
}

function removeResources(state, resources) {
  if (resources.length === 0) {
    return state;
  }

  state = {
    identity: { ...state.identity },
    values: { ...state.values }
  };

  for (let id of resources) {
    if (typeof id !== "string") {
      id = id.id;
    }

    if (!state.identity[id]) {
      throw new Error(`Resource "${id}" does not exists, cannot remove`);
    }
    if (!state.values[id]) {
      throw new Error(`Resource state corrupt: ${id} has identity but no value`);
    }

    delete state.identity[id];
    delete state.values[id];
  }
  return state;
}

function updateResources(state, resources) {
  if (resources.length === 0) {
    return state;
  }

  let didCopyValues = false;

  for (const subset of resources) {
    const { id } = subset;

    if (!state.identity[id]) {
      throw new Error(`Resource "${id}" does not exists, cannot update`);
    }
    if (!state.values[id]) {
      throw new Error(`Resource state corrupt: ${id} has identity but no value`);
    }

    const existing = state.values[id];
    const updated = {};

    for (const field of Object.keys(subset)) {
      if (field === "id") {
        continue;
      }

      if (subset[field] !== existing[field]) {
        updated[field] = subset[field];
      }
    }

    if (Object.keys(updated).length > 0) {
      if (!didCopyValues) {
        didCopyValues = true;
        state = {
          identity: state.identity,
          values: { ...state.values }
        };
      }

      state.values[id] = { ...existing, ...updated };
    }
  }

  return state;
}

function makeIdentity() {
  return {};
}

function getResourcePair(state, id) {
  const value = state.values[id];
  const identity = state.identity[id];
  if (value && !identity || !value && identity) {
    throw new Error(`Resource state corrupt: ${id} has mismatched value and identity`);
  }

  return value ? { value, identity } : null;
}

function getResourceValues(state) {
  return state.values;
}

/***/ }),
/* 545 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSourcesForTabs = exports.getSourceTabs = exports.getTabs = undefined;
exports.removeSourceFromTabList = removeSourceFromTabList;
exports.removeSourcesFromTabList = removeSourcesFromTabList;
exports.getNewSelectedSourceId = getNewSelectedSourceId;

var _reselect = __webpack_require__(444);

var _devtoolsSourceMap = __webpack_require__(182);

var _lodashMove = __webpack_require__(449);

var _lodashMove2 = _interopRequireDefault(_lodashMove);

var _prefs = __webpack_require__(492);

var _sources = __webpack_require__(498);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isSimilarTab(tab, url, isOriginal) {
  return tab.url === url && tab.isOriginal === isOriginal;
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/**
 * Tabs reducer
 * @module reducers/tabs
 */

function update(state = [], action) {
  switch (action.type) {
    case "ADD_TAB":
    case "UPDATE_TAB":
      return updateTabList(state, action);

    case "MOVE_TAB":
      return moveTabInList(state, action);

    case "CLOSE_TAB":
    case "CLOSE_TABS":
      _prefs.asyncStore.tabs = action.tabs;
      return action.tabs;

    default:
      return state;
  }
}

function removeSourceFromTabList(tabs, source) {
  return tabs.filter(tab => tab.url !== source.url || tab.isOriginal != (0, _devtoolsSourceMap.isOriginalId)(source.id));
}

function removeSourcesFromTabList(tabs, sources) {
  return sources.reduce((t, source) => removeSourceFromTabList(t, source), tabs);
}

/**
 * Adds the new source to the tab list if it is not already there
 * @memberof reducers/tabs
 * @static
 */
function updateTabList(tabs, { url, framework = null, sourceId, isOriginal = false }) {
  // Set currentIndex to -1 for URL-less tabs so that they aren't
  // filtered by isSimilarTab
  const currentIndex = url ? tabs.findIndex(tab => isSimilarTab(tab, url, isOriginal)) : -1;

  if (currentIndex === -1) {
    tabs = [{ url, framework, sourceId, isOriginal }, ...tabs];
  } else if (framework) {
    tabs[currentIndex].framework = framework;
  }

  _prefs.asyncStore.tabs = persistTabs(tabs);
  return tabs;
}

function persistTabs(tabs) {
  return tabs.filter(tab => tab.url).map(tab => {
    const newTab = { ...tab };
    delete newTab.sourceId;
    return newTab;
  });
}

function moveTabInList(tabs, { url, tabIndex: newIndex }) {
  const currentIndex = tabs.findIndex(tab => tab.url == url);
  tabs = (0, _lodashMove2.default)(tabs, currentIndex, newIndex);
  _prefs.asyncStore.tabs = tabs;
  return tabs;
}

/**
 * Gets the next tab to select when a tab closes. Heuristics:
 * 1. if the selected tab is available, it remains selected
 * 2. if it is gone, the next available tab to the left should be active
 * 3. if the first tab is active and closed, select the second tab
 *
 * @memberof reducers/tabs
 * @static
 */
function getNewSelectedSourceId(state, availableTabs) {
  const selectedLocation = state.sources.selectedLocation;
  if (!selectedLocation) {
    return "";
  }

  const selectedTab = (0, _sources.getSource)(state, selectedLocation.sourceId);
  if (!selectedTab) {
    return "";
  }

  const matchingTab = availableTabs.find(tab => isSimilarTab(tab, selectedTab.url, (0, _devtoolsSourceMap.isOriginalId)(selectedLocation.sourceId)));

  if (matchingTab) {
    const sources = state.sources.sources;
    if (!sources) {
      return "";
    }

    const selectedSource = (0, _sources.getSpecificSourceByURL)(state, selectedTab.url, (0, _devtoolsSourceMap.isOriginalId)(selectedTab.id));

    if (selectedSource) {
      return selectedSource.id;
    }

    return "";
  }

  const tabUrls = state.tabs.map(t => t.url);
  const leftNeighborIndex = Math.max(tabUrls.indexOf(selectedTab.url) - 1, 0);
  const lastAvailbleTabIndex = availableTabs.length - 1;
  const newSelectedTabIndex = Math.min(leftNeighborIndex, lastAvailbleTabIndex);
  const availableTab = availableTabs[newSelectedTabIndex];

  if (availableTab) {
    const tabSource = (0, _sources.getSpecificSourceByURL)(state, availableTab.url, availableTab.isOriginal);

    if (tabSource) {
      return tabSource.id;
    }
  }

  return "";
}

// Selectors

// Unfortunately, it's really hard to make these functions accept just
// the state that we care about and still type it with Flow. The
// problem is that we want to re-export all selectors from a single
// module for the UI, and all of those selectors should take the
// top-level app state, so we'd have to "wrap" them to automatically
// pick off the piece of state we're interested in. It's impossible
// (right now) to type those wrapped functions.
const getTabs = exports.getTabs = state => state.tabs;

const getSourceTabs = exports.getSourceTabs = (0, _reselect.createSelector)(getTabs, _sources.getSources, _sources.getUrls, (tabs, sources, urls) => tabs.filter(tab => getTabWithOrWithoutUrl(tab, sources, urls)));

const getSourcesForTabs = exports.getSourcesForTabs = (0, _reselect.createSelector)(getSourceTabs, _sources.getSources, _sources.getUrls, (tabs, sources, urls) => tabs.map(tab => getTabWithOrWithoutUrl(tab, sources, urls)).filter(Boolean));

function getTabWithOrWithoutUrl(tab, sources, urls) {
  if (tab.url) {
    return (0, _sources.getSpecificSourceByURLInSources)(sources, urls, tab.url, tab.isOriginal);
  }

  return tab.sourceId ? (0, _sources.getSourceInSources)(sources, tab.sourceId) : null;
}

exports.default = update;

/***/ }),
/* 546 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.memoizeableAction = memoizeableAction;


/*
 * memoizableActon is a utility for actions that should only be performed
 * once per key. It is useful for loading sources, parsing symbols ...
 *
 * @exitEarly - if true, do not attempt to perform the action
 * @hasValue - checks to see if the result is in the redux store
 * @getValue - gets the result from the redux store
 * @createKey - creates a key for the requests map
 * @action - kicks off the async work for the action
 *
 *
 * For Example
 *
 * export const setItem = memoizeableAction(
 *   "setItem",
 *   {
 *     hasValue: ({ a }, { getState }) => hasItem(getState(), a),
 *     getValue: ({ a }, { getState }) => getItem(getState(), a),
 *     createKey: ({ a }) => a,
 *     action: ({ a }, thunkArgs) => doSetItem(a, thunkArgs)
 *   }
 * );
 * 
 */
function memoizeableAction(name, {
  hasValue,
  getValue,
  createKey,
  action,
  exitEarly
}) {
  const requests = new Map();
  return args => async thunkArgs => {
    if (exitEarly && exitEarly(args, thunkArgs)) {
      return;
    }

    if (hasValue(args, thunkArgs)) {
      return getValue(args, thunkArgs);
    }

    const key = createKey(args, thunkArgs);
    if (!requests.has(key)) {
      requests.set(key, (async () => {
        try {
          await action(args, thunkArgs);
        } catch (e) {
          console.warn(`Action ${name} had an exception:`, e);
        } finally {
          requests.delete(key);
        }
      })());
    }

    await requests.get(key);
    return getValue(args, thunkArgs);
  };
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/***/ }),
/* 547 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateTab = updateTab;
exports.addTab = addTab;
exports.moveTab = moveTab;
exports.closeTab = closeTab;
exports.closeTabs = closeTabs;

var _devtoolsSourceMap = __webpack_require__(182);

var _editor = __webpack_require__(496);

var _sources = __webpack_require__(505);

var _selectors = __webpack_require__(490);

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/**
 * Redux actions for the editor tabs
 * @module actions/tabs
 */

function updateTab(source, framework) {
  const { url, id: sourceId } = source;
  const isOriginal = (0, _devtoolsSourceMap.isOriginalId)(source.id);

  return {
    type: "UPDATE_TAB",
    url,
    framework,
    isOriginal,
    sourceId
  };
}

function addTab(source) {
  const { url, id: sourceId } = source;
  const isOriginal = (0, _devtoolsSourceMap.isOriginalId)(source.id);

  return {
    type: "ADD_TAB",
    url,
    isOriginal,
    sourceId
  };
}

function moveTab(url, tabIndex) {
  return {
    type: "MOVE_TAB",
    url,
    tabIndex
  };
}

/**
 * @memberof actions/tabs
 * @static
 */
function closeTab(cx, source) {
  return ({ dispatch, getState, client }) => {
    const { id, url } = source;

    (0, _editor.removeDocument)(id);

    const tabs = (0, _selectors.removeSourceFromTabList)((0, _selectors.getSourceTabs)(getState()), source);
    const sourceId = (0, _selectors.getNewSelectedSourceId)(getState(), tabs);
    dispatch({ type: "CLOSE_TAB", url, tabs });
    dispatch((0, _sources.selectSource)(cx, sourceId));
  };
}

/**
 * @memberof actions/tabs
 * @static
 */
function closeTabs(cx, urls) {
  return ({ dispatch, getState, client }) => {
    const sources = urls.map(url => (0, _selectors.getSourceByURL)(getState(), url)).filter(Boolean);
    sources.map(source => (0, _editor.removeDocument)(source.id));

    const tabs = (0, _selectors.removeSourcesFromTabList)((0, _selectors.getSourceTabs)(getState()), sources);
    dispatch({ type: "CLOSE_TABS", sources, tabs });

    const sourceId = (0, _selectors.getNewSelectedSourceId)(getState(), tabs);
    dispatch((0, _sources.selectSource)(cx, sourceId));
  };
}

/***/ }),
/* 548 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _commands = __webpack_require__(591);

Object.defineProperty(exports, "selectThread", {
  enumerable: true,
  get: function () {
    return _commands.selectThread;
  }
});
Object.defineProperty(exports, "stepIn", {
  enumerable: true,
  get: function () {
    return _commands.stepIn;
  }
});
Object.defineProperty(exports, "stepOver", {
  enumerable: true,
  get: function () {
    return _commands.stepOver;
  }
});
Object.defineProperty(exports, "stepOut", {
  enumerable: true,
  get: function () {
    return _commands.stepOut;
  }
});
Object.defineProperty(exports, "resume", {
  enumerable: true,
  get: function () {
    return _commands.resume;
  }
});
Object.defineProperty(exports, "rewind", {
  enumerable: true,
  get: function () {
    return _commands.rewind;
  }
});
Object.defineProperty(exports, "reverseStepIn", {
  enumerable: true,
  get: function () {
    return _commands.reverseStepIn;
  }
});
Object.defineProperty(exports, "reverseStepOver", {
  enumerable: true,
  get: function () {
    return _commands.reverseStepOver;
  }
});
Object.defineProperty(exports, "reverseStepOut", {
  enumerable: true,
  get: function () {
    return _commands.reverseStepOut;
  }
});

var _fetchScopes = __webpack_require__(537);

Object.defineProperty(exports, "fetchScopes", {
  enumerable: true,
  get: function () {
    return _fetchScopes.fetchScopes;
  }
});

var _paused = __webpack_require__(661);

Object.defineProperty(exports, "paused", {
  enumerable: true,
  get: function () {
    return _paused.paused;
  }
});

var _resumed = __webpack_require__(662);

Object.defineProperty(exports, "resumed", {
  enumerable: true,
  get: function () {
    return _resumed.resumed;
  }
});

var _continueToHere = __webpack_require__(664);

Object.defineProperty(exports, "continueToHere", {
  enumerable: true,
  get: function () {
    return _continueToHere.continueToHere;
  }
});

var _breakOnNext = __webpack_require__(665);

Object.defineProperty(exports, "breakOnNext", {
  enumerable: true,
  get: function () {
    return _breakOnNext.breakOnNext;
  }
});

var _mapFrames = __webpack_require__(666);

Object.defineProperty(exports, "mapFrames", {
  enumerable: true,
  get: function () {
    return _mapFrames.mapFrames;
  }
});

var _pauseOnExceptions = __webpack_require__(667);

Object.defineProperty(exports, "pauseOnExceptions", {
  enumerable: true,
  get: function () {
    return _pauseOnExceptions.pauseOnExceptions;
  }
});

var _selectFrame = __webpack_require__(668);

Object.defineProperty(exports, "selectFrame", {
  enumerable: true,
  get: function () {
    return _selectFrame.selectFrame;
  }
});

var _skipPausing = __webpack_require__(669);

Object.defineProperty(exports, "toggleSkipPausing", {
  enumerable: true,
  get: function () {
    return _skipPausing.toggleSkipPausing;
  }
});

var _mapScopes = __webpack_require__(593);

Object.defineProperty(exports, "toggleMapScopes", {
  enumerable: true,
  get: function () {
    return _mapScopes.toggleMapScopes;
  }
});

/***/ }),
/* 549 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.positionCmp = positionCmp;

var _locColumn = __webpack_require__(522);

/**
 * * === 0 - Positions are equal.
 * * < 0 - first position before second position
 * * > 0 - first position after second position
 */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function positionCmp(p1, p2) {
  if (p1.line === p2.line) {
    const l1 = (0, _locColumn.locColumn)(p1);
    const l2 = (0, _locColumn.locColumn)(p2);

    if (l1 === l2) {
      return 0;
    }
    return l1 < l2 ? -1 : 1;
  }

  return p1.line < p2.line ? -1 : 1;
}

/***/ }),
/* 550 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _why = __webpack_require__(663);

Object.keys(_why).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _why[key];
    }
  });
});

/***/ }),
/* 551 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clearSelectedLocation = exports.setPendingSelectedLocation = exports.setSelectedLocation = undefined;
exports.selectSourceURL = selectSourceURL;
exports.selectSource = selectSource;
exports.selectLocation = selectLocation;
exports.selectSpecificLocation = selectSpecificLocation;
exports.jumpToMappedLocation = jumpToMappedLocation;
exports.jumpToMappedSelectedLocation = jumpToMappedSelectedLocation;

var _devtoolsSourceMap = __webpack_require__(182);

var _sources = __webpack_require__(498);

var _tabs = __webpack_require__(545);

var _ast = __webpack_require__(597);

var _symbols = __webpack_require__(521);

var _ui = __webpack_require__(538);

var _asyncValue = __webpack_require__(497);

var _prettyPrint = __webpack_require__(535);

var _tabs2 = __webpack_require__(547);

var _loadSourceText = __webpack_require__(507);

var _prefs = __webpack_require__(492);

var _source = __webpack_require__(494);

var _location = __webpack_require__(509);

var _sourceMaps = __webpack_require__(671);

var _selectors = __webpack_require__(490);

const setSelectedLocation = exports.setSelectedLocation = (cx, source, location) => ({
  type: "SET_SELECTED_LOCATION",
  cx,
  source,
  location
}); /* This Source Code Form is subject to the terms of the Mozilla Public
     * License, v. 2.0. If a copy of the MPL was not distributed with this
     * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/**
 * Redux actions for the sources state
 * @module actions/sources
 */

const setPendingSelectedLocation = exports.setPendingSelectedLocation = (cx, url, options) => ({
  type: "SET_PENDING_SELECTED_LOCATION",
  cx,
  url: url,
  line: options.location ? options.location.line : null
});

const clearSelectedLocation = exports.clearSelectedLocation = cx => ({
  type: "CLEAR_SELECTED_LOCATION",
  cx
});

/**
 * Deterministically select a source that has a given URL. This will
 * work regardless of the connection status or if the source exists
 * yet.
 *
 * This exists mostly for external things to interact with the
 * debugger.
 *
 * @memberof actions/sources
 * @static
 */
function selectSourceURL(cx, url, options = { line: 1 }) {
  return async ({ dispatch, getState, sourceMaps }) => {
    const source = (0, _selectors.getSourceByURL)(getState(), url);
    if (!source) {
      return dispatch(setPendingSelectedLocation(cx, url, options));
    }

    const sourceId = source.id;
    const location = (0, _location.createLocation)({ ...options, sourceId });
    return dispatch(selectLocation(cx, location));
  };
}

/**
 * @memberof actions/sources
 * @static
 */
function selectSource(cx, sourceId, options = { line: 1 }) {
  return async ({ dispatch }) => {
    const location = (0, _location.createLocation)({ ...options, sourceId });
    return dispatch(selectSpecificLocation(cx, location));
  };
}

/**
 * @memberof actions/sources
 * @static
 */
function selectLocation(cx, location, { keepContext = true } = {}) {
  return async ({ dispatch, getState, sourceMaps, client }) => {
    const currentSource = (0, _selectors.getSelectedSource)(getState());

    if (!client) {
      // No connection, do nothing. This happens when the debugger is
      // shut down too fast and it tries to display a default source.
      return;
    }

    let source = (0, _selectors.getSource)(getState(), location.sourceId);
    if (!source) {
      // If there is no source we deselect the current selected source
      return dispatch(clearSelectedLocation(cx));
    }

    const activeSearch = (0, _selectors.getActiveSearch)(getState());
    if (activeSearch && activeSearch !== "file") {
      dispatch((0, _ui.closeActiveSearch)());
    }

    // Preserve the current source map context (original / generated)
    // when navigting to a new location.
    const selectedSource = (0, _selectors.getSelectedSource)(getState());
    if (keepContext && selectedSource && (0, _devtoolsSourceMap.isOriginalId)(selectedSource.id) != (0, _devtoolsSourceMap.isOriginalId)(location.sourceId)) {
      location = await (0, _sourceMaps.mapLocation)(getState(), sourceMaps, location);
      source = (0, _sources.getSourceFromId)(getState(), location.sourceId);
    }

    const tabSources = (0, _tabs.getSourcesForTabs)(getState());
    if (!tabSources.includes(source)) {
      dispatch((0, _tabs2.addTab)(source));
    }

    dispatch(setSelectedLocation(cx, source, location));

    await dispatch((0, _loadSourceText.loadSourceText)({ cx, source }));
    const loadedSource = (0, _selectors.getSource)(getState(), source.id);

    if (!loadedSource) {
      // If there was a navigation while we were loading the loadedSource
      return;
    }
    const sourceWithContent = (0, _sources.getSourceWithContent)(getState(), source.id);
    const sourceContent = sourceWithContent.content && (0, _asyncValue.isFulfilled)(sourceWithContent.content) ? sourceWithContent.content.value : null;

    if (keepContext && _prefs.prefs.autoPrettyPrint && !(0, _selectors.getPrettySource)(getState(), loadedSource.id) && (0, _source.shouldPrettyPrint)(loadedSource, sourceContent || { type: "text", value: "", contentType: undefined }) && (0, _source.isMinified)(sourceWithContent)) {
      await dispatch((0, _prettyPrint.togglePrettyPrint)(cx, loadedSource.id));
      dispatch((0, _tabs2.closeTab)(cx, loadedSource));
    }

    dispatch((0, _symbols.setSymbols)({ cx, source: loadedSource }));
    dispatch((0, _ast.setOutOfScopeLocations)(cx));

    // If a new source is selected update the file search results
    const newSource = (0, _selectors.getSelectedSource)(getState());
    if (currentSource && currentSource !== newSource) {
      dispatch((0, _ui.updateActiveFileSearch)(cx));
    }
  };
}

/**
 * @memberof actions/sources
 * @static
 */
function selectSpecificLocation(cx, location) {
  return selectLocation(cx, location, { keepContext: false });
}

/**
 * @memberof actions/sources
 * @static
 */
function jumpToMappedLocation(cx, location) {
  return async function ({ dispatch, getState, client, sourceMaps }) {
    if (!client) {
      return;
    }

    const pairedLocation = await (0, _sourceMaps.mapLocation)(getState(), sourceMaps, location);

    return dispatch(selectSpecificLocation(cx, { ...pairedLocation }));
  };
}

function jumpToMappedSelectedLocation(cx) {
  return async function ({ dispatch, getState }) {
    const location = (0, _selectors.getSelectedLocation)(getState());
    if (!location) {
      return;
    }

    await dispatch(jumpToMappedLocation(cx, location));
  };
}

/***/ }),
/* 552 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.insertSourceActor = insertSourceActor;
exports.insertSourceActors = insertSourceActors;
exports.removeSourceActor = removeSourceActor;
exports.removeSourceActors = removeSourceActors;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function insertSourceActor(item) {
  return insertSourceActors([item]);
}
function insertSourceActors(items) {
  return function ({ dispatch }) {
    dispatch({
      type: "INSERT_SOURCE_ACTORS",
      items
    });
  };
}

function removeSourceActor(item) {
  return removeSourceActors([item]);
}
function removeSourceActors(items) {
  return function ({ dispatch }) {
    dispatch({
      type: "REMOVE_SOURCE_ACTORS",
      items
    });
  };
}

/***/ }),
/* 553 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _Button = __webpack_require__(502);

var _AccessibleImage = __webpack_require__(495);

var _AccessibleImage2 = _interopRequireDefault(_AccessibleImage);

var _classnames = __webpack_require__(67);

var _classnames2 = _interopRequireDefault(_classnames);

__webpack_require__(702);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const arrowBtn = (onClick, type, className, tooltip) => {
  const props = {
    className,
    key: type,
    onClick,
    title: tooltip,
    type
  };

  return _react2.default.createElement(
    "button",
    props,
    _react2.default.createElement(_AccessibleImage2.default, { className: type })
  );
}; /* This Source Code Form is subject to the terms of the Mozilla Public
    * License, v. 2.0. If a copy of the MPL was not distributed with this
    * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

class SearchInput extends _react.Component {

  constructor(props) {
    super(props);

    this.onKeyDown = e => {
      const { onHistoryScroll, onKeyDown } = this.props;
      if (!onHistoryScroll) {
        return onKeyDown(e);
      }

      const inputValue = e.target.value;
      const { history } = this.state;
      const currentHistoryIndex = history.indexOf(inputValue);

      if (e.key === "Enter") {
        this.saveEnteredTerm(inputValue);
        return onKeyDown(e);
      }

      if (e.key === "ArrowUp") {
        const previous = currentHistoryIndex > -1 ? currentHistoryIndex - 1 : history.length - 1;
        const previousInHistory = history[previous];
        if (previousInHistory) {
          e.preventDefault();
          onHistoryScroll(previousInHistory);
        }
        return;
      }

      if (e.key === "ArrowDown") {
        const next = currentHistoryIndex + 1;
        const nextInHistory = history[next];
        if (nextInHistory) {
          onHistoryScroll(nextInHistory);
        }
      }
    };

    this.state = {
      history: []
    };
  }

  componentDidMount() {
    this.setFocus();
  }

  setFocus() {
    if (this.$input) {
      const input = this.$input;
      input.focus();

      if (!input.value) {
        return;
      }

      // omit prefix @:# from being selected
      const selectStartPos = this.props.hasPrefix ? 1 : 0;
      input.setSelectionRange(selectStartPos, input.value.length + 1);
    }
  }

  renderSvg() {
    return _react2.default.createElement(_AccessibleImage2.default, { className: "search" });
  }

  renderArrowButtons() {
    const { handleNext, handlePrev } = this.props;

    return [arrowBtn(handlePrev, "arrow-up", (0, _classnames2.default)("nav-btn", "prev"), L10N.getFormatStr("editor.searchResults.prevResult")), arrowBtn(handleNext, "arrow-down", (0, _classnames2.default)("nav-btn", "next"), L10N.getFormatStr("editor.searchResults.nextResult"))];
  }

  saveEnteredTerm(query) {
    const { history } = this.state;
    const previousIndex = history.indexOf(query);
    if (previousIndex !== -1) {
      history.splice(previousIndex, 1);
    }
    history.push(query);
    this.setState({ history });
  }

  renderSummaryMsg() {
    const { summaryMsg } = this.props;

    if (!summaryMsg) {
      return null;
    }

    return _react2.default.createElement(
      "div",
      { className: "search-field-summary" },
      summaryMsg
    );
  }

  renderSpinner() {
    const { isLoading } = this.props;
    if (isLoading) {
      return _react2.default.createElement(_AccessibleImage2.default, { className: "loader" });
    }
  }

  renderNav() {
    const { count, handleNext, handlePrev } = this.props;
    if (!handleNext && !handlePrev || !count || count == 1) {
      return;
    }

    return _react2.default.createElement(
      "div",
      { className: "search-nav-buttons" },
      this.renderArrowButtons()
    );
  }

  render() {
    const {
      expanded,
      handleClose,
      onChange,
      onKeyUp,
      placeholder,
      query,
      selectedItemId,
      showErrorEmoji,
      size,
      showClose
    } = this.props;

    const inputProps = {
      className: (0, _classnames2.default)({
        empty: showErrorEmoji
      }),
      onChange,
      onKeyDown: e => this.onKeyDown(e),
      onKeyUp,
      "aria-autocomplete": "list",
      "aria-controls": "result-list",
      "aria-activedescendant": expanded && selectedItemId ? `${selectedItemId}-title` : "",
      placeholder,
      value: query,
      spellCheck: false,
      ref: c => this.$input = c
    };

    return _react2.default.createElement(
      "div",
      { className: "search-outline" },
      _react2.default.createElement(
        "div",
        {
          className: (0, _classnames2.default)("search-field", size),
          role: "combobox",
          "aria-haspopup": "listbox",
          "aria-owns": "result-list",
          "aria-expanded": expanded
        },
        this.renderSvg(),
        _react2.default.createElement("input", inputProps),
        this.renderSpinner(),
        this.renderSummaryMsg(),
        this.renderNav(),
        showClose && _react2.default.createElement(_Button.CloseButton, { handleClick: handleClose, buttonClass: size })
      )
    );
  }
}

SearchInput.defaultProps = {
  expanded: false,
  hasPrefix: false,
  selectedItemId: "",
  size: "",
  showClose: true
};
exports.default = SearchInput;

/***/ }),
/* 554 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /* This Source Code Form is subject to the terms of the Mozilla Public
                                                                                                                                                                                                                                                                   * License, v. 2.0. If a copy of the MPL was not distributed with this
                                                                                                                                                                                                                                                                   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

exports.debugBtn = debugBtn;

var _classnames = __webpack_require__(67);

var _classnames2 = _interopRequireDefault(_classnames);

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _AccessibleImage = __webpack_require__(495);

var _AccessibleImage2 = _interopRequireDefault(_AccessibleImage);

__webpack_require__(699);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function debugBtn(onClick, type, className, tooltip, disabled = false, ariaPressed = false) {
  return _react2.default.createElement(
    CommandBarButton,
    {
      className: (0, _classnames2.default)(type, className),
      disabled: disabled,
      key: type,
      onClick: onClick,
      pressed: ariaPressed,
      title: tooltip
    },
    _react2.default.createElement(_AccessibleImage2.default, { className: type })
  );
}

const CommandBarButton = props => {
  const { children, className, pressed = false, ...rest } = props;

  return _react2.default.createElement(
    "button",
    _extends({
      "aria-pressed": pressed,
      className: (0, _classnames2.default)("command-bar-button", className)
    }, rest),
    children
  );
};

exports.default = CommandBarButton;

/***/ }),
/* 555 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _connect = __webpack_require__(491);

var _AccessibleImage = __webpack_require__(495);

var _AccessibleImage2 = _interopRequireDefault(_AccessibleImage);

var _source = __webpack_require__(494);

var _tabs = __webpack_require__(556);

var _selectors = __webpack_require__(490);

__webpack_require__(713);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class SourceIcon extends _react.PureComponent {
  render() {
    const { shouldHide, source, symbols, framework } = this.props;
    const iconClass = framework ? framework.toLowerCase() : (0, _source.getSourceClassnames)(source, symbols);

    if (shouldHide && shouldHide(iconClass)) {
      return null;
    }

    return _react2.default.createElement(_AccessibleImage2.default, { className: `source-icon ${iconClass}` });
  }
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

exports.default = (0, _connect.connect)((state, props) => {
  return {
    symbols: (0, _selectors.getSymbols)(state, props.source),
    framework: (0, _tabs.getFramework)((0, _selectors.getTabs)(state), props.source.url)
  };
})(SourceIcon);

/***/ }),
/* 556 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getHiddenTabs = getHiddenTabs;
exports.getFramework = getFramework;
exports.getTabMenuItems = getTabMenuItems;

/*
 * Finds the hidden tabs by comparing the tabs' top offset.
 * hidden tabs will have a great top offset.
 *
 * @param sourceTabs Immutable.list
 * @param sourceTabEls HTMLCollection
 *
 * @returns Immutable.list
 */

function getHiddenTabs(sourceTabs, sourceTabEls) {
  sourceTabEls = [].slice.call(sourceTabEls);
  function getTopOffset() {
    const topOffsets = sourceTabEls.map(t => t.getBoundingClientRect().top);
    return Math.min(...topOffsets);
  }

  function hasTopOffset(el) {
    // adding 10px helps account for cases where the tab might be offset by
    // styling such as selected tabs which don't have a border.
    const tabTopOffset = getTopOffset();
    return el.getBoundingClientRect().top > tabTopOffset + 10;
  }

  return sourceTabs.filter((tab, index) => {
    const element = sourceTabEls[index];
    return element && hasTopOffset(element);
  });
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function getFramework(tabs, url) {
  const tab = tabs.find(t => t.url === url);

  if (tab) {
    return tab.framework;
  }

  return "";
}

function getTabMenuItems() {
  return {
    closeTab: {
      id: "node-menu-close-tab",
      label: L10N.getStr("sourceTabs.closeTab"),
      accesskey: L10N.getStr("sourceTabs.closeTab.accesskey"),
      disabled: false
    },
    closeOtherTabs: {
      id: "node-menu-close-other-tabs",
      label: L10N.getStr("sourceTabs.closeOtherTabs"),
      accesskey: L10N.getStr("sourceTabs.closeOtherTabs.accesskey"),
      disabled: false
    },
    closeTabsToEnd: {
      id: "node-menu-close-tabs-to-end",
      label: L10N.getStr("sourceTabs.closeTabsToEnd"),
      accesskey: L10N.getStr("sourceTabs.closeTabsToEnd.accesskey"),
      disabled: false
    },
    closeAllTabs: {
      id: "node-menu-close-all-tabs",
      label: L10N.getStr("sourceTabs.closeAllTabs"),
      accesskey: L10N.getStr("sourceTabs.closeAllTabs.accesskey"),
      disabled: false
    },
    showSource: {
      id: "node-menu-show-source",
      label: L10N.getStr("sourceTabs.revealInTree"),
      accesskey: L10N.getStr("sourceTabs.revealInTree.accesskey"),
      disabled: false
    },
    copyToClipboard: {
      id: "node-menu-copy-to-clipboard",
      label: L10N.getStr("copyToClipboard.label"),
      accesskey: L10N.getStr("copyToClipboard.accesskey"),
      disabled: false
    },
    copySourceUri2: {
      id: "node-menu-copy-source-url",
      label: L10N.getStr("copySourceUri2"),
      accesskey: L10N.getStr("copySourceUri2.accesskey"),
      disabled: false
    },
    toggleBlackBox: {
      id: "node-menu-blackbox",
      label: L10N.getStr("sourceFooter.blackbox"),
      accesskey: L10N.getStr("sourceFooter.blackbox.accesskey"),
      disabled: false
    },
    prettyPrint: {
      id: "node-menu-pretty-print",
      label: L10N.getStr("sourceTabs.prettyPrint"),
      accesskey: L10N.getStr("sourceTabs.prettyPrint.accesskey"),
      disabled: false
    }
  };
}

/***/ }),
/* 557 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.continueToHereItem = undefined;
exports.editorMenuItems = editorMenuItems;
exports.editorItemActions = editorItemActions;

var _redux = __webpack_require__(517);

var _devtoolsSourceMap = __webpack_require__(182);

var _clipboard = __webpack_require__(512);

var _source = __webpack_require__(494);

var _utils = __webpack_require__(524);

var _asyncValue = __webpack_require__(497);

var _actions = __webpack_require__(493);

var _actions2 = _interopRequireDefault(_actions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isMapped(selectedSource) {
  return (0, _devtoolsSourceMap.isOriginalId)(selectedSource.id) || !!selectedSource.sourceMapURL;
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const continueToHereItem = exports.continueToHereItem = (cx, location, isPaused, editorActions) => ({
  accesskey: L10N.getStr("editor.continueToHere.accesskey"),
  disabled: !isPaused,
  click: () => editorActions.continueToHere(cx, location.line, location.column),
  id: "node-menu-continue-to-here",
  label: L10N.getStr("editor.continueToHere.label")
});

// menu items

const copyToClipboardItem = (selectedContent, editorActions) => {
  return {
    id: "node-menu-copy-to-clipboard",
    label: L10N.getStr("copyToClipboard.label"),
    accesskey: L10N.getStr("copyToClipboard.accesskey"),
    disabled: false,
    click: () => selectedContent.type === "text" && (0, _clipboard.copyToTheClipboard)(selectedContent.value)
  };
};

const copySourceItem = (selectedSource, selectionText, editorActions) => {
  if (selectedSource.isWasm) {
    return;
  }

  return {
    id: "node-menu-copy-source",
    label: L10N.getStr("copySource.label"),
    accesskey: L10N.getStr("copySource.accesskey"),
    disabled: selectionText.length === 0,
    click: () => (0, _clipboard.copyToTheClipboard)(selectionText)
  };
};

const copySourceUri2Item = (selectedSource, editorActions) => ({
  id: "node-menu-copy-source-url",
  label: L10N.getStr("copySourceUri2"),
  accesskey: L10N.getStr("copySourceUri2.accesskey"),
  disabled: !selectedSource.url,
  click: () => (0, _clipboard.copyToTheClipboard)((0, _source.getRawSourceURL)(selectedSource.url))
});

const jumpToMappedLocationItem = (cx, selectedSource, location, hasPrettySource, editorActions) => ({
  id: "node-menu-jump",
  label: L10N.getFormatStr("editor.jumpToMappedLocation1", (0, _devtoolsSourceMap.isOriginalId)(selectedSource.id) ? L10N.getStr("generated") : L10N.getStr("original")),
  accesskey: L10N.getStr("editor.jumpToMappedLocation1.accesskey"),
  disabled: !isMapped(selectedSource) && !(0, _source.isPretty)(selectedSource) || hasPrettySource,
  click: () => editorActions.jumpToMappedLocation(cx, location)
});

const showSourceMenuItem = (cx, selectedSource, editorActions) => ({
  id: "node-menu-show-source",
  label: L10N.getStr("sourceTabs.revealInTree"),
  accesskey: L10N.getStr("sourceTabs.revealInTree.accesskey"),
  disabled: !selectedSource.url,
  click: () => editorActions.showSource(cx, selectedSource.id)
});

const blackBoxMenuItem = (cx, selectedSource, editorActions) => ({
  id: "node-menu-blackbox",
  label: selectedSource.isBlackBoxed ? L10N.getStr("sourceFooter.unblackbox") : L10N.getStr("sourceFooter.blackbox"),
  accesskey: L10N.getStr("sourceFooter.blackbox.accesskey"),
  disabled: !(0, _source.shouldBlackbox)(selectedSource),
  click: () => editorActions.toggleBlackBox(cx, selectedSource)
});

const watchExpressionItem = (cx, selectedSource, selectionText, editorActions) => ({
  id: "node-menu-add-watch-expression",
  label: L10N.getStr("expressions.label"),
  accesskey: L10N.getStr("expressions.accesskey"),
  click: () => editorActions.addExpression(cx, selectionText)
});

const evaluateInConsoleItem = (selectedSource, selectionText, editorActions) => ({
  id: "node-menu-evaluate-in-console",
  label: L10N.getStr("evaluateInConsole.label"),
  click: () => editorActions.evaluateInConsole(selectionText)
});

const downloadFileItem = (selectedSource, selectedContent, editorActions) => {
  return {
    id: "node-menu-download-file",
    label: L10N.getStr("downloadFile.label"),
    accesskey: L10N.getStr("downloadFile.accesskey"),
    click: () => (0, _utils.downloadFile)(selectedContent, (0, _source.getFilename)(selectedSource))
  };
};

function editorMenuItems({
  cx,
  editorActions,
  selectedSourceWithContent,
  location,
  selectionText,
  hasPrettySource,
  isTextSelected,
  isPaused
}) {
  const items = [];
  const { source: selectedSource, content } = selectedSourceWithContent;

  items.push(jumpToMappedLocationItem(cx, selectedSource, location, hasPrettySource, editorActions), continueToHereItem(cx, location, isPaused, editorActions), { type: "separator" }, ...(content && (0, _asyncValue.isFulfilled)(content) ? [copyToClipboardItem(content.value, editorActions)] : []), copySourceItem(selectedSource, selectionText, editorActions), copySourceUri2Item(selectedSource, editorActions), ...(content && (0, _asyncValue.isFulfilled)(content) ? [downloadFileItem(selectedSource, content.value, editorActions)] : []), { type: "separator" }, showSourceMenuItem(cx, selectedSource, editorActions), blackBoxMenuItem(cx, selectedSource, editorActions));

  if (isTextSelected) {
    items.push({ type: "separator" }, watchExpressionItem(cx, selectedSource, selectionText, editorActions), evaluateInConsoleItem(selectedSource, selectionText, editorActions));
  }

  return items;
}

function editorItemActions(dispatch) {
  return (0, _redux.bindActionCreators)({
    addExpression: _actions2.default.addExpression,
    continueToHere: _actions2.default.continueToHere,
    evaluateInConsole: _actions2.default.evaluateInConsole,
    flashLineRange: _actions2.default.flashLineRange,
    jumpToMappedLocation: _actions2.default.jumpToMappedLocation,
    showSource: _actions2.default.showSource,
    toggleBlackBox: _actions2.default.toggleBlackBox
  }, dispatch);
}

/***/ }),
/* 558 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clientCommands = exports.setupCommands = undefined;

var _create = __webpack_require__(539);

var _workers = __webpack_require__(614);

var _prefs = __webpack_require__(492);

var _devtoolsReps = __webpack_require__(457);

var _devtoolsReps2 = _interopRequireDefault(_devtoolsReps);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

let workerClients;
let threadClient;
let tabTarget;
let debuggerClient;
let sourceActors;
let breakpoints;
let supportsWasm;

let shouldWaitForWorkers = false;

function setupCommands(dependencies) {
  threadClient = dependencies.threadClient;
  tabTarget = dependencies.tabTarget;
  debuggerClient = dependencies.debuggerClient;
  supportsWasm = dependencies.supportsWasm;
  workerClients = {};
  sourceActors = {};
  breakpoints = {};
}

function hasWasmSupport() {
  return supportsWasm;
}

function createObjectClient(grip) {
  return debuggerClient.createObjectClient(grip);
}

async function loadObjectProperties(root) {
  const utils = _devtoolsReps2.default.objectInspector.utils;
  const properties = await utils.loadProperties.loadItemProperties(root, createObjectClient);
  return utils.node.getChildren({
    item: root,
    loadedProperties: new Map([[root.path, properties]])
  });
}

function releaseActor(actor) {
  if (!actor) {
    return;
  }

  return debuggerClient.release(actor);
}

function sendPacket(packet) {
  return debuggerClient.request(packet);
}

function lookupThreadClient(thread) {
  if (thread == threadClient.actor) {
    return threadClient;
  }
  if (!workerClients[thread]) {
    throw new Error(`Unknown thread client: ${thread}`);
  }
  return workerClients[thread].thread;
}

function lookupConsoleClient(thread) {
  if (thread == threadClient.actor) {
    return tabTarget.activeConsole;
  }
  return workerClients[thread].console;
}

function listWorkerThreadClients() {
  return Object.values(workerClients).map(({ thread }) => thread);
}

function forEachWorkerThread(iteratee) {
  const promises = listWorkerThreadClients().map(thread => iteratee(thread));

  // Do not return promises for the caller to wait on unless a flag is set.
  // Currently, worker threads are not guaranteed to respond to all requests,
  // if we send a request while they are shutting down. See bug 1529163.
  if (shouldWaitForWorkers) {
    return Promise.all(promises);
  }
}

function resume(thread) {
  return lookupThreadClient(thread).resume();
}

function stepIn(thread) {
  return lookupThreadClient(thread).stepIn();
}

function stepOver(thread) {
  return lookupThreadClient(thread).stepOver();
}

function stepOut(thread) {
  return lookupThreadClient(thread).stepOut();
}

function rewind(thread) {
  return lookupThreadClient(thread).rewind();
}

function reverseStepIn(thread) {
  return lookupThreadClient(thread).reverseStepIn();
}

function reverseStepOver(thread) {
  return lookupThreadClient(thread).reverseStepOver();
}

function reverseStepOut(thread) {
  return lookupThreadClient(thread).reverseStepOut();
}

function breakOnNext(thread) {
  return lookupThreadClient(thread).breakOnNext();
}

async function sourceContents({
  actor,
  thread
}) {
  const sourceThreadClient = lookupThreadClient(thread);
  const sourceFront = sourceThreadClient.source({ actor });
  const { source, contentType } = await sourceFront.source();
  return { source, contentType };
}

function setXHRBreakpoint(path, method) {
  return threadClient.setXHRBreakpoint(path, method);
}

function removeXHRBreakpoint(path, method) {
  return threadClient.removeXHRBreakpoint(path, method);
}

// Get the string key to use for a breakpoint location.
// See also duplicate code in breakpoint-actor-map.js :(
function locationKey(location) {
  const { sourceUrl, line, column } = location;
  const sourceId = location.sourceId || "";
  return `${sourceUrl}:${sourceId}:${line}:${column}`;
}

function waitForWorkers(shouldWait) {
  shouldWaitForWorkers = shouldWait;
}

function detachWorkers() {
  for (const thread of listWorkerThreadClients()) {
    thread.detach();
  }
}

function maybeGenerateLogGroupId(options) {
  if (options.logValue && tabTarget.traits && tabTarget.traits.canRewind) {
    return { ...options, logGroupId: `logGroup-${Math.random()}` };
  }
  return options;
}

function maybeClearLogpoint(location) {
  const bp = breakpoints[locationKey(location)];
  if (bp && bp.options.logGroupId && tabTarget.activeConsole) {
    tabTarget.activeConsole.emit("clearLogpointMessages", bp.options.logGroupId);
  }
}

function hasBreakpoint(location) {
  return !!breakpoints[locationKey(location)];
}

async function setBreakpoint(location, options) {
  maybeClearLogpoint(location);
  options = maybeGenerateLogGroupId(options);
  breakpoints[locationKey(location)] = { location, options };

  // We have to be careful here to atomically initiate the setBreakpoint() call
  // on every thread, with no intervening await. Otherwise, other code could run
  // and change or remove the breakpoint before we finish calling setBreakpoint
  // on all threads. Requests on server threads will resolve in FIFO order, and
  // this could result in the breakpoint state here being out of sync with the
  // breakpoints that are installed in the server.
  const mainThreadPromise = threadClient.setBreakpoint(location, options);

  await forEachWorkerThread(thread => thread.setBreakpoint(location, options));
  await mainThreadPromise;
}

async function removeBreakpoint(location) {
  maybeClearLogpoint(location);
  delete breakpoints[locationKey(location)];

  // Delay waiting on this promise, for the same reason as in setBreakpoint.
  const mainThreadPromise = threadClient.removeBreakpoint(location);

  await forEachWorkerThread(thread => thread.removeBreakpoint(location));
  await mainThreadPromise;
}

async function evaluateInFrame(script, options) {
  return evaluate(script, options);
}

async function evaluateExpressions(scripts, options) {
  return Promise.all(scripts.map(script => evaluate(script, options)));
}

function evaluate(script, { thread, frameId } = {}) {
  const params = { thread, frameActor: frameId };
  if (!tabTarget || !script) {
    return Promise.resolve({ result: null });
  }

  const console = thread ? lookupConsoleClient(thread) : tabTarget.activeConsole;
  if (!console) {
    return Promise.resolve({ result: null });
  }

  return console.evaluateJSAsync(script, params);
}

function autocomplete(input, cursor, frameId) {
  if (!tabTarget || !tabTarget.activeConsole || !input) {
    return Promise.resolve({});
  }
  return new Promise(resolve => {
    tabTarget.activeConsole.autocomplete(input, cursor, result => resolve(result), frameId);
  });
}

function navigate(url) {
  return tabTarget.navigateTo({ url });
}

function reload() {
  return tabTarget.reload();
}

function getProperties(thread, grip) {
  const objClient = lookupThreadClient(thread).pauseGrip(grip);

  return objClient.getPrototypeAndProperties().then(resp => {
    const { ownProperties, safeGetterValues } = resp;
    for (const name in safeGetterValues) {
      const { enumerable, writable, getterValue } = safeGetterValues[name];
      ownProperties[name] = { enumerable, writable, value: getterValue };
    }
    return resp;
  });
}

async function getFrameScopes(frame) {
  if (frame.scope) {
    return frame.scope;
  }

  const sourceThreadClient = lookupThreadClient(frame.thread);
  return sourceThreadClient.getEnvironment(frame.id);
}

async function pauseOnExceptions(shouldPauseOnExceptions, shouldPauseOnCaughtExceptions) {
  await threadClient.pauseOnExceptions(shouldPauseOnExceptions,
  // Providing opposite value because server
  // uses "shouldIgnoreCaughtExceptions"
  !shouldPauseOnCaughtExceptions);

  await forEachWorkerThread(thread => thread.pauseOnExceptions(shouldPauseOnExceptions, !shouldPauseOnCaughtExceptions));
}

async function blackBox(sourceActor, isBlackBoxed, range) {
  const sourceFront = threadClient.source({ actor: sourceActor.actor });
  if (isBlackBoxed) {
    await sourceFront.unblackBox(range);
  } else {
    await sourceFront.blackBox(range);
  }
}

async function setSkipPausing(shouldSkip) {
  await threadClient.skipBreakpoints(shouldSkip);
  await forEachWorkerThread(thread => thread.skipBreakpoints(shouldSkip));
}

function interrupt(thread) {
  return lookupThreadClient(thread).interrupt();
}

function setEventListenerBreakpoints(eventTypes) {
  // TODO: Figure out what sendpoint we want to hit
}

function pauseGrip(thread, func) {
  return lookupThreadClient(thread).pauseGrip(func);
}

function registerSourceActor(sourceActorId, sourceId) {
  sourceActors[sourceActorId] = sourceId;
}

async function getSources(client) {
  const { sources } = await client.getSources();

  return sources.map(source => (0, _create.prepareSourcePayload)(client, source));
}

async function fetchSources() {
  return getSources(threadClient);
}

function getSourceForActor(actor) {
  if (!sourceActors[actor]) {
    throw new Error(`Unknown source actor: ${actor}`);
  }
  return sourceActors[actor];
}

async function fetchWorkers() {
  if (_prefs.features.windowlessWorkers) {
    const options = {
      breakpoints,
      observeAsmJS: true
    };

    const newWorkerClients = await (0, _workers.updateWorkerClients)({
      tabTarget,
      debuggerClient,
      threadClient,
      workerClients,
      options
    });

    // Fetch the sources and install breakpoints on any new workers.
    const workerNames = Object.getOwnPropertyNames(newWorkerClients);
    for (const actor of workerNames) {
      if (!workerClients[actor]) {
        const client = newWorkerClients[actor].thread;
        getSources(client);
      }
    }

    workerClients = newWorkerClients;

    return workerNames.map(actor => (0, _create.createWorker)(actor, workerClients[actor].url));
  }

  if (!(0, _workers.supportsWorkers)(tabTarget)) {
    return Promise.resolve([]);
  }

  const { workers } = await tabTarget.listWorkers();
  return workers;
}

function getMainThread() {
  return threadClient.actor;
}

async function getBreakpointPositions(actors, range) {
  const sourcePositions = {};

  for (const { thread, actor } of actors) {
    const sourceThreadClient = lookupThreadClient(thread);
    const sourceFront = sourceThreadClient.source({ actor });
    const positions = await sourceFront.getBreakpointPositionsCompressed(range);

    for (const line of Object.keys(positions)) {
      let columns = positions[line];
      const existing = sourcePositions[line];
      if (existing) {
        columns = [...new Set([...existing, ...columns])];
      }

      sourcePositions[line] = columns;
    }
  }
  return sourcePositions;
}

async function getBreakableLines(actors) {
  let lines = [];
  for (const { thread, actor } of actors) {
    const sourceThreadClient = lookupThreadClient(thread);
    const sourceFront = sourceThreadClient.source({ actor });
    let actorLines = [];
    try {
      actorLines = await sourceFront.getBreakableLines();
    } catch (e) {
      // Handle backward compatibility
      if (e.message && e.message.match(/does not recognize the packet type getBreakableLines/)) {
        const pos = await sourceFront.getBreakpointPositionsCompressed();
        actorLines = Object.keys(pos).map(line => Number(line));
      } else if (!e.message || !e.message.match(/Connection closed/)) {
        throw e;
      }
    }

    lines = [...new Set([...lines, ...actorLines])];
  }

  return lines;
}

const clientCommands = {
  autocomplete,
  blackBox,
  createObjectClient,
  loadObjectProperties,
  releaseActor,
  interrupt,
  pauseGrip,
  resume,
  stepIn,
  stepOut,
  stepOver,
  rewind,
  reverseStepIn,
  reverseStepOut,
  reverseStepOver,
  breakOnNext,
  sourceContents,
  getSourceForActor,
  getBreakpointPositions,
  getBreakableLines,
  hasBreakpoint,
  setBreakpoint,
  setXHRBreakpoint,
  removeXHRBreakpoint,
  removeBreakpoint,
  evaluate,
  evaluateInFrame,
  evaluateExpressions,
  navigate,
  reload,
  getProperties,
  getFrameScopes,
  pauseOnExceptions,
  fetchSources,
  registerSourceActor,
  fetchWorkers,
  getMainThread,
  sendPacket,
  setSkipPausing,
  setEventListenerBreakpoints,
  waitForWorkers,
  detachWorkers,
  hasWasmSupport,
  lookupConsoleClient
};

exports.setupCommands = setupCommands;
exports.clientCommands = clientCommands;

/***/ }),
/* 559 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addThreadEventListeners = exports.clientEvents = exports.setupEvents = undefined;

var _create = __webpack_require__(539);

var _sourceQueue = __webpack_require__(513);

var _sourceQueue2 = _interopRequireDefault(_sourceQueue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const CALL_STACK_PAGE_SIZE = 1000; /* This Source Code Form is subject to the terms of the Mozilla Public
                                    * License, v. 2.0. If a copy of the MPL was not distributed with this
                                    * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

let actions;
let isInterrupted;

function addThreadEventListeners(client) {
  Object.keys(clientEvents).forEach(eventName => {
    client.addListener(eventName, clientEvents[eventName].bind(null, client));
  });
}

function setupEvents(dependencies) {
  const threadClient = dependencies.threadClient;
  const tabTarget = dependencies.tabTarget;
  actions = dependencies.actions;
  _sourceQueue2.default.initialize(actions);

  addThreadEventListeners(threadClient);
  tabTarget.on("workerListChanged", workerListChanged);
}

async function paused(threadClient, _, packet) {
  // If paused by an explicit interrupt, which are generated by the
  // slow script dialog and internal events such as setting
  // breakpoints, ignore the event.
  const { why } = packet;
  if (why.type === "interrupted" && !packet.why.onNext) {
    isInterrupted = true;
    return;
  }

  let response;
  try {
    // Eagerly fetch the frames
    response = await threadClient.getFrames(0, CALL_STACK_PAGE_SIZE);
  } catch (e) {
    console.log(e);
    return;
  }

  // NOTE: this happens if we fetch frames and then immediately navigate
  if (!response.hasOwnProperty("frames")) {
    return;
  }

  if (why.type != "alreadyPaused") {
    const pause = (0, _create.createPause)(threadClient.actor, packet, response);
    await _sourceQueue2.default.flush();
    actions.paused(pause);
  }
}

function resumed(threadClient, _, packet) {
  // NOTE: the client suppresses resumed events while interrupted
  // to prevent unintentional behavior.
  // see [client docs](../README.md#interrupted) for more information.
  if (isInterrupted) {
    isInterrupted = false;
    return;
  }

  actions.resumed(packet);
}

function newSource(threadClient, _, { source }) {
  _sourceQueue2.default.queue({
    type: "generated",
    data: (0, _create.prepareSourcePayload)(threadClient, source)
  });
}

function workerListChanged() {
  actions.updateWorkers();
}

const clientEvents = {
  paused,
  resumed,
  newSource
};

exports.setupEvents = setupEvents;
exports.clientEvents = clientEvents;
exports.addThreadEventListeners = addThreadEventListeners;

/***/ }),
/* 560 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fromServerLocation = fromServerLocation;
exports.toServerLocation = toServerLocation;
exports.createFrame = createFrame;
exports.createLoadedObject = createLoadedObject;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function fromServerLocation(serverLocation) {
  if (serverLocation) {
    return {
      sourceId: serverLocation.scriptId,
      line: serverLocation.lineNumber + 1,
      column: serverLocation.columnNumber,
      sourceUrl: ""
    };
  }
}

function toServerLocation(location) {
  return {
    scriptId: location.sourceId,
    lineNumber: location.line - 1
  };
}

function createFrame(frame) {
  const location = fromServerLocation(frame.location);
  if (!location) {
    return null;
  }

  return {
    id: frame.callFrameId,
    displayName: frame.functionName,
    scopeChain: frame.scopeChain,
    generatedLocation: location,
    location
  };
}

function createLoadedObject(serverObject, parentId) {
  const { value, name } = serverObject;

  return {
    objectId: value.objectId,
    parentId,
    name,
    value
  };
}

/***/ }),
/* 561 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createEditor = createEditor;
exports.createHeadlessEditor = createHeadlessEditor;

var _sourceEditor = __webpack_require__(562);

var _sourceEditor2 = _interopRequireDefault(_sourceEditor);

var _prefs = __webpack_require__(492);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function createEditor() {
  const gutters = ["breakpoints", "hit-markers", "CodeMirror-linenumbers"];

  if (_prefs.features.codeFolding) {
    gutters.push("CodeMirror-foldgutter");
  }

  return new _sourceEditor2.default({
    mode: "javascript",
    foldGutter: _prefs.features.codeFolding,
    enableCodeFolding: _prefs.features.codeFolding,
    readOnly: true,
    lineNumbers: true,
    theme: "mozilla",
    styleActiveLine: false,
    lineWrapping: _prefs.prefs.editorWrapping,
    matchBrackets: true,
    showAnnotationRuler: true,
    gutters,
    value: " ",
    extraKeys: {
      // Override code mirror keymap to avoid conflicts with split console.
      Esc: false,
      "Cmd-F": false,
      "Ctrl-F": false,
      "Cmd-G": false,
      "Ctrl-G": false
    }
  });
}

function createHeadlessEditor() {
  const editor = createEditor();
  editor.appendToLocalElement(document.createElement("div"));
  return editor;
}

/***/ }),
/* 562 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_562__;

/***/ }),
/* 563 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addToTree = addToTree;

var _utils = __webpack_require__(506);

var _treeOrder = __webpack_require__(564);

var _getURL = __webpack_require__(541);

function createNodeInTree(part, path, tree, index) {
  const node = (0, _utils.createDirectoryNode)(part, path, []);

  // we are modifying the tree
  const contents = tree.contents.slice(0);
  contents.splice(index, 0, node);
  tree.contents = contents;

  return node;
}

/*
 * Look for the child directory
 * 1. if it exists return it
 * 2. if it does not exist create it
 * 3. if it is a file, replace it with a directory
 */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function findOrCreateNode(parts, subTree, path, part, index, url, debuggeeHost, source) {
  const addedPartIsFile = (0, _utils.partIsFile)(index, parts, url);

  const { found: childFound, index: childIndex } = (0, _treeOrder.findNodeInContents)(subTree, (0, _treeOrder.createTreeNodeMatcher)(part, !addedPartIsFile, debuggeeHost));

  // we create and enter the new node
  if (!childFound) {
    return createNodeInTree(part, path, subTree, childIndex);
  }

  // we found a path with the same name as the part. We need to determine
  // if this is the correct child, or if we have a naming conflict
  const child = subTree.contents[childIndex];
  const childIsFile = !(0, _utils.nodeHasChildren)(child);

  // if we have a naming conflict, we'll create a new node
  if (child.type === "source" || !childIsFile && addedPartIsFile) {
    // pass true to findNodeInContents to sort node by url
    const { index: insertIndex } = (0, _treeOrder.findNodeInContents)(subTree, (0, _treeOrder.createTreeNodeMatcher)(part, !addedPartIsFile, debuggeeHost, source, true));
    return createNodeInTree(part, path, subTree, insertIndex);
  }

  // if there is no naming conflict, we can traverse into the child
  return child;
}

/*
 * walk the source tree to the final node for a given url,
 * adding new nodes along the way
 */
function traverseTree(url, tree, debuggeeHost, source, thread) {
  const parts = url.path.split("/").filter(p => p !== "");
  parts.unshift(url.group);
  if (thread) {
    parts.unshift(thread);
  }

  let path = "";
  return parts.reduce((subTree, part, index) => {
    if (index == 0 && thread) {
      path = thread;
    } else {
      path = `${path}/${part}`;
    }

    const debuggeeHostIfRoot = index === 1 ? debuggeeHost : null;

    return findOrCreateNode(parts, subTree, path, part, index, url, debuggeeHostIfRoot, source);
  }, tree);
}

/*
 * Add a source file to a directory node in the tree
 */
function addSourceToNode(node, url, source) {
  const isFile = !(0, _utils.isPathDirectory)(url.path);

  if (node.type == "source") {
    throw new Error(`Unexpected type "source" at: ${node.name}`);
  }

  // if we have a file, and the subtree has no elements, overwrite the
  // subtree contents with the source
  if (isFile) {
    // $FlowIgnore
    node.type = "source";
    return source;
  }

  const { filename } = url;
  const { found: childFound, index: childIndex } = (0, _treeOrder.findNodeInContents)(node, (0, _treeOrder.createTreeNodeMatcher)(filename, false, null));

  // if we are readding an existing file in the node, overwrite the existing
  // file and return the node's contents
  if (childFound) {
    const existingNode = node.contents[childIndex];
    if (existingNode.type === "source") {
      existingNode.contents = source;
    }

    return node.contents;
  }

  // if this is a new file, add the new file;
  const newNode = (0, _utils.createSourceNode)(filename, source.url, source);
  const contents = node.contents.slice(0);
  contents.splice(childIndex, 0, newNode);
  return contents;
}

/**
 * @memberof utils/sources-tree
 * @static
 */
function addToTree(tree, source, debuggeeHost, thread) {
  const url = (0, _getURL.getURL)(source, debuggeeHost);

  if ((0, _utils.isInvalidUrl)(url, source)) {
    return;
  }

  const finalNode = traverseTree(url, tree, debuggeeHost, source, thread);

  // $FlowIgnore
  finalNode.contents = addSourceToNode(finalNode, url, source);
}

/***/ }),
/* 564 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDomain = getDomain;
exports.findNodeInContents = findNodeInContents;
exports.createTreeNodeMatcher = createTreeNodeMatcher;

var _url = __webpack_require__(515);

var _utils = __webpack_require__(506);

/*
 * Gets domain from url (without www prefix)
 */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function getDomain(url) {
  // TODO: define how files should be ordered on the browser debugger
  if (!url) {
    return null;
  }
  const { host } = (0, _url.parse)(url);
  if (!host) {
    return null;
  }
  return host.startsWith("www.") ? host.substr("www.".length) : host;
}

/*
 * Checks if node name matches debugger host/domain.
 */
function isExactDomainMatch(part, debuggeeHost) {
  return part.startsWith("www.") ? part.substr("www.".length) === debuggeeHost : part === debuggeeHost;
}

/*
 * Function to assist with node search for a defined sorted order, see e.g.
 * `createTreeNodeMatcher`. Returns negative number if the node
 * stands earlier in sorting order, positive number if the node stands later
 * in sorting order, or zero if the node is found.
 */


/*
 * Performs a binary search to insert a node into contents. Returns positive
 * number, index of the found child, or negative number, which can be used
 * to calculate a position where a new node can be inserted (`-index - 1`).
 * The matcher is a function that returns result of comparision of a node with
 * lookup value.
 */
function findNodeInContents(tree, matcher) {
  if (tree.type === "source" || tree.contents.length === 0) {
    return { found: false, index: 0 };
  }

  let left = 0;
  let right = tree.contents.length - 1;
  while (left < right) {
    const middle = Math.floor((left + right) / 2);
    if (matcher(tree.contents[middle]) < 0) {
      left = middle + 1;
    } else {
      right = middle;
    }
  }
  const result = matcher(tree.contents[left]);
  if (result === 0) {
    return { found: true, index: left };
  }
  return { found: false, index: result > 0 ? left : left + 1 };
}

const IndexName = "(index)";

function createTreeNodeMatcherWithIndex() {
  return node => node.name === IndexName ? 0 : 1;
}

function createTreeNodeMatcherWithDebuggeeHost(debuggeeHost) {
  return node => {
    if (node.name === IndexName) {
      return -1;
    }
    return isExactDomainMatch(node.name, debuggeeHost) ? 0 : 1;
  };
}

function createTreeNodeMatcherWithNameAndOther(part, isDir, debuggeeHost, source, sortByUrl) {
  return node => {
    if (node.name === IndexName) {
      return -1;
    }
    if (debuggeeHost && isExactDomainMatch(node.name, debuggeeHost)) {
      return -1;
    }
    const nodeIsDir = (0, _utils.nodeHasChildren)(node);
    if (nodeIsDir && !isDir) {
      return -1;
    } else if (!nodeIsDir && isDir) {
      return 1;
    }
    if (sortByUrl && node.type === "source" && source) {
      return node.contents.url.localeCompare(source.url);
    }

    return node.name.localeCompare(part);
  };
}

/*
 * Creates a matcher for findNodeInContents.
 * The sorting order of nodes during comparison is:
 * - "(index)" node
 * - root node with the debuggee host/domain
 * - hosts/directories (not files) sorted by name
 * - files sorted by name
 */
function createTreeNodeMatcher(part, isDir, debuggeeHost, source, sortByUrl) {
  if (part === IndexName) {
    // Specialied matcher, when we are looking for "(index)" position.
    return createTreeNodeMatcherWithIndex();
  }

  if (debuggeeHost && isExactDomainMatch(part, debuggeeHost)) {
    // Specialied matcher, when we are looking for domain position.
    return createTreeNodeMatcherWithDebuggeeHost(debuggeeHost);
  }

  // Rest of the cases, without mentioned above.
  return createTreeNodeMatcherWithNameAndOther(part, isDir, debuggeeHost, source, sortByUrl);
}

/***/ }),
/* 565 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.collapseTree = collapseTree;

var _utils = __webpack_require__(506);

/**
 * Take an existing source tree, and return a new one with collapsed nodes.
 */
function _collapseTree(node, depth) {
  // Node is a folder.
  if (node.type === "directory") {
    if (!Array.isArray(node.contents)) {
      console.log(`Expected array at: ${node.path}`);
    }

    // Node is not a (1) thread and (2) root/domain node,
    // and only contains 1 item.
    if (depth > 2 && node.contents.length === 1) {
      const next = node.contents[0];
      // Do not collapse if the next node is a leaf node.
      if (next.type === "directory") {
        if (!Array.isArray(next.contents)) {
          console.log(`Expected array at: ${next.name} -- ${node.name} -- ${JSON.stringify(next.contents)}`);
        }
        const name = `${node.name}/${next.name}`;
        const nextNode = (0, _utils.createDirectoryNode)(name, next.path, next.contents);
        return _collapseTree(nextNode, depth + 1);
      }
    }

    // Map the contents.
    return (0, _utils.createDirectoryNode)(node.name, node.path, node.contents.map(next => _collapseTree(next, depth + 1)));
  }

  // Node is a leaf, not a folder, do not modify it.
  return node;
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function collapseTree(node) {
  const tree = _collapseTree(node, 0);
  return tree;
}

/***/ }),
/* 566 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bootstrapStore = bootstrapStore;
exports.bootstrapWorkers = bootstrapWorkers;
exports.teardownWorkers = teardownWorkers;
exports.bootstrapApp = bootstrapApp;

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _redux = __webpack_require__(517);

var _reactDom = __webpack_require__(112);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _devtoolsEnvironment = __webpack_require__(102);

var _devtoolsSourceMap = __webpack_require__(182);

var _devtoolsSourceMap2 = _interopRequireDefault(_devtoolsSourceMap);

var _search = __webpack_require__(542);

var search = _interopRequireWildcard(_search);

var _prettyPrint = __webpack_require__(567);

var prettyPrint = _interopRequireWildcard(_prettyPrint);

var _parser = __webpack_require__(503);

var parser = _interopRequireWildcard(_parser);

var _createStore = __webpack_require__(631);

var _createStore2 = _interopRequireDefault(_createStore);

var _reducers = __webpack_require__(651);

var _reducers2 = _interopRequireDefault(_reducers);

var _selectors = __webpack_require__(490);

var selectors = _interopRequireWildcard(_selectors);

var _App = __webpack_require__(653);

var _App2 = _interopRequireDefault(_App);

var _prefs = __webpack_require__(492);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const { Provider } = __webpack_require__(484); /* This Source Code Form is subject to the terms of the Mozilla Public
                                              * License, v. 2.0. If a copy of the MPL was not distributed with this
                                              * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function renderPanel(component, store) {
  const root = document.createElement("div");
  root.className = "launchpad-root theme-body";
  root.style.setProperty("flex", "1");
  const mount = document.querySelector("#mount");
  if (!mount) {
    return;
  }
  mount.appendChild(root);

  _reactDom2.default.render(_react2.default.createElement(Provider, { store }, _react2.default.createElement(component)), root);
}

function bootstrapStore(client, sourceMaps, panel, initialState) {
  const createStore = (0, _createStore2.default)({
    log: _prefs.prefs.logging || (0, _devtoolsEnvironment.isTesting)(),
    timing: (0, _devtoolsEnvironment.isDevelopment)(),
    makeThunkArgs: (args, state) => {
      return { ...args, client, sourceMaps, panel };
    }
  });

  const store = createStore((0, _redux.combineReducers)(_reducers2.default), initialState);
  store.subscribe(() => updatePrefs(store.getState()));

  const actions = (0, _redux.bindActionCreators)(__webpack_require__(493).default, store.dispatch);

  return { store, actions, selectors };
}

function bootstrapWorkers() {
  const workerPath = (0, _devtoolsEnvironment.isDevelopment)() ? "assets/build" : "resource://devtools/client/debugger/dist";

  if ((0, _devtoolsEnvironment.isDevelopment)()) {
    // When used in Firefox, the toolbox manages the source map worker.
    (0, _devtoolsSourceMap.startSourceMapWorker)(`${workerPath}/source-map-worker.js`,
    // This is relative to the worker itself.
    "./source-map-worker-assets/");
  }

  prettyPrint.start(`${workerPath}/pretty-print-worker.js`);
  parser.start(`${workerPath}/parser-worker.js`);
  search.start(`${workerPath}/search-worker.js`);
  return { prettyPrint, parser, search };
}

function teardownWorkers() {
  if (!(0, _devtoolsEnvironment.isFirefoxPanel)()) {
    // When used in Firefox, the toolbox manages the source map worker.
    (0, _devtoolsSourceMap.stopSourceMapWorker)();
  }
  prettyPrint.stop();
  parser.stop();
  search.stop();
}

function bootstrapApp(store) {
  if ((0, _devtoolsEnvironment.isFirefoxPanel)()) {
    renderPanel(_App2.default, store);
  } else {
    const { renderRoot } = __webpack_require__(103);
    renderRoot(_react2.default, _reactDom2.default, _App2.default, store);
  }
}

let currentPendingBreakpoints;
let currentXHRBreakpoints;
function updatePrefs(state) {
  const previousPendingBreakpoints = currentPendingBreakpoints;
  const previousXHRBreakpoints = currentXHRBreakpoints;
  currentPendingBreakpoints = selectors.getPendingBreakpoints(state);
  currentXHRBreakpoints = selectors.getXHRBreakpoints(state);

  if (previousPendingBreakpoints && currentPendingBreakpoints !== previousPendingBreakpoints) {
    _prefs.asyncStore.pendingBreakpoints = currentPendingBreakpoints;
  }

  if (currentXHRBreakpoints !== previousXHRBreakpoints) {
    _prefs.asyncStore.xhrBreakpoints = currentXHRBreakpoints;
  }
}

/***/ }),
/* 567 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stop = exports.start = undefined;
exports.prettyPrint = prettyPrint;

var _devtoolsUtils = __webpack_require__(7);

const { WorkerDispatcher } = _devtoolsUtils.workerUtils; /* This Source Code Form is subject to the terms of the Mozilla Public
                                                          * License, v. 2.0. If a copy of the MPL was not distributed with this
                                                          * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const dispatcher = new WorkerDispatcher();
const start = exports.start = dispatcher.start.bind(dispatcher);
const stop = exports.stop = dispatcher.stop.bind(dispatcher);

async function prettyPrint({ text, url }) {
  return dispatcher.invoke("prettyPrint", {
    url,
    indent: 2,
    sourceText: text
  });
}

/***/ }),
/* 568 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ContextError = undefined;
exports.validateNavigateContext = validateNavigateContext;
exports.validateContext = validateContext;

var _selectors = __webpack_require__(490);

// Context encapsulates the main parameters of the current redux state, which
// impact most other information tracked by the debugger.
//
// The main use of Context is to control when asynchronous operations are
// allowed to make changes to the program state. Such operations might be
// invalidated as the state changes from the time the operation was originally
// initiated. For example, operations on pause state might still continue even
// after the thread unpauses.
//
// The methods below can be used to compare an old context with the current one
// and see if the operation is now invalid and should be abandoned. Actions can
// also include a 'cx' Context property, which will be checked by the context
// middleware. If the action fails validateContextAction() then it will not be
// dispatched.
//
// Context can additionally be used as a shortcut to access the main properties
// of the pause state.

// A normal Context is invalidated if the target navigates.


// A ThreadContext is invalidated if the target navigates, or if the current
// thread changes, pauses, or resumes.
class ContextError extends Error {}

exports.ContextError = ContextError; /* This Source Code Form is subject to the terms of the Mozilla Public
                                      * License, v. 2.0. If a copy of the MPL was not distributed with this
                                      * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function validateNavigateContext(state, cx) {
  const newcx = (0, _selectors.getThreadContext)(state);

  if (newcx.navigateCounter != cx.navigateCounter) {
    throw new ContextError("Page has navigated");
  }
}

function validateThreadContext(state, cx) {
  const newcx = (0, _selectors.getThreadContext)(state);

  if (cx.thread != newcx.thread) {
    throw new ContextError("Current thread has changed");
  }

  if (cx.pauseCounter != newcx.pauseCounter) {
    throw new ContextError("Current thread has paused or resumed");
  }
}

function validateContext(state, cx) {
  validateNavigateContext(state, cx);

  if ("thread" in cx) {
    validateThreadContext(state, cx);
  }
}

/***/ }),
/* 569 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getExpressionError = exports.getAutocompleteMatches = exports.getExpressions = exports.createExpressionState = undefined;
exports.getExpression = getExpression;
exports.getAutocompleteMatchset = getAutocompleteMatchset;

var _makeRecord = __webpack_require__(527);

var _makeRecord2 = _interopRequireDefault(_makeRecord);

var _immutable = __webpack_require__(543);

var _lodash = __webpack_require__(417);

var _reselect = __webpack_require__(444);

var _prefs = __webpack_require__(492);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const createExpressionState = exports.createExpressionState = (0, _makeRecord2.default)({
  expressions: (0, _immutable.List)(restoreExpressions()),
  expressionError: false,
  autocompleteMatches: (0, _immutable.Map)({}),
  currentAutocompleteInput: null
}); /* This Source Code Form is subject to the terms of the Mozilla Public
     * License, v. 2.0. If a copy of the MPL was not distributed with this
     * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/**
 * Expressions reducer
 * @module reducers/expressions
 */

function update(state = createExpressionState(), action) {
  switch (action.type) {
    case "ADD_EXPRESSION":
      if (action.expressionError) {
        return state.set("expressionError", !!action.expressionError);
      }
      return appendExpressionToList(state, {
        input: action.input,
        value: null,
        updating: true
      });

    case "UPDATE_EXPRESSION":
      const key = action.expression.input;
      return updateExpressionInList(state, key, {
        input: action.input,
        value: null,
        updating: true
      }).set("expressionError", !!action.expressionError);

    case "EVALUATE_EXPRESSION":
      return updateExpressionInList(state, action.input, {
        input: action.input,
        value: action.value,
        updating: false
      });

    case "EVALUATE_EXPRESSIONS":
      const { inputs, results } = action;

      return (0, _lodash.zip)(inputs, results).reduce((newState, [input, result]) => updateExpressionInList(newState, input, {
        input: input,
        value: result,
        updating: false
      }), state);

    case "DELETE_EXPRESSION":
      return deleteExpression(state, action.input);

    case "CLEAR_EXPRESSION_ERROR":
      return state.set("expressionError", false);

    case "AUTOCOMPLETE":
      const { matchProp, matches } = action.result;

      return state.updateIn(["autocompleteMatches", matchProp], list => matches).set("currentAutocompleteInput", matchProp);

    case "CLEAR_AUTOCOMPLETE":
      return state.updateIn(["autocompleteMatches", ""], list => []).set("currentAutocompleteInput", "");
  }

  return state;
}

function restoreExpressions() {
  const exprs = _prefs.prefs.expressions;
  if (exprs.length == 0) {
    return;
  }
  return exprs;
}

function storeExpressions({ expressions }) {
  _prefs.prefs.expressions = expressions.map(expression => (0, _lodash.omit)(expression, "value")).toJS();
}

function appendExpressionToList(state, value) {
  const newState = state.update("expressions", () => {
    return state.expressions.push(value);
  });

  storeExpressions(newState);
  return newState;
}

function updateExpressionInList(state, key, value) {
  const newState = state.update("expressions", () => {
    const list = state.expressions;
    const index = list.findIndex(e => e.input == key);
    return list.update(index, () => value);
  });

  storeExpressions(newState);
  return newState;
}

function deleteExpression(state, input) {
  const index = state.expressions.findIndex(e => e.input == input);
  const newState = state.deleteIn(["expressions", index]);
  storeExpressions(newState);
  return newState;
}

const getExpressionsWrapper = state => state.expressions;

const getExpressions = exports.getExpressions = (0, _reselect.createSelector)(getExpressionsWrapper, expressions => expressions.expressions);

const getAutocompleteMatches = exports.getAutocompleteMatches = (0, _reselect.createSelector)(getExpressionsWrapper, expressions => expressions.autocompleteMatches);

function getExpression(state, input) {
  return getExpressions(state).find(exp => exp.input == input);
}

function getAutocompleteMatchset(state) {
  const input = state.expressions.get("currentAutocompleteInput");
  return getAutocompleteMatches(state).get(input);
}

const getExpressionError = exports.getExpressionError = (0, _reselect.createSelector)(getExpressionsWrapper, expressions => expressions.expressionError);

exports.default = update;

/***/ }),
/* 570 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _core = __webpack_require__(544);

Object.defineProperty(exports, "createInitial", {
  enumerable: true,
  get: function () {
    return _core.createInitial;
  }
});
Object.defineProperty(exports, "insertResources", {
  enumerable: true,
  get: function () {
    return _core.insertResources;
  }
});
Object.defineProperty(exports, "removeResources", {
  enumerable: true,
  get: function () {
    return _core.removeResources;
  }
});
Object.defineProperty(exports, "updateResources", {
  enumerable: true,
  get: function () {
    return _core.updateResources;
  }
});

var _selector = __webpack_require__(639);

Object.defineProperty(exports, "hasResource", {
  enumerable: true,
  get: function () {
    return _selector.hasResource;
  }
});
Object.defineProperty(exports, "getResourceIds", {
  enumerable: true,
  get: function () {
    return _selector.getResourceIds;
  }
});
Object.defineProperty(exports, "getResource", {
  enumerable: true,
  get: function () {
    return _selector.getResource;
  }
});
Object.defineProperty(exports, "getMappedResource", {
  enumerable: true,
  get: function () {
    return _selector.getMappedResource;
  }
});

var _baseQuery = __webpack_require__(571);

Object.defineProperty(exports, "makeResourceQuery", {
  enumerable: true,
  get: function () {
    return _baseQuery.makeResourceQuery;
  }
});
Object.defineProperty(exports, "makeMapWithArgs", {
  enumerable: true,
  get: function () {
    return _baseQuery.makeMapWithArgs;
  }
});

var _query = __webpack_require__(640);

Object.defineProperty(exports, "filterAllIds", {
  enumerable: true,
  get: function () {
    return _query.filterAllIds;
  }
});
Object.defineProperty(exports, "makeWeakQuery", {
  enumerable: true,
  get: function () {
    return _query.makeWeakQuery;
  }
});
Object.defineProperty(exports, "makeShallowQuery", {
  enumerable: true,
  get: function () {
    return _query.makeShallowQuery;
  }
});
Object.defineProperty(exports, "makeStrictQuery", {
  enumerable: true,
  get: function () {
    return _query.makeStrictQuery;
  }
});
Object.defineProperty(exports, "makeIdQuery", {
  enumerable: true,
  get: function () {
    return _query.makeIdQuery;
  }
});
Object.defineProperty(exports, "makeLoadQuery", {
  enumerable: true,
  get: function () {
    return _query.makeLoadQuery;
  }
});
Object.defineProperty(exports, "makeFilterQuery", {
  enumerable: true,
  get: function () {
    return _query.makeFilterQuery;
  }
});
Object.defineProperty(exports, "makeReduceQuery", {
  enumerable: true,
  get: function () {
    return _query.makeReduceQuery;
  }
});
Object.defineProperty(exports, "makeReduceAllQuery", {
  enumerable: true,
  get: function () {
    return _query.makeReduceAllQuery;
  }
});

var _queryCache = __webpack_require__(572);

Object.defineProperty(exports, "queryCacheWeak", {
  enumerable: true,
  get: function () {
    return _queryCache.queryCacheWeak;
  }
});
Object.defineProperty(exports, "queryCacheShallow", {
  enumerable: true,
  get: function () {
    return _queryCache.queryCacheShallow;
  }
});
Object.defineProperty(exports, "queryCacheStrict", {
  enumerable: true,
  get: function () {
    return _queryCache.queryCacheStrict;
  }
});

var _memoize = __webpack_require__(573);

Object.defineProperty(exports, "memoizeResourceShallow", {
  enumerable: true,
  get: function () {
    return _memoize.memoizeResourceShallow;
  }
});

/***/ }),
/* 571 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeMapWithArgs = makeMapWithArgs;
exports.makeResourceQuery = makeResourceQuery;

var _core = __webpack_require__(544);

var _compare = __webpack_require__(528);

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function makeMapWithArgs(map) {
  const wrapper = (resource, identity, args) => map(resource, identity, args);
  wrapper.needsArgs = true;
  return wrapper;
}

function makeResourceQuery({
  cache,
  filter,
  map,
  reduce,
  resultCompare
}) {
  const loadResource = makeResourceMapper(map);

  return cache((state, context, existing) => {
    const ids = filter((0, _core.getResourceValues)(state), context.args);
    const mapped = ids.map(id => loadResource(state, id, context));

    if (existing && (0, _compare.arrayShallowEqual)(existing.mapped, mapped)) {
      // If the items are exactly the same as the existing ones, we return
      // early to reuse the existing result.
      return existing;
    }

    const reduced = reduce(mapped, ids, context.args);

    if (existing && resultCompare(existing.reduced, reduced)) {
      return existing;
    }

    return { mapped, reduced };
  });
}

function makeResourceMapper(map) {
  return map.needsArgs ? makeResourceArgsMapper(map) : makeResourceNoArgsMapper(map);
}

/**
 * Resources loaded when things care about arguments need to be given a
 * special ResourceIdentity object that correlates with both the resource
 * _and_ the arguments being passed to the query. That means they need extra
 * logic when loading those resources.
 */
function makeResourceArgsMapper(map) {
  const mapper = (value, identity, context) => map(value, getIdentity(context.identMap, identity), context.args);
  return (state, id, context) => getCachedResource(state, id, context, mapper);
}

function makeResourceNoArgsMapper(map) {
  const mapper = (value, identity, context) => map(value, identity);
  return (state, id, context) => getCachedResource(state, id, context, mapper);
}

function getCachedResource(state, id, context, map) {
  const pair = (0, _core.getResourcePair)(state, id);
  if (!pair) {
    throw new Error(`Resource ${id} does not exist`);
  }

  return map(pair.value, pair.identity, context);
}

function getIdentity(identMap, identity) {
  let ident = identMap.get(identity);
  if (!ident) {
    ident = (0, _core.makeIdentity)();
    identMap.set(identity, ident);
  }

  return ident;
}

/***/ }),
/* 572 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.queryCacheWeak = queryCacheWeak;
exports.queryCacheShallow = queryCacheShallow;
exports.queryCacheStrict = queryCacheStrict;

var _compare = __webpack_require__(528);

/**
 * A query 'cache' function that uses the identity of the arguments object to
 * cache data for the query itself.
 */
function queryCacheWeak(handler) {
  const cache = new WeakMap();
  return makeCacheFunction({
    handler,
    // The WeakMap will only return entries for the exact object,
    // so there is no need to compare at all.
    compareArgs: () => true,
    getEntry: args => cache.get(args) || null,
    setEntry: (args, entry) => {
      cache.set(args, entry);
    }
  });
}

/**
 * A query 'cache' function that uses shallow comparison to cache the most
 * recent calculated result based on the value of the argument.
 */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function queryCacheShallow(handler) {
  let latestEntry = null;
  return makeCacheFunction({
    handler,
    compareArgs: _compare.shallowEqual,
    getEntry: () => latestEntry,
    setEntry: (args, entry) => {
      latestEntry = entry;
    }
  });
}

/**
 * A query 'cache' function that uses strict comparison to cache the most
 * recent calculated result based on the value of the argument.
 */
function queryCacheStrict(handler) {
  let latestEntry = null;
  return makeCacheFunction({
    handler,
    compareArgs: _compare.strictEqual,
    getEntry: () => latestEntry,
    setEntry: (args, entry) => {
      latestEntry = entry;
    }
  });
}

function makeCacheFunction(info) {
  const { handler, compareArgs, getEntry, setEntry } = info;

  return (state, args) => {
    let entry = getEntry(args);

    const sameArgs = !!entry && compareArgs(entry.context.args, args);
    const sameState = !!entry && entry.state === state;

    if (!entry || !sameArgs || !sameState) {
      const context = !entry || !sameArgs ? {
        args,
        identMap: new WeakMap()
      } : entry.context;

      const result = handler(state, context, entry ? entry.result : null);

      if (entry) {
        entry.context = context;
        entry.state = state;
        entry.result = result;
      } else {
        entry = {
          context,
          state,
          result
        };
        setEntry(args, entry);
      }
    }

    return entry.result.reduced;
  };
}

/***/ }),
/* 573 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.memoizeResourceShallow = memoizeResourceShallow;

var _compare = __webpack_require__(528);

/**
 * Wraps a 'mapper' function to create a shallow-equality memoized version
 * of the mapped result. The returned function will return the same value
 * even if the input object is different, as long as the identity is the same
 * and the mapped result is shallow-equal to the most recent mapped value.
 */
function memoizeResourceShallow(map) {
  const cache = new WeakMap();

  const fn = (input, identity, args) => {
    let existingEntry = cache.get(identity);

    if (!existingEntry || existingEntry.input !== input) {
      const mapper = map;
      const output = mapper(input, identity, args);

      if (existingEntry) {
        // If the new output is shallow-equal to the old output, we reuse
        // the previous object instead to preserve object equality.
        const newOutput = (0, _compare.shallowEqual)(output, existingEntry.output) ? existingEntry.output : output;

        existingEntry.output = newOutput;
        existingEntry.input = input;
      } else {
        existingEntry = {
          input,
          output
        };
        cache.set(identity, existingEntry);
      }
    }

    return existingEntry.output;
  };
  fn.needsArgs = map.needsArgs;
  return fn;
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/***/ }),
/* 574 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findPosition = findPosition;

var _location = __webpack_require__(509);

var _selectedLocation = __webpack_require__(501);

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function findPosition(positions, location) {
  if (!positions) {
    return null;
  }

  const lineBps = positions[location.line];
  if (!lineBps) {
    return null;
  }
  return lineBps.find(pos => (0, _location.comparePosition)((0, _selectedLocation.getSelectedLocation)(pos, location), location));
}

/***/ }),
/* 575 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getActiveEventListeners = getActiveEventListeners;

var _lodash = __webpack_require__(417);

var _prefs = __webpack_require__(492);

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function update(state = [], action) {
  switch (action.type) {
    case "ADD_EVENT_LISTENERS":
      return updateEventTypes("add", state, action.events);

    case "REMOVE_EVENT_LISTENERS":
      return updateEventTypes("remove", state, action.events);

    default:
      return state;
  }
}

function updateEventTypes(addOrRemove, currentEvents, events) {
  let newEventListeners;

  if (addOrRemove === "add") {
    newEventListeners = (0, _lodash.uniq)([...currentEvents, ...events]);
  } else {
    newEventListeners = currentEvents.filter(event => !events.includes(event));
  }

  _prefs.asyncStore.eventListenerBreakpoints = newEventListeners;
  return newEventListeners;
}

function getActiveEventListeners(state) {
  return state.eventListenerBreakpoints;
}

exports.default = update;

/***/ }),
/* 576 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getVisibleSelectedFrame = exports.getSelectedFrames = undefined;
exports.getSelectedFrame = getSelectedFrame;

var _pause = __webpack_require__(530);

var _sources = __webpack_require__(498);

var _selectedLocation = __webpack_require__(501);

var _reselect = __webpack_require__(444);

// eslint-disable-next-line

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const getSelectedFrames = exports.getSelectedFrames = (0, _reselect.createSelector)(state => state.pause.threads, threadPauseState => {
  const selectedFrames = {};
  for (const thread in threadPauseState) {
    const pausedThread = threadPauseState[thread];
    const { selectedFrameId, frames } = pausedThread;
    if (frames) {
      selectedFrames[thread] = frames.find(frame => frame.id == selectedFrameId);
    }
  }
  return selectedFrames;
});

function getSelectedFrame(state, thread) {
  const selectedFrames = getSelectedFrames(state);
  return selectedFrames[thread];
}

const getVisibleSelectedFrame = exports.getVisibleSelectedFrame = (0, _reselect.createSelector)(_sources.getSelectedLocation, getSelectedFrames, _pause.getCurrentThread, (selectedLocation, selectedFrames, thread) => {
  const selectedFrame = selectedFrames[thread];
  if (!selectedFrame) {
    return null;
  }

  const { id } = selectedFrame;

  return {
    id,
    location: (0, _selectedLocation.getSelectedLocation)(selectedFrame, selectedLocation)
  };
});

/***/ }),
/* 577 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getThreads = exports.getWorkerCount = exports.getWorkers = undefined;
exports.initialDebuggeeState = initialDebuggeeState;
exports.default = debuggee;
exports.getWorkerByThread = getWorkerByThread;
exports.getMainThread = getMainThread;
exports.getDebuggeeUrl = getDebuggeeUrl;

var _lodash = __webpack_require__(417);

var _reselect = __webpack_require__(444);

var _workers = __webpack_require__(531);

function initialDebuggeeState() {
  return {
    workers: [],
    mainThread: { actor: "", url: "", type: -1, name: "" }
  };
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/**
 * Debuggee reducer
 * @module reducers/debuggee
 */

function debuggee(state = initialDebuggeeState(), action) {
  switch (action.type) {
    case "CONNECT":
      return {
        ...state,
        mainThread: { ...action.mainThread, name: L10N.getStr("mainThread") }
      };
    case "INSERT_WORKERS":
      return insertWorkers(state, action.workers);
    case "REMOVE_WORKERS":
      const { workers } = action;
      return {
        ...state,
        workers: state.workers.filter(w => !workers.includes(w.actor))
      };
    case "NAVIGATE":
      return {
        ...initialDebuggeeState(),
        mainThread: action.mainThread
      };
    default:
      return state;
  }
}

function insertWorkers(state, workers) {
  const formatedWorkers = workers.map(worker => ({
    ...worker,
    name: (0, _workers.getDisplayName)(worker)
  }));

  return {
    ...state,
    workers: [...state.workers, ...formatedWorkers]
  };
}

const getWorkers = exports.getWorkers = state => state.debuggee.workers;

const getWorkerCount = exports.getWorkerCount = state => getWorkers(state).length;

function getWorkerByThread(state, thread) {
  return getWorkers(state).find(worker => worker.actor == thread);
}

function getMainThread(state) {
  return state.debuggee.mainThread;
}

function getDebuggeeUrl(state) {
  return getMainThread(state).url;
}

const getThreads = exports.getThreads = (0, _reselect.createSelector)(getMainThread, getWorkers, (mainThread, workers) => [mainThread, ...(0, _lodash.sortBy)(workers, _workers.getDisplayName)]);

/***/ }),
/* 578 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.basename = basename;
exports.dirname = dirname;
exports.isURL = isURL;
exports.isAbsolute = isAbsolute;
exports.join = join;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function basename(path) {
  return path.split("/").pop();
}

function dirname(path) {
  const idx = path.lastIndexOf("/");
  return path.slice(0, idx);
}

function isURL(str) {
  return str.includes("://");
}

function isAbsolute(str) {
  return str[0] === "/";
}

function join(base, dir) {
  return `${base}/${dir}`;
}

/***/ }),
/* 579 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getBreakpointsList = exports.shouldPauseOnAnyXHR = undefined;
exports.getXHRBreakpoints = getXHRBreakpoints;

var _reselect = __webpack_require__(444);

function getXHRBreakpoints(state) {
  return state.breakpoints.xhrBreakpoints;
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const shouldPauseOnAnyXHR = exports.shouldPauseOnAnyXHR = (0, _reselect.createSelector)(getXHRBreakpoints, xhrBreakpoints => {
  const emptyBp = xhrBreakpoints.find(({ path }) => path.length === 0);
  if (!emptyBp) {
    return false;
  }

  return !emptyBp.disabled;
});

const getBreakpointsList = exports.getBreakpointsList = (0, _reselect.createSelector)(state => state.breakpoints.breakpoints, breakpoints => Object.values(breakpoints));

/***/ }),
/* 580 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPendingBreakpoints = getPendingBreakpoints;
exports.getPendingBreakpointList = getPendingBreakpointList;
exports.getPendingBreakpointsForSource = getPendingBreakpointsForSource;

var _sources = __webpack_require__(498);

var _breakpoint = __webpack_require__(499);

var _source = __webpack_require__(494);

function update(state = {}, action) {
  switch (action.type) {
    case "SET_BREAKPOINT":
      return setBreakpoint(state, action);

    case "REMOVE_BREAKPOINT":
    case "REMOVE_PENDING_BREAKPOINT":
      return removeBreakpoint(state, action);
  }

  return state;
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/**
 * Pending breakpoints reducer
 * @module reducers/pending-breakpoints
 */

function setBreakpoint(state, { breakpoint }) {
  if (breakpoint.options.hidden) {
    return state;
  }

  const locationId = (0, _breakpoint.makePendingLocationId)(breakpoint.location);
  const pendingBreakpoint = (0, _breakpoint.createPendingBreakpoint)(breakpoint);

  return { ...state, [locationId]: pendingBreakpoint };
}

function removeBreakpoint(state, { location }) {
  const locationId = (0, _breakpoint.makePendingLocationId)(location);

  state = { ...state };
  delete state[locationId];
  return state;
}

// Selectors
// TODO: these functions should be moved out of the reducer

function getPendingBreakpoints(state) {
  return state.pendingBreakpoints;
}

function getPendingBreakpointList(state) {
  return Object.values(getPendingBreakpoints(state));
}

function getPendingBreakpointsForSource(state, source) {
  const sources = (0, _sources.getSourcesByURL)(state, source.url);
  if (sources.length > 1 && (0, _source.isGenerated)(source)) {
    // Don't return pending breakpoints for duplicated generated sources
    return [];
  }

  return getPendingBreakpointList(state).filter(pendingBreakpoint => {
    return pendingBreakpoint.location.sourceUrl === source.url || pendingBreakpoint.generatedLocation.sourceUrl == source.url;
  });
}

exports.default = update;

/***/ }),
/* 581 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createUIState = undefined;
exports.getSelectedPrimaryPaneTab = getSelectedPrimaryPaneTab;
exports.getActiveSearch = getActiveSearch;
exports.getFrameworkGroupingState = getFrameworkGroupingState;
exports.getShownSource = getShownSource;
exports.getPaneCollapse = getPaneCollapse;
exports.getHighlightedLineRange = getHighlightedLineRange;
exports.getConditionalPanelLocation = getConditionalPanelLocation;
exports.getLogPointStatus = getLogPointStatus;
exports.getOrientation = getOrientation;
exports.getViewport = getViewport;

var _makeRecord = __webpack_require__(527);

var _makeRecord2 = _interopRequireDefault(_makeRecord);

var _prefs = __webpack_require__(492);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/**
 * UI reducer
 * @module reducers/ui
 */

const createUIState = exports.createUIState = (0, _makeRecord2.default)({
  selectedPrimaryPaneTab: "sources",
  activeSearch: null,
  shownSource: null,
  startPanelCollapsed: _prefs.prefs.startPanelCollapsed,
  endPanelCollapsed: _prefs.prefs.endPanelCollapsed,
  frameworkGroupingOn: _prefs.prefs.frameworkGroupingOn,
  highlightedLineRange: undefined,
  conditionalPanelLocation: null,
  isLogPoint: false,
  orientation: "horizontal",
  viewport: null
});

function update(state = createUIState(), action) {
  switch (action.type) {
    case "TOGGLE_ACTIVE_SEARCH":
      {
        return state.set("activeSearch", action.value);
      }

    case "TOGGLE_FRAMEWORK_GROUPING":
      {
        _prefs.prefs.frameworkGroupingOn = action.value;
        return state.set("frameworkGroupingOn", action.value);
      }

    case "SET_ORIENTATION":
      {
        return state.set("orientation", action.orientation);
      }

    case "SHOW_SOURCE":
      {
        return state.set("shownSource", action.source);
      }

    case "TOGGLE_PANE":
      {
        if (action.position == "start") {
          _prefs.prefs.startPanelCollapsed = action.paneCollapsed;
          return state.set("startPanelCollapsed", action.paneCollapsed);
        }

        _prefs.prefs.endPanelCollapsed = action.paneCollapsed;
        return state.set("endPanelCollapsed", action.paneCollapsed);
      }

    case "HIGHLIGHT_LINES":
      const { start, end, sourceId } = action.location;
      let lineRange = {};

      if (start && end && sourceId) {
        lineRange = { start, end, sourceId };
      }

      return state.set("highlightedLineRange", lineRange);

    case "CLOSE_QUICK_OPEN":
    case "CLEAR_HIGHLIGHT_LINES":
      return state.set("highlightedLineRange", {});

    case "OPEN_CONDITIONAL_PANEL":
      return state.set("conditionalPanelLocation", action.location).set("isLogPoint", action.log);

    case "CLOSE_CONDITIONAL_PANEL":
      return state.set("conditionalPanelLocation", null);

    case "SET_PRIMARY_PANE_TAB":
      return state.set("selectedPrimaryPaneTab", action.tabName);

    case "CLOSE_PROJECT_SEARCH":
      {
        if (state.get("activeSearch") === "project") {
          return state.set("activeSearch", null);
        }
        return state;
      }

    case "SET_VIEWPORT":
      {
        return state.set("viewport", action.viewport);
      }

    case "NAVIGATE":
      {
        return state.set("activeSearch", null).set("highlightedLineRange", {});
      }

    default:
      {
        return state;
      }
  }
}

// NOTE: we'd like to have the app state fully typed
// https://github.com/firefox-devtools/debugger/blob/master/src/reducers/sources.js#L179-L185
function getSelectedPrimaryPaneTab(state) {
  return state.ui.get("selectedPrimaryPaneTab");
}

function getActiveSearch(state) {
  return state.ui.get("activeSearch");
}

function getFrameworkGroupingState(state) {
  return state.ui.get("frameworkGroupingOn");
}

function getShownSource(state) {
  return state.ui.get("shownSource");
}

function getPaneCollapse(state, position) {
  if (position == "start") {
    return state.ui.get("startPanelCollapsed");
  }

  return state.ui.get("endPanelCollapsed");
}

function getHighlightedLineRange(state) {
  return state.ui.get("highlightedLineRange");
}

function getConditionalPanelLocation(state) {
  return state.ui.get("conditionalPanelLocation");
}

function getLogPointStatus(state) {
  return state.ui.get("isLogPoint");
}

function getOrientation(state) {
  return state.ui.get("orientation");
}

function getViewport(state) {
  return state.ui.get("viewport");
}

exports.default = update;

/***/ }),
/* 582 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createFileSearchState = undefined;
exports.getFileSearchQuery = getFileSearchQuery;
exports.getFileSearchModifiers = getFileSearchModifiers;
exports.getFileSearchResults = getFileSearchResults;

var _makeRecord = __webpack_require__(527);

var _makeRecord2 = _interopRequireDefault(_makeRecord);

var _prefs = __webpack_require__(492);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/**
 * File Search reducer
 * @module reducers/fileSearch
 */

const emptySearchResults = Object.freeze({
  matches: Object.freeze([]),
  matchIndex: -1,
  index: -1,
  count: 0
});

const createFileSearchState = exports.createFileSearchState = (0, _makeRecord2.default)({
  query: "",
  searchResults: emptySearchResults,
  modifiers: (0, _makeRecord2.default)({
    caseSensitive: _prefs.prefs.fileSearchCaseSensitive,
    wholeWord: _prefs.prefs.fileSearchWholeWord,
    regexMatch: _prefs.prefs.fileSearchRegexMatch
  })()
});

function update(state = createFileSearchState(), action) {
  switch (action.type) {
    case "UPDATE_FILE_SEARCH_QUERY":
      {
        return state.set("query", action.query);
      }

    case "UPDATE_SEARCH_RESULTS":
      {
        return state.set("searchResults", action.results);
      }

    case "TOGGLE_FILE_SEARCH_MODIFIER":
      {
        const actionVal = !state.modifiers[action.modifier];

        if (action.modifier == "caseSensitive") {
          _prefs.prefs.fileSearchCaseSensitive = actionVal;
        }

        if (action.modifier == "wholeWord") {
          _prefs.prefs.fileSearchWholeWord = actionVal;
        }

        if (action.modifier == "regexMatch") {
          _prefs.prefs.fileSearchRegexMatch = actionVal;
        }

        return state.setIn(["modifiers", action.modifier], actionVal);
      }

    case "NAVIGATE":
      {
        return state.set("query", "").set("searchResults", emptySearchResults);
      }

    default:
      {
        return state;
      }
  }
}

// NOTE: we'd like to have the app state fully typed
// https://github.com/firefox-devtools/debugger/blob/master/src/reducers/sources.js#L179-L185
function getFileSearchQuery(state) {
  return state.fileSearch.query;
}

function getFileSearchModifiers(state) {
  return state.fileSearch.modifiers;
}

function getFileSearchResults(state) {
  return state.fileSearch.searchResults;
}

exports.default = update;

/***/ }),
/* 583 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initialASTState = initialASTState;
exports.getSymbols = getSymbols;
exports.hasSymbols = hasSymbols;
exports.getFramework = getFramework;
exports.isSymbolsLoading = isSymbolsLoading;
exports.getOutOfScopeLocations = getOutOfScopeLocations;
exports.getPreview = getPreview;
exports.getInScopeLines = getInScopeLines;
exports.isLineInScope = isLineInScope;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/**
 * Ast reducer
 * @module reducers/ast
 */

function initialASTState() {
  return {
    symbols: {},
    outOfScopeLocations: null,
    inScopeLines: null,
    preview: null
  };
}

function update(state = initialASTState(), action) {
  switch (action.type) {
    case "SET_SYMBOLS":
      {
        const { sourceId } = action;
        if (action.status === "start") {
          return {
            ...state,
            symbols: { ...state.symbols, [sourceId]: { loading: true } }
          };
        }

        const value = action.value;
        return {
          ...state,
          symbols: { ...state.symbols, [sourceId]: value }
        };
      }

    case "OUT_OF_SCOPE_LOCATIONS":
      {
        return { ...state, outOfScopeLocations: action.locations };
      }

    case "IN_SCOPE_LINES":
      {
        return { ...state, inScopeLines: action.lines };
      }

    case "CLEAR_SELECTION":
      {
        return { ...state, preview: null };
      }

    case "SET_PREVIEW":
      {
        if (action.status == "start") {
          return { ...state, preview: { updating: true } };
        }

        if (!action.value) {
          return { ...state, preview: null };
        }

        // NOTE: if the preview does not exist, it has been cleared
        if (state.preview) {
          return { ...state, preview: { ...action.value, updating: false } };
        }

        return state;
      }

    case "RESUME":
      {
        return { ...state, outOfScopeLocations: null };
      }

    case "NAVIGATE":
      {
        return initialASTState();
      }

    default:
      {
        return state;
      }
  }
}

// NOTE: we'd like to have the app state fully typed
// https://github.com/firefox-devtools/debugger/blob/master/src/reducers/sources.js#L179-L185
function getSymbols(state, source) {
  if (!source) {
    return null;
  }

  return state.ast.symbols[source.id] || null;
}

function hasSymbols(state, source) {
  const symbols = getSymbols(state, source);

  if (!symbols) {
    return false;
  }

  return !symbols.loading;
}

function getFramework(state, source) {
  const symbols = getSymbols(state, source);
  if (symbols && !symbols.loading) {
    return symbols.framework;
  }
}

function isSymbolsLoading(state, source) {
  const symbols = getSymbols(state, source);
  if (!symbols) {
    return false;
  }

  return symbols.loading;
}

function getOutOfScopeLocations(state) {
  return state.ast.outOfScopeLocations;
}

function getPreview(state) {
  return state.ast.preview;
}

function getInScopeLines(state) {
  return state.ast.inScopeLines;
}

function isLineInScope(state, line) {
  const linesInScope = state.ast.inScopeLines;
  return linesInScope && linesInScope.includes(line);
}

exports.default = update;

/***/ }),
/* 584 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InitialState = InitialState;
exports.default = update;
exports.getExpandedState = getExpandedState;
exports.getFocusedSourceItem = getFocusedSourceItem;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/**
 * Source tree reducer
 * @module reducers/source-tree
 */

function InitialState() {
  return {
    expanded: new Set(),
    focusedItem: null
  };
}

function update(state = InitialState(), action) {
  switch (action.type) {
    case "SET_EXPANDED_STATE":
      return updateExpanded(state, action);

    case "SET_FOCUSED_SOURCE_ITEM":
      return { ...state, focusedItem: action.item };
  }

  return state;
}

function updateExpanded(state, action) {
  return {
    ...state,
    expanded: new Set(action.expanded)
  };
}

function getExpandedState(state) {
  return state.sourceTree.expanded;
}

function getFocusedSourceItem(state) {
  return state.sourceTree.focusedItem;
}

/***/ }),
/* 585 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createQuickOpenState = undefined;
exports.default = update;
exports.getQuickOpenEnabled = getQuickOpenEnabled;
exports.getQuickOpenQuery = getQuickOpenQuery;
exports.getQuickOpenType = getQuickOpenType;

var _makeRecord = __webpack_require__(527);

var _makeRecord2 = _interopRequireDefault(_makeRecord);

var _quickOpen = __webpack_require__(586);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/**
 * Quick Open reducer
 * @module reducers/quick-open
 */

const createQuickOpenState = exports.createQuickOpenState = (0, _makeRecord2.default)({
  enabled: false,
  query: "",
  searchType: "sources"
});

function update(state = createQuickOpenState(), action) {
  switch (action.type) {
    case "OPEN_QUICK_OPEN":
      if (action.query != null) {
        return state.merge({
          enabled: true,
          query: action.query,
          searchType: (0, _quickOpen.parseQuickOpenQuery)(action.query)
        });
      }
      return state.set("enabled", true);
    case "CLOSE_QUICK_OPEN":
      return createQuickOpenState();
    case "SET_QUICK_OPEN_QUERY":
      return state.merge({
        query: action.query,
        searchType: (0, _quickOpen.parseQuickOpenQuery)(action.query)
      });
    default:
      return state;
  }
}

function getQuickOpenEnabled(state) {
  return state.quickOpen.get("enabled");
}

function getQuickOpenQuery(state) {
  return state.quickOpen.get("query");
}

function getQuickOpenType(state) {
  return state.quickOpen.get("searchType");
}

/***/ }),
/* 586 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MODIFIERS = undefined;
exports.parseQuickOpenQuery = parseQuickOpenQuery;
exports.parseLineColumn = parseLineColumn;
exports.formatSourcesForList = formatSourcesForList;
exports.formatSymbol = formatSymbol;
exports.formatSymbols = formatSymbols;
exports.formatShortcutResults = formatShortcutResults;
exports.formatSources = formatSources;

var _classnames = __webpack_require__(67);

var _classnames2 = _interopRequireDefault(_classnames);

var _utils = __webpack_require__(524);

var _source = __webpack_require__(494);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const MODIFIERS = exports.MODIFIERS = {
  "@": "functions",
  "#": "variables",
  ":": "goto",
  "?": "shortcuts"
}; /* This Source Code Form is subject to the terms of the Mozilla Public
    * License, v. 2.0. If a copy of the MPL was not distributed with this
    * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function parseQuickOpenQuery(query) {
  const modifierPattern = /^@|#|:|\?$/;
  const gotoSourcePattern = /^(\w+)\:/;
  const startsWithModifier = modifierPattern.test(query[0]);
  const isGotoSource = gotoSourcePattern.test(query);

  if (startsWithModifier) {
    const modifier = query[0];
    return MODIFIERS[modifier];
  }

  if (isGotoSource) {
    return "gotoSource";
  }

  return "sources";
}

function parseLineColumn(query) {
  const [, line, column] = query.split(":");
  const lineNumber = parseInt(line, 10);
  const columnNumber = parseInt(column, 10);
  if (!isNaN(lineNumber)) {
    return {
      line: lineNumber,
      ...(!isNaN(columnNumber) ? { column: columnNumber } : null)
    };
  }
}

function formatSourcesForList(source, tabUrls) {
  const title = (0, _source.getFilename)(source);
  const relativeUrlWithQuery = `${source.relativeUrl}${(0, _source.getSourceQueryString)(source) || ""}`;
  const subtitle = (0, _utils.endTruncateStr)(relativeUrlWithQuery, 100);
  const value = relativeUrlWithQuery;
  return {
    value,
    title,
    subtitle,
    icon: tabUrls.has(source.url) ? "tab result-item-icon" : (0, _classnames2.default)((0, _source.getSourceClassnames)(source), "result-item-icon"),
    id: source.id,
    url: source.url
  };
}

function formatSymbol(symbol) {
  return {
    id: `${symbol.name}:${symbol.location.start.line}`,
    title: symbol.name,
    subtitle: `${symbol.location.start.line}`,
    value: symbol.name,
    location: symbol.location
  };
}

function formatSymbols(symbols) {
  if (!symbols || symbols.loading) {
    return { functions: [] };
  }

  const { functions } = symbols;

  return {
    functions: functions.map(formatSymbol)
  };
}

function formatShortcutResults() {
  return [{
    value: L10N.getStr("symbolSearch.search.functionsPlaceholder.title"),
    title: `@ ${L10N.getStr("symbolSearch.search.functionsPlaceholder")}`,
    id: "@"
  }, {
    value: L10N.getStr("symbolSearch.search.variablesPlaceholder.title"),
    title: `# ${L10N.getStr("symbolSearch.search.variablesPlaceholder")}`,
    id: "#"
  }, {
    value: L10N.getStr("gotoLineModal.title"),
    title: `: ${L10N.getStr("gotoLineModal.placeholder")}`,
    id: ":"
  }];
}

function formatSources(sources, tabUrls) {
  return sources.filter(source => !(0, _source.isPretty)(source)).filter(source => !!source.relativeUrl && !(0, _source.isPretty)(source)).map(source => formatSourcesForList(source, tabUrls));
}

/***/ }),
/* 587 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFirstVisibleBreakpoints = exports.getVisibleBreakpoints = undefined;

var _reselect = __webpack_require__(444);

var _lodash = __webpack_require__(417);

var _breakpoints = __webpack_require__(518);

var _sources = __webpack_require__(498);

var _breakpoint = __webpack_require__(499);

var _selectedLocation = __webpack_require__(501);

/*
 * Finds the breakpoints, which appear in the selected source.
 */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const getVisibleBreakpoints = exports.getVisibleBreakpoints = (0, _reselect.createSelector)(_sources.getSelectedSource, _breakpoints.getBreakpointsList, (selectedSource, breakpoints) => {
  if (!selectedSource) {
    return null;
  }

  return breakpoints.filter(bp => selectedSource && (0, _selectedLocation.getSelectedLocation)(bp, selectedSource).sourceId === selectedSource.id);
});

/*
 * Finds the first breakpoint per line, which appear in the selected source.
 */
const getFirstVisibleBreakpoints = exports.getFirstVisibleBreakpoints = (0, _reselect.createSelector)(getVisibleBreakpoints, _sources.getSelectedSource, (breakpoints, selectedSource) => {
  if (!breakpoints || !selectedSource) {
    return [];
  }

  return (0, _lodash.uniqBy)((0, _breakpoint.sortSelectedBreakpoints)(breakpoints, selectedSource), bp => (0, _selectedLocation.getSelectedLocation)(bp, selectedSource).line);
});

/***/ }),
/* 588 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLibraryFromUrl = getLibraryFromUrl;

var _getFrameUrl = __webpack_require__(533);

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const libraryMap = [{
  label: "Backbone",
  pattern: /backbone/i
}, {
  label: "jQuery",
  pattern: /jquery/i
}, {
  label: "Preact",
  pattern: /preact/i
}, {
  label: "React",
  pattern: /(node_modules\/(?:react|react-dom)\/)|(react(\.[a-z]+)*\.js$)/
}, {
  label: "Immutable",
  pattern: /immutable/i
}, {
  label: "Webpack",
  pattern: /webpack\/bootstrap/i
}, {
  label: "Express",
  pattern: /node_modules\/express/
}, {
  label: "Pug",
  pattern: /node_modules\/pug/
}, {
  label: "ExtJS",
  pattern: /\/ext-all[\.\-]/
}, {
  label: "MobX",
  pattern: /mobx/i
}, {
  label: "Underscore",
  pattern: /underscore/i
}, {
  label: "Lodash",
  pattern: /lodash/i
}, {
  label: "Ember",
  pattern: /ember/i
}, {
  label: "Choo",
  pattern: /choo/i
}, {
  label: "VueJS",
  pattern: /vue(?:\.[a-z]+)*\.js/i
}, {
  label: "RxJS",
  pattern: /rxjs/i
}, {
  label: "Angular",
  pattern: /angular(?!.*\/app\/)/i,
  contextPattern: /(zone\.js)/
}, {
  label: "Redux",
  pattern: /redux/i
}, {
  label: "Dojo",
  pattern: /dojo/i
}, {
  label: "Marko",
  pattern: /marko/i
}, {
  label: "NuxtJS",
  pattern: /[\._]nuxt/i
}, {
  label: "Aframe",
  pattern: /aframe/i
}, {
  label: "NextJS",
  pattern: /[\._]next/i
}];

function getLibraryFromUrl(frame, callStack = []) {
  // @TODO each of these fns calls getFrameUrl, just call it once
  // (assuming there's not more complex logic to identify a lib)
  const frameUrl = (0, _getFrameUrl.getFrameUrl)(frame);

  // Let's first check if the frame match a defined pattern.
  let match = libraryMap.find(o => frameUrl.match(o.pattern));
  if (match) {
    return match.label;
  }

  // If it does not, it might still be one of the case where the file is used
  // by a library but the name has not enough specificity. In such case, we want
  // to only return the library name if there are frames matching the library
  // pattern in the callStack (e.g. `zone.js` is used by Angular, but the name
  //  could be quite common and return false positive if evaluated alone. So we
  // only return Angular if there are other frames matching Angular).
  match = libraryMap.find(o => o.contextPattern && frameUrl.match(o.contextPattern));
  if (match) {
    const contextMatch = callStack.some(f => {
      const url = (0, _getFrameUrl.getFrameUrl)(f);
      if (!url) {
        return false;
      }

      return libraryMap.some(o => url.match(o.pattern));
    });

    if (contextMatch) {
      return match.label;
    }
  }

  return null;
}

/***/ }),
/* 589 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toggleBlackBox = toggleBlackBox;

var _devtoolsSourceMap = __webpack_require__(182);

var _telemetry = __webpack_require__(520);

var _prefs = __webpack_require__(492);

var _selectors = __webpack_require__(490);

var _promise = __webpack_require__(500);

async function blackboxActors(state, client, sourceId, isBlackBoxed, range) {
  for (const actor of (0, _selectors.getSourceActorsForSource)(state, sourceId)) {
    await client.blackBox(actor, isBlackBoxed, range);
  }
  return { isBlackBoxed: !isBlackBoxed };
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/**
 * Redux actions for the sources state
 * @module actions/sources
 */

function toggleBlackBox(cx, source) {
  return async ({ dispatch, getState, client, sourceMaps }) => {
    const { isBlackBoxed } = source;

    if (!isBlackBoxed) {
      (0, _telemetry.recordEvent)("blackbox");
    }

    let sourceId, range;
    if (_prefs.features.originalBlackbox && (0, _devtoolsSourceMap.isOriginalId)(source.id)) {
      range = await sourceMaps.getFileGeneratedRange(source);
      sourceId = (0, _devtoolsSourceMap.originalToGeneratedId)(source.id);
    } else {
      sourceId = source.id;
    }

    return dispatch({
      type: "BLACKBOX",
      cx,
      source,
      [_promise.PROMISE]: blackboxActors(getState(), client, sourceId, isBlackBoxed, range)
    });
  };
}

/***/ }),
/* 590 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setBreakableLines = setBreakableLines;

var _devtoolsSourceMap = __webpack_require__(182);

var _selectors = __webpack_require__(490);

var _breakpointPositions = __webpack_require__(534);

var _lodash = __webpack_require__(417);

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function calculateBreakableLines(positions) {
  const lines = [];
  for (const line in positions) {
    if (positions[line].length > 0) {
      lines.push(Number(line));
    }
  }

  return lines;
}

function setBreakableLines(cx, sourceId) {
  return async ({ getState, dispatch, client }) => {
    let breakableLines;
    if ((0, _devtoolsSourceMap.isOriginalId)(sourceId)) {
      const positions = await dispatch((0, _breakpointPositions.setBreakpointPositions)({ cx, sourceId }));
      breakableLines = calculateBreakableLines(positions);
    } else {
      breakableLines = await client.getBreakableLines((0, _selectors.getSourceActorsForSource)(getState(), sourceId));
    }

    const existingBreakableLines = (0, _selectors.getBreakableLines)(getState(), sourceId);
    if (existingBreakableLines) {
      breakableLines = (0, _lodash.union)(existingBreakableLines, breakableLines);
    }

    dispatch({
      type: "SET_BREAKABLE_LINES",
      cx,
      sourceId,
      breakableLines
    });
  };
}

/***/ }),
/* 591 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.selectThread = selectThread;
exports.command = command;
exports.stepIn = stepIn;
exports.stepOver = stepOver;
exports.stepOut = stepOut;
exports.resume = resume;
exports.rewind = rewind;
exports.reverseStepIn = reverseStepIn;
exports.reverseStepOver = reverseStepOver;
exports.reverseStepOut = reverseStepOut;
exports.astCommand = astCommand;

var _selectors = __webpack_require__(490);

var _promise = __webpack_require__(500);

var _parser = __webpack_require__(503);

var _breakpoints = __webpack_require__(504);

var _expressions = __webpack_require__(511);

var _sources = __webpack_require__(505);

var _fetchScopes = __webpack_require__(537);

var _prefs = __webpack_require__(492);

var _telemetry = __webpack_require__(520);

var _assert = __webpack_require__(385);

var _assert2 = _interopRequireDefault(_assert);

var _asyncValue = __webpack_require__(497);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function selectThread(cx, thread) {
  return async ({ dispatch, getState, client }) => {
    await dispatch({ cx, type: "SELECT_THREAD", thread });

    // Get a new context now that the current thread has changed.
    const threadcx = (0, _selectors.getThreadContext)(getState());
    (0, _assert2.default)(threadcx.thread == thread, "Thread mismatch");

    dispatch((0, _expressions.evaluateExpressions)(threadcx));

    const frame = (0, _selectors.getSelectedFrame)(getState(), thread);
    if (frame) {
      dispatch((0, _sources.selectLocation)(threadcx, frame.location));
      dispatch((0, _fetchScopes.fetchScopes)(threadcx));
    }
  };
}

/**
 * Debugger commands like stepOver, stepIn, stepUp
 *
 * @param string $0.type
 * @memberof actions/pause
 * @static
 */
/* -*- indent-tabs-mode: nil; js-indent-level: 2; js-indent-level: 2 -*- */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function command(cx, type) {
  return async ({ dispatch, getState, client }) => {
    if (type) {
      return dispatch({
        type: "COMMAND",
        command: type,
        cx,
        thread: cx.thread,
        [_promise.PROMISE]: client[type](cx.thread)
      });
    }
  };
}

/**
 * StepIn
 * @memberof actions/pause
 * @static
 * @returns {Function} {@link command}
 */
function stepIn(cx) {
  return ({ dispatch, getState }) => {
    if (cx.isPaused) {
      return dispatch(command(cx, "stepIn"));
    }
  };
}

/**
 * stepOver
 * @memberof actions/pause
 * @static
 * @returns {Function} {@link command}
 */
function stepOver(cx) {
  return ({ dispatch, getState }) => {
    if (cx.isPaused) {
      return dispatch(astCommand(cx, "stepOver"));
    }
  };
}

/**
 * stepOut
 * @memberof actions/pause
 * @static
 * @returns {Function} {@link command}
 */
function stepOut(cx) {
  return ({ dispatch, getState }) => {
    if (cx.isPaused) {
      return dispatch(command(cx, "stepOut"));
    }
  };
}

/**
 * resume
 * @memberof actions/pause
 * @static
 * @returns {Function} {@link command}
 */
function resume(cx) {
  return ({ dispatch, getState }) => {
    if (cx.isPaused) {
      (0, _telemetry.recordEvent)("continue");
      return dispatch(command(cx, "resume"));
    }
  };
}

/**
 * rewind
 * @memberof actions/pause
 * @static
 * @returns {Function} {@link command}
 */
function rewind(cx) {
  return ({ dispatch, getState }) => {
    if (cx.isPaused) {
      return dispatch(command(cx, "rewind"));
    }
  };
}

/**
 * reverseStepIn
 * @memberof actions/pause
 * @static
 * @returns {Function} {@link command}
 */
function reverseStepIn(cx) {
  return ({ dispatch, getState }) => {
    if (cx.isPaused) {
      return dispatch(command(cx, "reverseStepIn"));
    }
  };
}

/**
 * reverseStepOver
 * @memberof actions/pause
 * @static
 * @returns {Function} {@link command}
 */
function reverseStepOver(cx) {
  return ({ dispatch, getState }) => {
    if (cx.isPaused) {
      return dispatch(astCommand(cx, "reverseStepOver"));
    }
  };
}

/**
 * reverseStepOut
 * @memberof actions/pause
 * @static
 * @returns {Function} {@link command}
 */
function reverseStepOut(cx) {
  return ({ dispatch, getState }) => {
    if (cx.isPaused) {
      return dispatch(command(cx, "reverseStepOut"));
    }
  };
}

/*
 * Checks for await or yield calls on the paused line
 * This avoids potentially expensive parser calls when we are likely
 * not at an async expression.
 */
function hasAwait(content, pauseLocation) {
  const { line, column } = pauseLocation;
  if (!content || !(0, _asyncValue.isFulfilled)(content) || content.value.type !== "text") {
    return false;
  }

  const lineText = content.value.value.split("\n")[line - 1];

  if (!lineText) {
    return false;
  }

  const snippet = lineText.slice(column - 50, column + 50);

  return !!snippet.match(/(yield|await)/);
}

/**
 * @memberOf actions/pause
 * @static
 * @param stepType
 * @returns {function(ThunkArgs)}
 */
function astCommand(cx, stepType) {
  return async ({ dispatch, getState, sourceMaps }) => {
    if (!_prefs.features.asyncStepping) {
      return dispatch(command(cx, stepType));
    }

    if (stepType == "stepOver") {
      // This type definition is ambiguous:
      const frame = (0, _selectors.getTopFrame)(getState(), cx.thread);
      const source = (0, _selectors.getSource)(getState(), frame.location.sourceId);
      const content = source ? (0, _selectors.getSourceContent)(getState(), source.id) : null;

      if (source && hasAwait(content, frame.location)) {
        const nextLocation = await (0, _parser.getNextStep)(source.id, frame.location);
        if (nextLocation) {
          await dispatch((0, _breakpoints.addHiddenBreakpoint)(cx, nextLocation));
          return dispatch(command(cx, "resume"));
        }
      }
    }

    return dispatch(command(cx, stepType));
  };
}

/***/ }),
/* 592 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wrapExpression = wrapExpression;
exports.getValue = getValue;

var _indentation = __webpack_require__(536);

/*
 * wrap the expression input in a try/catch so that it can be safely
 * evaluated.
 *
 * NOTE: we add line after the expression to protect against comments.
 */
function wrapExpression(input) {
  return (0, _indentation.correctIndentation)(`
    try {
      ${input}
    } catch (e) {
      e
    }
  `);
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function isUnavailable(value) {
  if (!value.preview || !value.preview.name) {
    return false;
  }

  return ["ReferenceError", "TypeError"].includes(value.preview.name);
}

function getValue(expression) {
  const value = expression.value;
  if (!value) {
    return {
      path: expression.from,
      value: { unavailable: true }
    };
  }

  if (value.exception) {
    if (isUnavailable(value.exception)) {
      return { value: { unavailable: true } };
    }
    return {
      path: value.from,
      value: value.exception
    };
  }

  if (value.error) {
    return {
      path: value.from,
      value: value.error
    };
  }

  if (value.result && value.result.class == "Error") {
    const { name, message } = value.result.preview;
    if (isUnavailable(value.result)) {
      return { value: { unavailable: true } };
    }

    const newValue = `${name}: ${message}`;
    return { path: value.input, value: newValue };
  }

  if (typeof value.result == "object") {
    return {
      path: value.result.actor,
      value: value.result
    };
  }

  return {
    path: value.input,
    value: value.result
  };
}

/***/ }),
/* 593 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toggleMapScopes = toggleMapScopes;
exports.mapScopes = mapScopes;

var _selectors = __webpack_require__(490);

var _loadSourceText = __webpack_require__(507);

var _promise = __webpack_require__(500);

var _assert = __webpack_require__(385);

var _assert2 = _interopRequireDefault(_assert);

var _log = __webpack_require__(594);

var _source = __webpack_require__(494);

var _mapScopes = __webpack_require__(656);

var _asyncValue = __webpack_require__(497);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function toggleMapScopes() {
  return async function ({ dispatch, getState, client, sourceMaps }) {
    if ((0, _selectors.isMapScopesEnabled)(getState())) {
      return dispatch({ type: "TOGGLE_MAP_SCOPES", mapScopes: false });
    }

    dispatch({ type: "TOGGLE_MAP_SCOPES", mapScopes: true });

    const cx = (0, _selectors.getThreadContext)(getState());

    if ((0, _selectors.getSelectedOriginalScope)(getState(), cx.thread)) {
      return;
    }

    const scopes = (0, _selectors.getSelectedGeneratedScope)(getState(), cx.thread);
    const frame = (0, _selectors.getSelectedFrame)(getState(), cx.thread);
    if (!scopes || !frame) {
      return;
    }

    dispatch(mapScopes(cx, Promise.resolve(scopes.scope), frame));
  };
}

function mapScopes(cx, scopes, frame) {
  return async function ({ dispatch, getState, client, sourceMaps }) {
    (0, _assert2.default)(cx.thread == frame.thread, "Thread mismatch");

    const generatedSource = (0, _selectors.getSource)(getState(), frame.generatedLocation.sourceId);

    const source = (0, _selectors.getSource)(getState(), frame.location.sourceId);

    await dispatch({
      type: "MAP_SCOPES",
      cx,
      thread: cx.thread,
      frame,
      [_promise.PROMISE]: async function () {
        if (!(0, _selectors.isMapScopesEnabled)(getState()) || !source || !generatedSource || generatedSource.isWasm || source.isPrettyPrinted || (0, _source.isGenerated)(source)) {
          return null;
        }

        await dispatch((0, _loadSourceText.loadSourceText)({ cx, source }));
        if ((0, _source.isOriginal)(source)) {
          await dispatch((0, _loadSourceText.loadSourceText)({ cx, source: generatedSource }));
        }

        try {
          const content = (0, _selectors.getSource)(getState(), source.id) && (0, _selectors.getSourceContent)(getState(), source.id);

          return await (0, _mapScopes.buildMappedScopes)(source, content && (0, _asyncValue.isFulfilled)(content) ? content.value : { type: "text", value: "", contentType: undefined }, frame, (await scopes), sourceMaps, client);
        } catch (e) {
          (0, _log.log)(e);
          return null;
        }
      }()
    });
  };
}

/***/ }),
/* 594 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.log = log;

var _prefs = __webpack_require__(492);

/**
 * Produces a formatted console log line by imploding args, prefixed by [log]
 *
 * function input: log(["hello", "world"])
 * console output: [log] hello world
 *
 * @memberof utils/log
 * @static
 */
function log(...args) {
  if (_prefs.prefs.logging) {
    console.log(...args);
  }
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/**
 *
 * Utils for logging to the console
 * Suppresses logging in non-development environment
 *
 * @module utils/log
 */

/***/ }),
/* 595 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.filterSortedArray = filterSortedArray;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function findInsertionLocation(array, callback) {
  let left = 0;
  let right = array.length;
  while (left < right) {
    const mid = Math.floor((left + right) / 2);
    const item = array[mid];

    const result = callback(item);
    if (result === 0) {
      left = mid;
      break;
    }
    if (result >= 0) {
      right = mid;
    } else {
      left = mid + 1;
    }
  }

  // Ensure the value is the start of any set of matches.
  let i = left;
  if (i < array.length) {
    while (i >= 0 && callback(array[i]) >= 0) {
      i--;
    }
    return i + 1;
  }

  return i;
}

function filterSortedArray(array, callback) {
  const start = findInsertionLocation(array, callback);

  const results = [];
  for (let i = start; i < array.length && callback(array[i]) === 0; i++) {
    results.push(array[i]);
  }

  return results;
}

/***/ }),
/* 596 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mappingContains = mappingContains;

var _positionCmp = __webpack_require__(549);

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function mappingContains(mapped, item) {
  return (0, _positionCmp.positionCmp)(item.start, mapped.start) >= 0 && (0, _positionCmp.positionCmp)(item.end, mapped.end) <= 0;
}

/***/ }),
/* 597 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setOutOfScopeLocations = setOutOfScopeLocations;

var _selectors = __webpack_require__(490);

var _setInScopeLines = __webpack_require__(670);

var _parser = __webpack_require__(503);

var parser = _interopRequireWildcard(_parser);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function setOutOfScopeLocations(cx) {
  return async ({ dispatch, getState }) => {
    const location = (0, _selectors.getSelectedLocation)(getState());
    if (!location) {
      return;
    }

    const { source, content } = (0, _selectors.getSourceWithContent)(getState(), location.sourceId);

    if (!content) {
      return;
    }

    let locations = null;
    if (location.line && source && !source.isWasm) {
      locations = await parser.findOutOfScopeLocations(source.id, location);
    }

    dispatch({
      type: "OUT_OF_SCOPE_LOCATIONS",
      cx,
      locations
    });
    dispatch((0, _setInScopeLines.setInScopeLines)(cx));
  };
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/***/ }),
/* 598 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.doSearch = doSearch;
exports.doSearchForHighlight = doSearchForHighlight;
exports.setFileSearchQuery = setFileSearchQuery;
exports.toggleFileSearchModifier = toggleFileSearchModifier;
exports.updateSearchResults = updateSearchResults;
exports.searchContents = searchContents;
exports.searchContentsForHighlight = searchContentsForHighlight;
exports.traverseResults = traverseResults;
exports.closeFileSearch = closeFileSearch;

var _editor = __webpack_require__(496);

var _wasm = __webpack_require__(516);

var _search = __webpack_require__(542);

var _selectors = __webpack_require__(490);

var _ui = __webpack_require__(538);

var _asyncValue = __webpack_require__(497);

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function doSearch(cx, query, editor) {
  return ({ getState, dispatch }) => {
    const selectedSourceWithContent = (0, _selectors.getSelectedSourceWithContent)(getState());
    if (!selectedSourceWithContent || !selectedSourceWithContent.content) {
      return;
    }

    dispatch(setFileSearchQuery(cx, query));
    dispatch(searchContents(cx, query, editor));
  };
}

function doSearchForHighlight(query, editor, line, ch) {
  return async ({ getState, dispatch }) => {
    const selectedSourceWithContent = (0, _selectors.getSelectedSourceWithContent)(getState());
    if (!selectedSourceWithContent || !selectedSourceWithContent.content) {
      return;
    }
    dispatch(searchContentsForHighlight(query, editor, line, ch));
  };
}

function setFileSearchQuery(cx, query) {
  return {
    type: "UPDATE_FILE_SEARCH_QUERY",
    cx,
    query
  };
}

function toggleFileSearchModifier(cx, modifier) {
  return { type: "TOGGLE_FILE_SEARCH_MODIFIER", cx, modifier };
}

function updateSearchResults(cx, characterIndex, line, matches) {
  const matchIndex = matches.findIndex(elm => elm.line === line && elm.ch === characterIndex);

  return {
    type: "UPDATE_SEARCH_RESULTS",
    cx,
    results: {
      matches,
      matchIndex,
      count: matches.length,
      index: characterIndex
    }
  };
}

function searchContents(cx, query, editor, focusFirstResult = true) {
  return async ({ getState, dispatch }) => {
    const modifiers = (0, _selectors.getFileSearchModifiers)(getState());
    const selectedSourceWithContent = (0, _selectors.getSelectedSourceWithContent)(getState());

    if (!editor || !selectedSourceWithContent || !selectedSourceWithContent.content || !(0, _asyncValue.isFulfilled)(selectedSourceWithContent.content) || !modifiers) {
      return;
    }
    const selectedSource = selectedSourceWithContent.source;
    const selectedContent = selectedSourceWithContent.content.value;

    const ctx = { ed: editor, cm: editor.codeMirror };

    if (!query) {
      (0, _editor.clearSearch)(ctx.cm, query);
      return;
    }

    const _modifiers = modifiers.toJS();
    let text;
    if (selectedContent.type === "wasm") {
      text = (0, _wasm.renderWasmText)(selectedSource.id, selectedContent).join("\n");
    } else {
      text = selectedContent.value;
    }

    const matches = await (0, _search.getMatches)(query, text, _modifiers);

    const res = (0, _editor.find)(ctx, query, true, _modifiers, focusFirstResult);
    if (!res) {
      return;
    }

    const { ch, line } = res;

    dispatch(updateSearchResults(cx, ch, line, matches));
  };
}

function searchContentsForHighlight(query, editor, line, ch) {
  return async ({ getState, dispatch }) => {
    const modifiers = (0, _selectors.getFileSearchModifiers)(getState());
    const selectedSource = (0, _selectors.getSelectedSourceWithContent)(getState());

    if (!query || !editor || !selectedSource || !selectedSource.content || !modifiers) {
      return;
    }

    const ctx = { ed: editor, cm: editor.codeMirror };
    const _modifiers = modifiers.toJS();

    (0, _editor.searchSourceForHighlight)(ctx, false, query, true, _modifiers, line, ch);
  };
}

function traverseResults(cx, rev, editor) {
  return async ({ getState, dispatch }) => {
    if (!editor) {
      return;
    }

    const ctx = { ed: editor, cm: editor.codeMirror };

    const query = (0, _selectors.getFileSearchQuery)(getState());
    const modifiers = (0, _selectors.getFileSearchModifiers)(getState());
    const { matches } = (0, _selectors.getFileSearchResults)(getState());

    if (query === "") {
      dispatch((0, _ui.setActiveSearch)("file"));
    }

    if (modifiers) {
      const matchedLocations = matches || [];
      const findArgs = [ctx, query, true, modifiers.toJS()];
      const results = rev ? (0, _editor.findPrev)(...findArgs) : (0, _editor.findNext)(...findArgs);

      if (!results) {
        return;
      }
      const { ch, line } = results;
      dispatch(updateSearchResults(cx, ch, line, matchedLocations));
    }
  };
}

function closeFileSearch(cx, editor) {
  return ({ getState, dispatch }) => {
    if (editor) {
      const query = (0, _selectors.getFileSearchQuery)(getState());
      const ctx = { ed: editor, cm: editor.codeMirror };
      (0, _editor.removeOverlay)(ctx, query);
    }

    dispatch(setFileSearchQuery(cx, ""));
    dispatch((0, _ui.closeActiveSearch)());
    dispatch((0, _ui.clearHighlightLineRange)());
  };
}

/***/ }),
/* 599 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateWorkers = updateWorkers;

var _lodash = __webpack_require__(417);

var _sourceActors = __webpack_require__(552);

var _selectors = __webpack_require__(490);

function updateWorkers() {
  return async function ({ dispatch, getState, client }) {
    const cx = (0, _selectors.getContext)(getState());
    const workers = await client.fetchWorkers();

    const currentWorkers = (0, _selectors.getWorkers)(getState());

    const addedWorkers = (0, _lodash.differenceBy)(workers, currentWorkers, w => w.actor);
    const removedWorkers = (0, _lodash.differenceBy)(currentWorkers, workers, w => w.actor);
    if (removedWorkers.length > 0) {
      const sourceActors = (0, _selectors.getSourceActorsForThread)(getState(), removedWorkers.map(w => w.actor));
      dispatch((0, _sourceActors.removeSourceActors)(sourceActors));
      dispatch({
        type: "REMOVE_WORKERS",
        cx,
        workers: removedWorkers.map(w => w.actor)
      });
    }
    if (addedWorkers.length > 0) {
      dispatch({ type: "INSERT_WORKERS", cx, workers: addedWorkers });
    }
  };
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/***/ }),
/* 600 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Modal = exports.transitionTimeout = undefined;
exports.default = Slide;

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(67);

var _classnames2 = _interopRequireDefault(_classnames);

var _Transition = __webpack_require__(435);

var _Transition2 = _interopRequireDefault(_Transition);

__webpack_require__(686);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const transitionTimeout = exports.transitionTimeout = 175; /* This Source Code Form is subject to the terms of the Mozilla Public
                                                            * License, v. 2.0. If a copy of the MPL was not distributed with this
                                                            * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

class Modal extends _react2.default.Component {
  constructor(...args) {
    var _temp;

    return _temp = super(...args), this.onClick = e => {
      e.stopPropagation();
    }, _temp;
  }

  render() {
    const { additionalClass, children, handleClose, status } = this.props;

    return _react2.default.createElement(
      "div",
      { className: "modal-wrapper", onClick: handleClose },
      _react2.default.createElement(
        "div",
        {
          className: (0, _classnames2.default)("modal", additionalClass, status),
          onClick: this.onClick
        },
        children
      )
    );
  }
}

exports.Modal = Modal;
Modal.contextTypes = {
  shortcuts: _propTypes2.default.object
};

function Slide({
  in: inProp,
  children,
  additionalClass,
  handleClose
}) {
  return _react2.default.createElement(
    _Transition2.default,
    { "in": inProp, timeout: transitionTimeout, appear: true },
    status => _react2.default.createElement(
      Modal,
      {
        status: status,
        additionalClass: additionalClass,
        handleClose: handleClose
      },
      children
    )
  );
}

/***/ }),
/* 601 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /* This Source Code Form is subject to the terms of the Mozilla Public
                                                                                                                                                                                                                                                                   * License, v. 2.0. If a copy of the MPL was not distributed with this
                                                                                                                                                                                                                                                                   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

__webpack_require__(695);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const { Tree } = __webpack_require__(108);

class ManagedTree extends _react.Component {
  constructor(props) {
    super(props);

    this.setExpanded = (item, isExpanded, shouldIncludeChildren) => {
      const expandItem = i => {
        const path = this.props.getPath(i);
        if (isExpanded) {
          expanded.add(path);
        } else {
          expanded.delete(path);
        }
      };
      const { expanded } = this.state;
      expandItem(item);

      if (shouldIncludeChildren) {
        let parents = [item];
        while (parents.length) {
          const children = [];
          for (const parent of parents) {
            if (parent.contents && parent.contents.length) {
              for (const child of parent.contents) {
                expandItem(child);
                children.push(child);
              }
            }
          }
          parents = children;
        }
      }
      this.setState({ expanded });

      if (isExpanded && this.props.onExpand) {
        this.props.onExpand(item, expanded);
      } else if (!isExpanded && this.props.onCollapse) {
        this.props.onCollapse(item, expanded);
      }
    };

    this.state = {
      expanded: props.expanded || new Set()
    };
  }

  componentWillReceiveProps(nextProps) {
    const { listItems, highlightItems } = this.props;
    if (nextProps.listItems && nextProps.listItems != listItems) {
      this.expandListItems(nextProps.listItems);
    }

    if (nextProps.highlightItems && nextProps.highlightItems != highlightItems && nextProps.highlightItems.length) {
      this.highlightItem(nextProps.highlightItems);
    }
  }

  expandListItems(listItems) {
    const { expanded } = this.state;
    listItems.forEach(item => expanded.add(this.props.getPath(item)));
    this.props.onFocus(listItems[0]);
    this.setState({ expanded });
  }

  highlightItem(highlightItems) {
    const { expanded } = this.state;
    // This file is visible, so we highlight it.
    if (expanded.has(this.props.getPath(highlightItems[0]))) {
      this.props.onFocus(highlightItems[0]);
    } else {
      // Look at folders starting from the top-level until finds a
      // closed folder and highlights this folder
      const index = highlightItems.reverse().findIndex(item => !expanded.has(this.props.getPath(item)) && item.name !== "root");

      if (highlightItems[index]) {
        this.props.onFocus(highlightItems[index]);
      }
    }
  }

  render() {
    const { expanded } = this.state;
    return _react2.default.createElement(
      "div",
      { className: "managed-tree" },
      _react2.default.createElement(Tree, _extends({}, this.props, {
        isExpanded: item => expanded.has(this.props.getPath(item)),
        focused: this.props.focused,
        getKey: this.props.getPath,
        onExpand: (item, shouldIncludeChildren) => this.setExpanded(item, true, shouldIncludeChildren),
        onCollapse: (item, shouldIncludeChildren) => this.setExpanded(item, false, shouldIncludeChildren),
        onFocus: this.props.onFocus,
        renderItem: (...args) => this.props.renderItem(...args, {
          setExpanded: this.setExpanded
        })
      }))
    );
  }
}

ManagedTree.defaultProps = {
  onFocus: () => {}
};
exports.default = ManagedTree;

/***/ }),
/* 602 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _lodash = __webpack_require__(417);

var _frames = __webpack_require__(510);

__webpack_require__(710);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class PreviewFunction extends _react.Component {
  renderFunctionName(func) {
    const { l10n } = this.context;
    const name = (0, _frames.formatDisplayName)(func, undefined, l10n);
    return _react2.default.createElement(
      "span",
      { className: "function-name" },
      name
    );
  }

  renderParams(func) {
    const { parameterNames = [] } = func;
    const params = parameterNames.filter(i => i).map(param => _react2.default.createElement(
      "span",
      { className: "param", key: param },
      param
    ));

    const commas = (0, _lodash.times)(params.length - 1).map((_, i) => _react2.default.createElement(
      "span",
      { className: "delimiter", key: i },
      ", "
    ));

    // $FlowIgnore
    return (0, _lodash.flatten)((0, _lodash.zip)(params, commas));
  }

  render() {
    return _react2.default.createElement(
      "span",
      { className: "function-signature" },
      this.renderFunctionName(this.props.func),
      _react2.default.createElement(
        "span",
        { className: "paren" },
        "("
      ),
      this.renderParams(this.props.func),
      _react2.default.createElement(
        "span",
        { className: "paren" },
        ")"
      )
    );
  }
}

exports.default = PreviewFunction; /* This Source Code Form is subject to the terms of the Mozilla Public
                                    * License, v. 2.0. If a copy of the MPL was not distributed with this
                                    * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

PreviewFunction.contextTypes = { l10n: _propTypes2.default.object };

/***/ }),
/* 603 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scrollList = scrollList;

var _devtoolsEnvironment = __webpack_require__(102);

function scrollList(resultList, index) {
  if (!resultList.hasOwnProperty(index)) {
    return;
  }

  const resultEl = resultList[index];

  const scroll = () => {
    if ((0, _devtoolsEnvironment.isFirefox)()) {
      resultEl.scrollIntoView({ block: "nearest", behavior: "auto" });
    } else {
      chromeScrollList(resultEl, index);
    }
  };

  scroll();
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function chromeScrollList(elem, index) {
  const resultsEl = elem.parentNode;

  if (!resultsEl || resultsEl.children.length === 0) {
    return;
  }

  // Avoid expensive DOM computations (reading clientHeight)
  // https://nolanlawson.com/2018/09/25/accurately-measuring-layout-on-the-web/
  requestAnimationFrame(() => {
    setTimeout(() => {
      const resultsHeight = resultsEl.clientHeight;
      const itemHeight = resultsEl.children[0].clientHeight;
      const numVisible = resultsHeight / itemHeight;
      const positionsToScroll = index - numVisible + 1;
      const itemOffset = resultsHeight % itemHeight;
      const scroll = positionsToScroll * (itemHeight + 2) + itemOffset;

      resultsEl.scrollTop = Math.max(0, scroll);
    });
  });
}

/***/ }),
/* 604 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ExceptionOption;

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ExceptionOption({
  className,
  isChecked = false,
  label,
  onChange
}) {
  return _react2.default.createElement(
    "div",
    { className: className, onClick: onChange },
    _react2.default.createElement("input", {
      type: "checkbox",
      checked: isChecked ? "checked" : "",
      onChange: e => e.stopPropagation() && onChange()
    }),
    _react2.default.createElement(
      "div",
      { className: "breakpoint-exceptions-label" },
      label
    )
  );
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/***/ }),
/* 605 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(67);

var _classnames2 = _interopRequireDefault(_classnames);

var _AccessibleImage = __webpack_require__(495);

var _AccessibleImage2 = _interopRequireDefault(_AccessibleImage);

var _frames = __webpack_require__(510);

var _source = __webpack_require__(494);

var _FrameMenu = __webpack_require__(606);

var _FrameMenu2 = _interopRequireDefault(_FrameMenu);

var _FrameIndent = __webpack_require__(607);

var _FrameIndent2 = _interopRequireDefault(_FrameIndent);

var _actions = __webpack_require__(493);

var _actions2 = _interopRequireDefault(_actions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function FrameTitle({ frame, options = {}, l10n }) {
  const displayName = (0, _frames.formatDisplayName)(frame, options, l10n);
  return _react2.default.createElement(
    "span",
    { className: "title" },
    displayName
  );
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function FrameLocation({ frame, displayFullUrl = false }) {
  if (!frame.source) {
    return null;
  }

  if (frame.library) {
    return _react2.default.createElement(
      "span",
      { className: "location" },
      frame.library,
      _react2.default.createElement(_AccessibleImage2.default, {
        className: `annotation-logo ${frame.library.toLowerCase()}`
      })
    );
  }

  const { location, source } = frame;
  const filename = displayFullUrl ? (0, _source.getFileURL)(source, false) : (0, _source.getFilename)(source);

  return _react2.default.createElement(
    "span",
    { className: "location" },
    _react2.default.createElement(
      "span",
      { className: "filename" },
      filename
    ),
    ":",
    _react2.default.createElement(
      "span",
      { className: "line" },
      location.line
    )
  );
}

FrameLocation.displayName = "FrameLocation";

class FrameComponent extends _react.Component {

  onContextMenu(event) {
    const {
      frame,
      copyStackTrace,
      toggleFrameworkGrouping,
      toggleBlackBox,
      frameworkGroupingOn
    } = this.props;
    (0, _FrameMenu2.default)(frame, frameworkGroupingOn, { copyStackTrace, toggleFrameworkGrouping, toggleBlackBox }, event);
  }

  onMouseDown(e, frame, selectedFrame) {
    if (e.button !== 0) {
      return;
    }
    this.props.selectFrame(this.props.cx, frame);
  }

  onKeyUp(event, frame, selectedFrame) {
    if (event.key != "Enter") {
      return;
    }
    this.props.selectFrame(this.props.cx, frame);
  }

  render() {
    const {
      frame,
      selectedFrame,
      hideLocation,
      shouldMapDisplayName,
      displayFullUrl,
      getFrameTitle,
      disableContextMenu,
      selectable
    } = this.props;
    const { l10n } = this.context;

    const className = (0, _classnames2.default)("frame", {
      selected: selectedFrame && selectedFrame.id === frame.id
    });

    if (!frame.source) {
      throw new Error("no frame source");
    }

    const title = getFrameTitle ? getFrameTitle(`${(0, _source.getFileURL)(frame.source, false)}:${frame.location.line}`) : undefined;

    return _react2.default.createElement(
      "div",
      {
        role: "listitem",
        key: frame.id,
        className: className,
        onMouseDown: e => this.onMouseDown(e, frame, selectedFrame),
        onKeyUp: e => this.onKeyUp(e, frame, selectedFrame),
        onContextMenu: disableContextMenu ? null : e => this.onContextMenu(e),
        tabIndex: 0,
        title: title
      },
      selectable && _react2.default.createElement(_FrameIndent2.default, null),
      _react2.default.createElement(FrameTitle, {
        frame: frame,
        options: { shouldMapDisplayName },
        l10n: l10n
      }),
      !hideLocation && _react2.default.createElement(
        "span",
        { className: "clipboard-only" },
        " "
      ),
      !hideLocation && _react2.default.createElement(FrameLocation, { frame: frame, displayFullUrl: displayFullUrl }),
      selectable && _react2.default.createElement("br", { className: "clipboard-only" })
    );
  }
}

exports.default = FrameComponent;
FrameComponent.defaultProps = {
  hideLocation: false,
  shouldMapDisplayName: true,
  disableContextMenu: false
};
FrameComponent.displayName = "Frame";
FrameComponent.contextTypes = { l10n: _propTypes2.default.object };

/***/ }),
/* 606 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = FrameMenu;

var _devtoolsContextmenu = __webpack_require__(420);

var _clipboard = __webpack_require__(512);

var _lodash = __webpack_require__(417);

const blackboxString = "sourceFooter.blackbox"; /* This Source Code Form is subject to the terms of the Mozilla Public
                                                 * License, v. 2.0. If a copy of the MPL was not distributed with this
                                                 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const unblackboxString = "sourceFooter.unblackbox";

function formatMenuElement(labelString, click, disabled = false) {
  const label = L10N.getStr(labelString);
  const accesskey = L10N.getStr(`${labelString}.accesskey`);
  const id = `node-menu-${(0, _lodash.kebabCase)(label)}`;
  return {
    id,
    label,
    accesskey,
    disabled,
    click
  };
}

function copySourceElement(url) {
  return formatMenuElement("copySourceUri2", () => (0, _clipboard.copyToTheClipboard)(url));
}

function copyStackTraceElement(copyStackTrace) {
  return formatMenuElement("copyStackTrace", () => copyStackTrace());
}

function toggleFrameworkGroupingElement(toggleFrameworkGrouping, frameworkGroupingOn) {
  const actionType = frameworkGroupingOn ? "framework.disableGrouping" : "framework.enableGrouping";

  return formatMenuElement(actionType, () => toggleFrameworkGrouping());
}

function blackBoxSource(source, toggleBlackBox) {
  const toggleBlackBoxString = source.isBlackBoxed ? unblackboxString : blackboxString;

  return formatMenuElement(toggleBlackBoxString, () => toggleBlackBox(source));
}

function FrameMenu(frame, frameworkGroupingOn, callbacks, event) {
  event.stopPropagation();
  event.preventDefault();

  const menuOptions = [];

  const source = frame.source;

  const toggleFrameworkElement = toggleFrameworkGroupingElement(callbacks.toggleFrameworkGrouping, frameworkGroupingOn);
  menuOptions.push(toggleFrameworkElement);

  if (source) {
    const copySourceUri2 = copySourceElement(source.url);
    menuOptions.push(copySourceUri2);
    menuOptions.push(blackBoxSource(source, callbacks.toggleBlackBox));
  }

  const copyStackTraceItem = copyStackTraceElement(callbacks.copyStackTrace);

  menuOptions.push(copyStackTraceItem);

  (0, _devtoolsContextmenu.showMenu)(event, menuOptions);
}

/***/ }),
/* 607 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = FrameIndent;

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function FrameIndent() {
  return _react2.default.createElement(
    "span",
    { className: "frame-indent clipboard-only" },
    "\xA0\xA0\xA0\xA0"
  );
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/***/ }),
/* 608 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _connect = __webpack_require__(491);

var _classnames = __webpack_require__(67);

var _classnames2 = _interopRequireDefault(_classnames);

var _prefs = __webpack_require__(492);

var _selectors = __webpack_require__(490);

var _text = __webpack_require__(514);

var _actions = __webpack_require__(493);

var _actions2 = _interopRequireDefault(_actions);

var _CommandBarButton = __webpack_require__(554);

var _AccessibleImage = __webpack_require__(495);

var _AccessibleImage2 = _interopRequireDefault(_AccessibleImage);

__webpack_require__(609);

var _devtoolsServices = __webpack_require__(37);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* -*- indent-tabs-mode: nil; js-indent-level: 2; js-indent-level: 2 -*- */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const isMacOS = _devtoolsServices.appinfo.OS === "Darwin";

// NOTE: the "resume" command will call either the resume or breakOnNext action
// depending on whether or not the debugger is paused or running
const COMMANDS = ["resume", "stepOver", "stepIn", "stepOut"];

const KEYS = {
  WINNT: {
    resume: "F8",
    stepOver: "F10",
    stepIn: "F11",
    stepOut: "Shift+F11"
  },
  Darwin: {
    resume: "Cmd+\\",
    stepOver: "Cmd+'",
    stepIn: "Cmd+;",
    stepOut: "Cmd+Shift+:",
    stepOutDisplay: "Cmd+Shift+;"
  },
  Linux: {
    resume: "F8",
    stepOver: "F10",
    stepIn: "F11",
    stepOut: "Shift+F11"
  }
};

function getKey(action) {
  return getKeyForOS(_devtoolsServices.appinfo.OS, action);
}

function getKeyForOS(os, action) {
  const osActions = KEYS[os] || KEYS.Linux;
  return osActions[action];
}

function formatKey(action) {
  const key = getKey(`${action}Display`) || getKey(action);
  if (isMacOS) {
    const winKey = getKeyForOS("WINNT", `${action}Display`) || getKeyForOS("WINNT", action);
    // display both Windows type and Mac specific keys
    return (0, _text.formatKeyShortcut)([key, winKey].join(" "));
  }
  return (0, _text.formatKeyShortcut)(key);
}

class CommandBar extends _react.Component {
  componentWillUnmount() {
    const shortcuts = this.context.shortcuts;
    COMMANDS.forEach(action => shortcuts.off(getKey(action)));
    if (isMacOS) {
      COMMANDS.forEach(action => shortcuts.off(getKeyForOS("WINNT", action)));
    }
  }

  componentDidMount() {
    const shortcuts = this.context.shortcuts;

    COMMANDS.forEach(action => shortcuts.on(getKey(action), (_, e) => this.handleEvent(e, action)));

    if (isMacOS) {
      // The Mac supports both the Windows Function keys
      // as well as the Mac non-Function keys
      COMMANDS.forEach(action => shortcuts.on(getKeyForOS("WINNT", action), (_, e) => this.handleEvent(e, action)));
    }
  }

  handleEvent(e, action) {
    const { cx } = this.props;
    e.preventDefault();
    e.stopPropagation();
    if (action === "resume") {
      this.props.cx.isPaused ? this.props.resume(cx) : this.props.breakOnNext(cx);
    } else {
      this.props[action](cx);
    }
  }

  renderStepButtons() {
    const { cx, canRewind } = this.props;
    const className = cx.isPaused ? "active" : "disabled";
    const isDisabled = !cx.isPaused;

    if (canRewind || !cx.isPaused && _prefs.features.removeCommandBarOptions) {
      return;
    }

    return [(0, _CommandBarButton.debugBtn)(() => this.props.stepOver(cx), "stepOver", className, L10N.getFormatStr("stepOverTooltip", formatKey("stepOver")), isDisabled), (0, _CommandBarButton.debugBtn)(() => this.props.stepIn(cx), "stepIn", className, L10N.getFormatStr("stepInTooltip", formatKey("stepIn")), isDisabled), (0, _CommandBarButton.debugBtn)(() => this.props.stepOut(cx), "stepOut", className, L10N.getFormatStr("stepOutTooltip", formatKey("stepOut")), isDisabled)];
  }

  resume() {
    this.props.resume(this.props.cx);
  }

  renderPauseButton() {
    const { cx, breakOnNext, isWaitingOnBreak, canRewind } = this.props;

    if (cx.isPaused) {
      if (canRewind) {
        return null;
      }
      return (0, _CommandBarButton.debugBtn)(() => this.resume(), "resume", "active", L10N.getFormatStr("resumeButtonTooltip", formatKey("resume")));
    }

    if (_prefs.features.removeCommandBarOptions && !this.props.canRewind) {
      return;
    }

    if (isWaitingOnBreak) {
      return (0, _CommandBarButton.debugBtn)(null, "pause", "disabled", L10N.getStr("pausePendingButtonTooltip"), true);
    }

    return (0, _CommandBarButton.debugBtn)(() => breakOnNext(cx), "pause", "active", L10N.getFormatStr("pauseButtonTooltip", formatKey("resume")));
  }

  renderTimeTravelButtons() {
    const { cx, canRewind } = this.props;

    if (!canRewind || !cx.isPaused) {
      return null;
    }

    const isDisabled = !cx.isPaused;

    return [(0, _CommandBarButton.debugBtn)(() => this.props.rewind(cx), "rewind", "active", "Rewind Execution"), (0, _CommandBarButton.debugBtn)(() => this.props.resume(cx), "resume", "active", L10N.getFormatStr("resumeButtonTooltip", formatKey("resume"))), _react2.default.createElement("div", { key: "divider-1", className: "divider" }), (0, _CommandBarButton.debugBtn)(() => this.props.reverseStepOver(cx), "reverseStepOver", "active", "Reverse step over"), (0, _CommandBarButton.debugBtn)(() => this.props.stepOver(cx), "stepOver", "active", L10N.getFormatStr("stepOverTooltip", formatKey("stepOver")), isDisabled), _react2.default.createElement("div", { key: "divider-2", className: "divider" }), (0, _CommandBarButton.debugBtn)(() => this.props.stepOut(cx), "stepOut", "active", L10N.getFormatStr("stepOutTooltip", formatKey("stepOut")), isDisabled), (0, _CommandBarButton.debugBtn)(() => this.props.stepIn(cx), "stepIn", "active", L10N.getFormatStr("stepInTooltip", formatKey("stepIn")), isDisabled)];
  }

  renderSkipPausingButton() {
    const { skipPausing, toggleSkipPausing } = this.props;

    if (!_prefs.features.skipPausing) {
      return null;
    }

    return _react2.default.createElement(
      "button",
      {
        className: (0, _classnames2.default)("command-bar-button", "command-bar-skip-pausing", {
          active: skipPausing
        }),
        title: skipPausing ? L10N.getStr("undoSkipPausingTooltip.label") : L10N.getStr("skipPausingTooltip.label"),
        onClick: toggleSkipPausing
      },
      _react2.default.createElement(_AccessibleImage2.default, { className: "disable-pausing" })
    );
  }

  render() {
    return _react2.default.createElement(
      "div",
      {
        className: (0, _classnames2.default)("command-bar", {
          vertical: !this.props.horizontal
        })
      },
      this.renderPauseButton(),
      this.renderStepButtons(),
      this.renderTimeTravelButtons(),
      _react2.default.createElement("div", { className: "filler" }),
      this.renderSkipPausingButton()
    );
  }
}

CommandBar.contextTypes = {
  shortcuts: _propTypes2.default.object
};

const mapStateToProps = state => ({
  cx: (0, _selectors.getThreadContext)(state),
  isWaitingOnBreak: (0, _selectors.getIsWaitingOnBreak)(state, (0, _selectors.getCurrentThread)(state)),
  canRewind: (0, _selectors.getCanRewind)(state),
  skipPausing: (0, _selectors.getSkipPausing)(state)
});

exports.default = (0, _connect.connect)(mapStateToProps, {
  resume: _actions2.default.resume,
  stepIn: _actions2.default.stepIn,
  stepOut: _actions2.default.stepOut,
  stepOver: _actions2.default.stepOver,
  breakOnNext: _actions2.default.breakOnNext,
  rewind: _actions2.default.rewind,
  reverseStepIn: _actions2.default.reverseStepIn,
  reverseStepOut: _actions2.default.reverseStepOut,
  reverseStepOver: _actions2.default.reverseStepOver,
  pauseOnExceptions: _actions2.default.pauseOnExceptions,
  toggleSkipPausing: _actions2.default.toggleSkipPausing
})(CommandBar);

/***/ }),
/* 609 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 610 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _connect = __webpack_require__(491);

var _AccessibleImage = __webpack_require__(495);

var _AccessibleImage2 = _interopRequireDefault(_AccessibleImage);

var _pause = __webpack_require__(550);

var _selectors = __webpack_require__(490);

__webpack_require__(764);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

class WhyPaused extends _react.PureComponent {
  constructor(props) {
    super(props);
    this.state = { hideWhyPaused: "" };
  }

  componentDidUpdate() {
    const { delay } = this.props;

    if (delay) {
      setTimeout(() => {
        this.setState({ hideWhyPaused: "" });
      }, delay);
    } else {
      this.setState({ hideWhyPaused: "pane why-paused" });
    }
  }

  renderExceptionSummary(exception) {
    if (typeof exception === "string") {
      return exception;
    }

    const preview = exception.preview;
    if (!preview || !preview.name || !preview.message) {
      return;
    }

    return `${preview.name}: ${preview.message}`;
  }

  renderMessage(why) {
    if (why.type == "exception" && why.exception) {
      return _react2.default.createElement(
        "div",
        { className: "message warning" },
        this.renderExceptionSummary(why.exception)
      );
    }

    if (typeof why.message == "string") {
      return _react2.default.createElement(
        "div",
        { className: "message" },
        why.message
      );
    }

    return null;
  }

  render() {
    const { endPanelCollapsed, why } = this.props;
    const reason = (0, _pause.getPauseReason)(why);

    if (reason) {
      if (!endPanelCollapsed) {
        return _react2.default.createElement(
          "div",
          { className: "pane why-paused" },
          _react2.default.createElement(
            "div",
            null,
            _react2.default.createElement(
              "div",
              { className: "pause reason" },
              L10N.getStr(reason),
              this.renderMessage(why)
            ),
            _react2.default.createElement(
              "div",
              { className: "info icon" },
              _react2.default.createElement(_AccessibleImage2.default, { className: "info" })
            )
          )
        );
      }
    }
    return _react2.default.createElement("div", { className: this.state.hideWhyPaused });
  }
}

const mapStateToProps = state => {
  const thread = (0, _selectors.getCurrentThread)(state);
  return {
    endPanelCollapsed: (0, _selectors.getPaneCollapse)(state, "end"),
    why: (0, _selectors.getPauseReason)(state, thread)
  };
};

exports.default = (0, _connect.connect)(mapStateToProps)(WhyPaused);

/***/ }),
/* 611 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(612);


/***/ }),
/* 612 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _reactDom = __webpack_require__(112);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _client = __webpack_require__(613);

var _bootstrap = __webpack_require__(566);

var _sourceQueue = __webpack_require__(513);

var _sourceQueue2 = _interopRequireDefault(_sourceQueue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function unmountRoot() {
  const mount = document.querySelector("#mount .launchpad-root");
  _reactDom2.default.unmountComponentAtNode(mount);
}

module.exports = {
  bootstrap: ({
    threadClient,
    tabTarget,
    debuggerClient,
    sourceMaps,
    panel
  }) => (0, _client.onConnect)({
    tab: { clientType: "firefox" },
    tabConnection: {
      tabTarget,
      threadClient,
      debuggerClient
    }
  }, sourceMaps, panel),
  destroy: () => {
    unmountRoot();
    _sourceQueue2.default.clear();
    (0, _bootstrap.teardownWorkers)();
  }
};

/***/ }),
/* 613 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.onConnect = onConnect;

var _firefox = __webpack_require__(508);

var firefox = _interopRequireWildcard(_firefox);

var _chrome = __webpack_require__(616);

var chrome = _interopRequireWildcard(_chrome);

var _prefs = __webpack_require__(492);

var _dbg = __webpack_require__(619);

var _bootstrap = __webpack_require__(566);

var _breakpoints = __webpack_require__(518);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

async function syncBreakpoints() {
  const breakpoints = await _prefs.asyncStore.pendingBreakpoints;
  const breakpointValues = Object.values(breakpoints);
  breakpointValues.forEach(({ disabled, options, generatedLocation }) => {
    if (!disabled) {
      firefox.clientCommands.setBreakpoint(generatedLocation, options);
    }
  });
}

function syncXHRBreakpoints() {
  _prefs.asyncStore.xhrBreakpoints.then(bps => {
    bps.forEach(({ path, method, disabled }) => {
      if (!disabled) {
        firefox.clientCommands.setXHRBreakpoint(path, method);
      }
    });
  });
}

async function loadInitialState() {
  const pendingBreakpoints = await _prefs.asyncStore.pendingBreakpoints;
  const tabs = await _prefs.asyncStore.tabs;
  const xhrBreakpoints = await _prefs.asyncStore.xhrBreakpoints;
  const eventListenerBreakpoints = await _prefs.asyncStore.eventListenerBreakpoints;

  const breakpoints = (0, _breakpoints.initialBreakpointsState)(xhrBreakpoints);

  return { pendingBreakpoints, tabs, breakpoints, eventListenerBreakpoints };
}

function getClient(connection) {
  const {
    tab: { clientType }
  } = connection;
  return clientType == "firefox" ? firefox : chrome;
}

async function onConnect(connection, sourceMaps, panel) {
  // NOTE: the landing page does not connect to a JS process
  if (!connection) {
    return;
  }

  (0, _prefs.verifyPrefSchema)();

  const client = getClient(connection);
  const commands = client.clientCommands;

  const initialState = await loadInitialState();

  const { store, actions, selectors } = (0, _bootstrap.bootstrapStore)(commands, sourceMaps, panel, initialState);

  const workers = (0, _bootstrap.bootstrapWorkers)();
  await client.onConnect(connection, actions);

  await syncBreakpoints();
  syncXHRBreakpoints();
  (0, _dbg.setupHelper)({
    store,
    actions,
    selectors,
    workers: { ...workers, sourceMaps },
    connection,
    client: client.clientCommands
  });

  (0, _bootstrap.bootstrapApp)(store);
  return { store, actions, selectors, client: commands };
}

/***/ }),
/* 614 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.supportsWorkers = supportsWorkers;
exports.updateWorkerClients = updateWorkerClients;

var _events = __webpack_require__(559);

function supportsWorkers(tabTarget) {
  return tabTarget.isBrowsingContext || tabTarget.isContentProcess;
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

async function updateWorkerClients({
  tabTarget,
  debuggerClient,
  threadClient,
  workerClients,
  options
}) {
  if (!supportsWorkers(tabTarget)) {
    return {};
  }

  const newWorkerClients = {};

  const { workers } = await tabTarget.listWorkers();
  for (const workerTargetFront of workers) {
    try {
      await workerTargetFront.attach();
      const [, workerThread] = await workerTargetFront.attachThread(options);

      const actor = workerThread.actor;
      if (workerClients[actor]) {
        if (workerClients[actor].thread != workerThread) {
          console.error(`Multiple clients for actor ID: ${workerThread.actor}`);
        }
        newWorkerClients[actor] = workerClients[actor];
      } else {
        (0, _events.addThreadEventListeners)(workerThread);
        workerThread.resume();

        const consoleFront = await workerTargetFront.getFront("console");
        await consoleFront.startListeners([]);

        newWorkerClients[actor] = {
          url: workerTargetFront.url,
          thread: workerThread,
          console: consoleFront
        };
      }
    } catch (e) {
      // If any of the workers have terminated since the list command initiated
      // then we will get errors. Ignore these.
    }
  }

  return newWorkerClients;
}

/***/ }),
/* 615 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.asyncStoreHelper = asyncStoreHelper;

var _devtoolsModules = __webpack_require__(183);

/*
 * asyncStoreHelper wraps asyncStorage so that it is easy to define project
 * specific properties. It is similar to PrefsHelper.
 *
 * e.g.
 *   const asyncStore = asyncStoreHelper("r", {a: "_a"})
 *   asyncStore.a         // => asyncStorage.getItem("r._a")
 *   asyncStore.a = 2     // => asyncStorage.setItem("r._a", 2)
 */
function asyncStoreHelper(root, mappings) {
  let store = {};

  function getMappingKey(key) {
    return Array.isArray(mappings[key]) ? mappings[key][0] : mappings[key];
  }

  function getMappingDefaultValue(key) {
    return Array.isArray(mappings[key]) ? mappings[key][1] : null;
  }

  Object.keys(mappings).map(key => Object.defineProperty(store, key, {
    async get() {
      const value = await _devtoolsModules.asyncStorage.getItem(`${root}.${getMappingKey(key)}`);
      return value || getMappingDefaultValue(key);
    },
    set(value) {
      return _devtoolsModules.asyncStorage.setItem(`${root}.${getMappingKey(key)}`, value);
    }
  }));

  store = new Proxy(store, {
    set: function (target, property, value, receiver) {
      if (!mappings.hasOwnProperty(property)) {
        throw new Error(`AsyncStore: ${property} is not defined in mappings`);
      }

      Reflect.set(...arguments);
      return true;
    }
  });

  return store;
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/***/ }),
/* 616 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clientEvents = exports.clientCommands = undefined;
exports.onConnect = onConnect;

var _commands = __webpack_require__(617);

var _events = __webpack_require__(618);

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

async function onConnect(connection, actions) {
  const {
    tabConnection,
    connTarget: { type }
  } = connection;
  const { Debugger, Runtime, Page } = tabConnection;

  Debugger.enable();
  Debugger.setPauseOnExceptions({ state: "none" });
  Debugger.setAsyncCallStackDepth({ maxDepth: 0 });

  if (type == "chrome") {
    Page.frameNavigated(_events.pageEvents.frameNavigated);
    Page.frameStartedLoading(_events.pageEvents.frameStartedLoading);
    Page.frameStoppedLoading(_events.pageEvents.frameStoppedLoading);
  }

  Debugger.scriptParsed(_events.clientEvents.scriptParsed);
  Debugger.scriptFailedToParse(_events.clientEvents.scriptFailedToParse);
  Debugger.paused(_events.clientEvents.paused);
  Debugger.resumed(_events.clientEvents.resumed);

  (0, _commands.setupCommands)({ Debugger, Runtime, Page });
  (0, _events.setupEvents)({ actions, Page, type, Runtime });
  return {};
}

exports.clientCommands = _commands.clientCommands;
exports.clientEvents = _events.clientEvents;

/***/ }),
/* 617 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clientCommands = exports.setupCommands = undefined;

var _create = __webpack_require__(560);

let debuggerAgent; /* This Source Code Form is subject to the terms of the Mozilla Public
                    * License, v. 2.0. If a copy of the MPL was not distributed with this
                    * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

let runtimeAgent;
let pageAgent;

function setupCommands({ Debugger, Runtime, Page }) {
  debuggerAgent = Debugger;
  runtimeAgent = Runtime;
  pageAgent = Page;
}

function resume() {
  return debuggerAgent.resume();
}

function stepIn() {
  return debuggerAgent.stepInto();
}

function stepOver() {
  return debuggerAgent.stepOver();
}

function stepOut() {
  return debuggerAgent.stepOut();
}

function pauseOnExceptions(shouldPauseOnExceptions, shouldIgnoreCaughtExceptions) {
  if (!shouldPauseOnExceptions) {
    return debuggerAgent.setPauseOnExceptions({ state: "none" });
  }
  const state = shouldIgnoreCaughtExceptions ? "uncaught" : "all";
  return debuggerAgent.setPauseOnExceptions({ state });
}

function breakOnNext() {
  return debuggerAgent.pause();
}

function sourceContents(sourceId) {
  return debuggerAgent.getScriptSource({ scriptId: sourceId }).then(({ scriptSource }) => ({
    source: scriptSource,
    contentType: null
  }));
}

async function setBreakpoint(location, condition) {
  const {
    breakpointId,
    serverLocation
  } = await debuggerAgent.setBreakpoint({
    location: (0, _create.toServerLocation)(location),
    columnNumber: location.column
  });

  const actualLocation = (0, _create.fromServerLocation)(serverLocation) || location;

  return {
    id: breakpointId,
    actualLocation: actualLocation
  };
}

function removeBreakpoint(breakpointId) {
  return debuggerAgent.removeBreakpoint({ breakpointId });
}

async function getProperties(object) {
  const { result } = await runtimeAgent.getProperties({
    objectId: object.objectId
  });

  const loadedObjects = result.map(_create.createLoadedObject);

  return { loadedObjects };
}

function evaluate(script) {
  return runtimeAgent.evaluate({ expression: script });
}

function debuggeeCommand(script) {
  evaluate(script);
  return Promise.resolve();
}

function navigate(url) {
  return pageAgent.navigate({ url });
}

function getBreakpointByLocation(location) {}

function getFrameScopes() {}
function evaluateInFrame() {}
function evaluateExpressions() {}

const clientCommands = {
  resume,
  stepIn,
  stepOut,
  stepOver,
  pauseOnExceptions,
  breakOnNext,
  sourceContents,
  setBreakpoint,
  removeBreakpoint,
  evaluate,
  debuggeeCommand,
  navigate,
  getProperties,
  getBreakpointByLocation,
  getFrameScopes,
  evaluateInFrame,
  evaluateExpressions
};

exports.setupCommands = setupCommands;
exports.clientCommands = clientCommands;

/***/ }),
/* 618 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clientEvents = exports.pageEvents = exports.setupEvents = undefined;

var _create = __webpack_require__(560);

var _sourceQueue = __webpack_require__(513);

var _sourceQueue2 = _interopRequireDefault(_sourceQueue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

let actions;
let pageAgent;
let clientType;
let runtimeAgent;

function setupEvents(dependencies) {
  actions = dependencies.actions;
  pageAgent = dependencies.Page;
  clientType = dependencies.clientType;
  runtimeAgent = dependencies.Runtime;
  _sourceQueue2.default.initialize(actions);
}

// Debugger Events
function scriptParsed({
  scriptId,
  url,
  startLine,
  startColumn,
  endLine,
  endColumn,
  executionContextId,
  hash,
  isContentScript,
  isInternalScript,
  isLiveEdit,
  sourceMapURL,
  hasSourceURL,
  deprecatedCommentWasUsed
}) {
  if (isContentScript) {
    return;
  }

  if (clientType == "node") {
    sourceMapURL = undefined;
  }

  actions.newSource({
    id: scriptId,
    url,
    sourceMapURL,
    isPrettyPrinted: false
  });
}

function scriptFailedToParse() {}

async function paused({
  callFrames,
  reason,
  data,
  hitBreakpoints,
  asyncStackTrace
}) {
  const frames = callFrames.map(_create.createFrame);
  const frame = frames[0];
  const why = { type: reason, ...data };

  const objectId = frame.scopeChain[0].object.objectId;
  const { result } = await runtimeAgent.getProperties({
    objectId
  });

  const loadedObjects = result.map(_create.createLoadedObject);

  if (clientType == "chrome") {
    pageAgent.configureOverlay({ message: "Paused in debugger.html" });
  }
  await actions.paused({ thread: "root", frame, why, frames, loadedObjects });
}

function resumed() {
  if (clientType == "chrome") {
    pageAgent.configureOverlay({ suspended: false });
  }

  actions.resumed();
}

function globalObjectCleared() {}

// Page Events
function frameNavigated(frame) {
  actions.navigated();
}

function frameStartedLoading() {
  actions.willNavigate();
}

function domContentEventFired() {}

function loadEventFired() {}

function frameStoppedLoading() {}

const clientEvents = {
  scriptParsed,
  scriptFailedToParse,
  paused,
  resumed,
  globalObjectCleared
};

const pageEvents = {
  frameNavigated,
  frameStartedLoading,
  domContentEventFired,
  loadEventFired,
  frameStoppedLoading
};

exports.setupEvents = setupEvents;
exports.pageEvents = pageEvents;
exports.clientEvents = clientEvents;

/***/ }),
/* 619 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setupHelper = setupHelper;

var _timings = __webpack_require__(620);

var timings = _interopRequireWildcard(_timings);

var _prefs = __webpack_require__(492);

var _devtoolsEnvironment = __webpack_require__(102);

var _sourceDocuments = __webpack_require__(540);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function findSource(dbg, url) {
  const sources = dbg.selectors.getSourceList();
  return sources.find(s => (s.url || "").includes(url));
}

function findSources(dbg, url) {
  const sources = dbg.selectors.getSourceList();
  return sources.filter(s => (s.url || "").includes(url));
}

function sendPacket(dbg, packet) {
  return dbg.client.sendPacket(packet);
}

function sendPacketToThread(dbg, packet) {
  return sendPacket(dbg, {
    to: dbg.connection.tabConnection.threadClient.actor,
    ...packet
  });
}

function evaluate(dbg, expression) {
  return dbg.client.evaluate(expression);
}

function bindSelectors(obj) {
  return Object.keys(obj.selectors).reduce((bound, selector) => {
    bound[selector] = (a, b, c) => obj.selectors[selector](obj.store.getState(), a, b, c);
    return bound;
  }, {});
}

function getCM() {
  const cm = document.querySelector(".CodeMirror");
  return cm && cm.CodeMirror;
}

function formatMappedLocation(mappedLocation) {
  const { location, generatedLocation } = mappedLocation;
  return {
    original: `(${location.line}, ${location.column})`,
    generated: `(${generatedLocation.line}, ${generatedLocation.column})`
  };
}

function formatMappedLocations(locations) {
  return console.table(locations.map(loc => formatMappedLocation(loc)));
}

function formatSelectedColumnBreakpoints(dbg) {
  const positions = dbg.selectors.getBreakpointPositionsForSource(dbg.selectors.getSelectedSource().id);

  return formatMappedLocations(positions);
}

function getDocumentForUrl(dbg, url) {
  const source = findSource(dbg, url);
  return (0, _sourceDocuments.getDocument)(source.id);
}

function setupHelper(obj) {
  const selectors = bindSelectors(obj);
  const dbg = {
    ...obj,
    selectors,
    prefs: _prefs.prefs,
    asyncStore: _prefs.asyncStore,
    features: _prefs.features,
    timings,
    getCM,
    helpers: {
      findSource: url => findSource(dbg, url),
      findSources: url => findSources(dbg, url),
      evaluate: expression => evaluate(dbg, expression),
      sendPacketToThread: packet => sendPacketToThread(dbg, packet),
      sendPacket: packet => sendPacket(dbg, packet),
      dumpThread: () => sendPacketToThread(dbg, { type: "dumpThread" }),
      getDocument: url => getDocumentForUrl(dbg, url)
    },
    formatters: {
      mappedLocations: locations => formatMappedLocations(locations),
      mappedLocation: location => formatMappedLocation(location),
      selectedColumnBreakpoints: () => formatSelectedColumnBreakpoints(dbg)
    },
    _telemetry: {
      events: {}
    }
  };

  window.dbg = dbg;

  if ((0, _devtoolsEnvironment.isDevelopment)() && !(0, _devtoolsEnvironment.isTesting)()) {
    console.group("Development Notes");
    const baseUrl = "https://firefox-devtools.github.io/debugger";
    const localDevelopmentUrl = `${baseUrl}/docs/dbg.html`;
    console.log("Debugging Tips", localDevelopmentUrl);
    console.log("dbg", window.dbg);
    console.groupEnd();
  }
}

/***/ }),
/* 620 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAsyncTimes = getAsyncTimes;
exports.steppingTimings = steppingTimings;

var _lodash = __webpack_require__(417);

function getAsyncTimes(name) {
  return (0, _lodash.zip)(window.performance.getEntriesByName(`${name}_start`), window.performance.getEntriesByName(`${name}_end`)).map(([start, end]) => +(end.startTime - start.startTime).toPrecision(2));
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function getTimes(name) {
  return window.performance.getEntriesByName(name).map(time => +time.duration.toPrecision(2));
}

function getStats(times) {
  if (times.length == 0) {
    return { times: [], avg: null, median: null };
  }
  const avg = times.reduce((sum, time) => time + sum, 0) / times.length;
  const sortedtimings = [...times].sort((a, b) => a - b);
  const median = sortedtimings[times.length / 2];
  return {
    times,
    avg: +avg.toPrecision(2),
    median: +median.toPrecision(2)
  };
}

function steppingTimings() {
  const commandTimings = getAsyncTimes("COMMAND");
  const pausedTimings = getTimes("PAUSED");

  return {
    commands: getStats(commandTimings),
    paused: getStats(pausedTimings)
  };
}

// console.log("..", asyncTimes("COMMAND"));

/***/ }),
/* 621 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isMinified = isMinified;

var _asyncValue = __webpack_require__(497);

// Used to detect minification for automatic pretty printing
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const SAMPLE_SIZE = 50;
const INDENT_COUNT_THRESHOLD = 5;
const CHARACTER_LIMIT = 250;
const _minifiedCache = new Map();

function isMinified({ source, content }) {
  if (_minifiedCache.has(source.id)) {
    return _minifiedCache.get(source.id);
  }

  if (!content || !(0, _asyncValue.isFulfilled)(content) || content.value.type !== "text") {
    return false;
  }

  let text = content.value.value;

  let lineEndIndex = 0;
  let lineStartIndex = 0;
  let lines = 0;
  let indentCount = 0;
  let overCharLimit = false;

  // Strip comments.
  text = text.replace(/\/\*[\S\s]*?\*\/|\/\/(.+|\n)/g, "");

  while (lines++ < SAMPLE_SIZE) {
    lineEndIndex = text.indexOf("\n", lineStartIndex);
    if (lineEndIndex == -1) {
      break;
    }
    if (/^\s+/.test(text.slice(lineStartIndex, lineEndIndex))) {
      indentCount++;
    }
    // For files with no indents but are not minified.
    if (lineEndIndex - lineStartIndex > CHARACTER_LIMIT) {
      overCharLimit = true;
      break;
    }
    lineStartIndex = lineEndIndex + 1;
  }

  const minified = indentCount / lines * 100 < INDENT_COUNT_THRESHOLD || overCharLimit;

  _minifiedCache.set(source.id, minified);
  return minified;
}

/***/ }),
/* 622 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_622__;

/***/ }),
/* 623 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_623__;

/***/ }),
/* 624 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTokenLocation = getTokenLocation;
function getTokenLocation(codeMirror, tokenEl) {
  const { left, top, width, height } = tokenEl.getBoundingClientRect();
  const { line, ch } = codeMirror.coordsChar({
    left: left + width / 2,
    top: top + height / 2
  });

  return {
    line: line + 1,
    column: ch
  };
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/***/ }),
/* 625 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildQuery = undefined;
exports.getMatchIndex = getMatchIndex;
exports.searchSourceForHighlight = searchSourceForHighlight;
exports.removeOverlay = removeOverlay;
exports.clearSearch = clearSearch;
exports.find = find;
exports.findNext = findNext;
exports.findPrev = findPrev;

var _buildQuery = __webpack_require__(386);

var _buildQuery2 = _interopRequireDefault(_buildQuery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @memberof utils/source-search
 * @static
 */
function getSearchCursor(cm, query, pos, modifiers) {
  const regexQuery = (0, _buildQuery2.default)(query, modifiers, { isGlobal: true });
  return cm.getSearchCursor(regexQuery, pos);
}

/**
 * @memberof utils/source-search
 * @static
 */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function SearchState() {
  this.posFrom = this.posTo = this.query = null;
  this.overlay = null;
  this.results = [];
}

/**
 * @memberof utils/source-search
 * @static
 */
function getSearchState(cm, query) {
  const state = cm.state.search || (cm.state.search = new SearchState());
  return state;
}

function isWhitespace(query) {
  return !query.match(/\S/);
}

/**
 * This returns a mode object used by CoeMirror's addOverlay function
 * to parse and style tokens in the file.
 * The mode object contains a tokenizer function (token) which takes
 * a character stream as input, advances it a character at a time,
 * and returns style(s) for that token. For more details see
 * https://codemirror.net/doc/manual.html#modeapi
 *
 * Also the token function code is mainly based of work done
 * by the chrome devtools team. Thanks guys! :)
 *
 * @memberof utils/source-search
 * @static
 */
function searchOverlay(query, modifiers) {
  const regexQuery = (0, _buildQuery2.default)(query, modifiers, {
    ignoreSpaces: true,
    // regex must be global for the overlay
    isGlobal: true
  });

  return {
    token: function (stream, state) {
      // set the last index to be the current stream position
      // this acts as an offset
      regexQuery.lastIndex = stream.pos;
      const match = regexQuery.exec(stream.string);
      if (match && match.index === stream.pos) {
        // if we have a match at the current stream position
        // set the class for a match
        stream.pos += match[0].length || 1;
        return "highlight highlight-full";
      } else if (match) {
        // if we have a match somewhere in the line, go to that point in the
        // stream
        stream.pos = match.index;
      } else {
        // if we have no matches in this line, skip to the end of the line
        stream.skipToEnd();
      }
    }
  };
}

/**
 * @memberof utils/source-search
 * @static
 */
function updateOverlay(cm, state, query, modifiers) {
  cm.removeOverlay(state.overlay);
  state.overlay = searchOverlay(query, modifiers);
  cm.addOverlay(state.overlay, { opaque: false });
}

function updateCursor(cm, state, keepSelection) {
  state.posTo = cm.getCursor("anchor");
  state.posFrom = cm.getCursor("head");

  if (!keepSelection) {
    state.posTo = { line: 0, ch: 0 };
    state.posFrom = { line: 0, ch: 0 };
  }
}

function getMatchIndex(count, currentIndex, rev) {
  if (!rev) {
    if (currentIndex == count - 1) {
      return 0;
    }

    return currentIndex + 1;
  }

  if (currentIndex == 0) {
    return count - 1;
  }

  return currentIndex - 1;
}

/**
 * If there's a saved search, selects the next results.
 * Otherwise, creates a new search and selects the first
 * result.
 *
 * @memberof utils/source-search
 * @static
 */
function doSearch(ctx, rev, query, keepSelection, modifiers, focusFirstResult = true) {
  const { cm, ed } = ctx;
  if (!cm) {
    return;
  }
  const defaultIndex = { line: -1, ch: -1 };

  return cm.operation(function () {
    if (!query || isWhitespace(query)) {
      clearSearch(cm, query);
      return;
    }

    const state = getSearchState(cm, query);
    const isNewQuery = state.query !== query;
    state.query = query;

    updateOverlay(cm, state, query, modifiers);
    updateCursor(cm, state, keepSelection);
    const searchLocation = searchNext(ctx, rev, query, isNewQuery, modifiers);

    // We don't want to jump the editor
    // when we're selecting text
    if (!cm.state.selectingText && searchLocation && focusFirstResult) {
      ed.alignLine(searchLocation.from.line, "center");
      cm.setSelection(searchLocation.from, searchLocation.to);
    }

    return searchLocation ? searchLocation.from : defaultIndex;
  });
}

function searchSourceForHighlight(ctx, rev, query, keepSelection, modifiers, line, ch) {
  const { cm } = ctx;
  if (!cm) {
    return;
  }

  return cm.operation(function () {
    const state = getSearchState(cm, query);
    const isNewQuery = state.query !== query;
    state.query = query;

    updateOverlay(cm, state, query, modifiers);
    updateCursor(cm, state, keepSelection);
    findNextOnLine(ctx, rev, query, isNewQuery, modifiers, line, ch);
  });
}

function getCursorPos(newQuery, rev, state) {
  if (newQuery) {
    return rev ? state.posFrom : state.posTo;
  }

  return rev ? state.posTo : state.posFrom;
}

/**
 * Selects the next result of a saved search.
 *
 * @memberof utils/source-search
 * @static
 */
function searchNext(ctx, rev, query, newQuery, modifiers) {
  const { cm } = ctx;
  let nextMatch;
  cm.operation(function () {
    const state = getSearchState(cm, query);
    const pos = getCursorPos(newQuery, rev, state);

    if (!state.query) {
      return;
    }

    let cursor = getSearchCursor(cm, state.query, pos, modifiers);

    const location = rev ? { line: cm.lastLine(), ch: null } : { line: cm.firstLine(), ch: 0 };

    if (!cursor.find(rev) && state.query) {
      cursor = getSearchCursor(cm, state.query, location, modifiers);
      if (!cursor.find(rev)) {
        return;
      }
    }

    nextMatch = { from: cursor.from(), to: cursor.to() };
  });

  return nextMatch;
}

function findNextOnLine(ctx, rev, query, newQuery, modifiers, line, ch) {
  const { cm, ed } = ctx;
  cm.operation(function () {
    const pos = { line: line - 1, ch };
    let cursor = getSearchCursor(cm, query, pos, modifiers);

    if (!cursor.find(rev) && query) {
      cursor = getSearchCursor(cm, query, pos, modifiers);
      if (!cursor.find(rev)) {
        return;
      }
    }

    // We don't want to jump the editor
    // when we're selecting text
    if (!cm.state.selectingText) {
      ed.alignLine(cursor.from().line, "center");
      cm.setSelection(cursor.from(), cursor.to());
    }
  });
}

/**
 * Remove overlay.
 *
 * @memberof utils/source-search
 * @static
 */
function removeOverlay(ctx, query) {
  const state = getSearchState(ctx.cm, query);
  ctx.cm.removeOverlay(state.overlay);
  const { line, ch } = ctx.cm.getCursor();
  ctx.cm.doc.setSelection({ line, ch }, { line, ch }, { scroll: false });
}

/**
 * Clears the currently saved search.
 *
 * @memberof utils/source-search
 * @static
 */
function clearSearch(cm, query) {
  const state = getSearchState(cm, query);

  state.results = [];

  if (!state.query) {
    return;
  }
  cm.removeOverlay(state.overlay);
  state.query = null;
}

/**
 * Starts a new search.
 *
 * @memberof utils/source-search
 * @static
 */
function find(ctx, query, keepSelection, modifiers, focusFirstResult) {
  clearSearch(ctx.cm, query);
  return doSearch(ctx, false, query, keepSelection, modifiers, focusFirstResult);
}

/**
 * Finds the next item based on the currently saved search.
 *
 * @memberof utils/source-search
 * @static
 */
function findNext(ctx, query, keepSelection, modifiers) {
  return doSearch(ctx, false, query, keepSelection, modifiers);
}

/**
 * Finds the previous item based on the currently saved search.
 *
 * @memberof utils/source-search
 * @static
 */
function findPrev(ctx, query, keepSelection, modifiers) {
  return doSearch(ctx, true, query, keepSelection, modifiers);
}

exports.buildQuery = _buildQuery2.default;

/***/ }),
/* 626 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.onMouseOver = onMouseOver;

var _ = __webpack_require__(496);

var _lodash = __webpack_require__(417);

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function isInvalidTarget(target) {
  if (!target || !target.innerText) {
    return true;
  }

  const tokenText = target.innerText.trim();
  const cursorPos = target.getBoundingClientRect();

  // exclude literal tokens where it does not make sense to show a preview
  const invalidType = ["cm-atom", ""].includes(target.className);

  // exclude syntax where the expression would be a syntax error
  const invalidToken = tokenText === "" || tokenText.match(/^[(){}\|&%,.;=<>\+-/\*\s](?=)/);

  // exclude codemirror elements that are not tokens
  const invalidTarget = target.parentElement && !target.parentElement.closest(".CodeMirror-line") || cursorPos.top == 0;

  const invalidClasses = ["editor-mount"];
  if (invalidClasses.some(className => target.classList.contains(className))) {
    return true;
  }

  if (target.closest(".popover")) {
    return true;
  }

  return invalidTarget || invalidToken || invalidType;
}

function dispatch(codeMirror, eventName, data) {
  codeMirror.constructor.signal(codeMirror, eventName, data);
}

function invalidLeaveTarget(target) {
  if (!target || target.closest(".popover")) {
    return true;
  }

  return false;
}

function onMouseOver(codeMirror) {
  let prevTokenPos = null;

  function onMouseLeave(event) {
    if (invalidLeaveTarget(event.relatedTarget)) {
      return addMouseLeave(event.target);
    }

    prevTokenPos = null;
    dispatch(codeMirror, "tokenleave", event);
  }

  function addMouseLeave(target) {
    target.addEventListener("mouseleave", onMouseLeave, {
      capture: true,
      once: true
    });
  }

  return enterEvent => {
    const { target } = enterEvent;

    if (isInvalidTarget(target)) {
      return;
    }

    const tokenPos = (0, _.getTokenLocation)(codeMirror, target);

    if (!(0, _lodash.isEqual)(prevTokenPos, tokenPos)) {
      addMouseLeave(target);

      dispatch(codeMirror, "tokenenter", {
        event: enterEvent,
        target,
        tokenPos
      });
      prevTokenPos = tokenPos;
    }
  };
}

/***/ }),
/* 627 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatTree = formatTree;
function formatTree(tree, depth = 0, str = "") {
  const whitespace = new Array(depth * 2).join(" ");

  if (tree.type === "directory") {
    str += `${whitespace} - ${tree.name} path=${tree.path} \n`;
    tree.contents.forEach(t => {
      str = formatTree(t, depth + 1, str);
    });
  } else {
    const id = tree.contents.id;
    str += `${whitespace} - ${tree.name} path=${tree.path} source_id=${id} \n`;
  }

  return str;
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/***/ }),
/* 628 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDirectories = getDirectories;

var _utils = __webpack_require__(506);

function _traverse(subtree, source) {
  if (subtree.type === "source") {
    if (subtree.contents.id === source.id) {
      return subtree;
    }

    return null;
  }

  const matches = subtree.contents.map(child => _traverse(child, source));
  return matches && matches.filter(Boolean)[0];
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function findSourceItem(sourceTree, source) {
  return _traverse(sourceTree, source);
}

function getAncestors(sourceTree, item) {
  if (!item) {
    return null;
  }

  const parentMap = (0, _utils.createParentMap)(sourceTree);
  const directories = [];

  directories.push(item);
  while (true) {
    item = parentMap.get(item);
    if (!item) {
      return directories;
    }
    directories.push(item);
  }
}

function getDirectories(source, sourceTree) {
  const item = findSourceItem(sourceTree, source);
  const ancestors = getAncestors(sourceTree, item);
  return ancestors || [sourceTree];
}

/***/ }),
/* 629 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sortTree = sortTree;

var _utils = __webpack_require__(506);

/**
 * Look at the nodes in the source tree, and determine the index of where to
 * insert a new node. The ordering is index -> folder -> file.
 * @memberof utils/sources-tree
 * @static
 */
function sortTree(tree, debuggeeUrl = "") {
  return tree.contents.sort((previousNode, currentNode) => {
    const currentNodeIsDir = (0, _utils.nodeHasChildren)(currentNode);
    const previousNodeIsDir = (0, _utils.nodeHasChildren)(previousNode);
    if (currentNode.name === "(index)") {
      return 1;
    } else if (previousNode.name === "(index)") {
      return -1;
    } else if ((0, _utils.isExactUrlMatch)(currentNode.name, debuggeeUrl)) {
      return 1;
    } else if ((0, _utils.isExactUrlMatch)(previousNode.name, debuggeeUrl)) {
      return -1;
      // If neither is the case, continue to compare alphabetically
    } else if (previousNodeIsDir && !currentNodeIsDir) {
      return -1;
    } else if (!previousNodeIsDir && currentNodeIsDir) {
      return 1;
    }
    return previousNode.name.localeCompare(currentNode.name);
  });
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/***/ }),
/* 630 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createTree = createTree;
exports.updateTree = updateTree;

var _addToTree = __webpack_require__(563);

var _collapseTree = __webpack_require__(565);

var _utils = __webpack_require__(506);

var _treeOrder = __webpack_require__(564);

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function getSourcesToAdd(newSources, prevSources) {
  const sourcesToAdd = [];

  for (const sourceId in newSources) {
    const newSource = newSources[sourceId];
    const prevSource = prevSources ? prevSources[sourceId] : null;
    if (!prevSource) {
      sourcesToAdd.push(newSource);
    }
  }

  return sourcesToAdd;
}

function createTree({
  debuggeeUrl,
  sources,
  threads
}) {
  const uncollapsedTree = (0, _utils.createDirectoryNode)("root", "", []);

  return updateTree({
    debuggeeUrl,
    newSources: sources,
    prevSources: {},
    threads,
    uncollapsedTree
  });
}

function updateTree({
  newSources,
  prevSources,
  debuggeeUrl,
  uncollapsedTree,
  threads
}) {
  const debuggeeHost = (0, _treeOrder.getDomain)(debuggeeUrl);
  const contexts = Object.keys(newSources);

  contexts.forEach(context => {
    const thread = threads.find(t => t.actor === context);
    if (!thread) {
      return;
    }

    const sourcesToAdd = getSourcesToAdd(Object.values(newSources[context]), prevSources[context] ? Object.values(prevSources[context]) : null);

    for (const source of sourcesToAdd) {
      (0, _addToTree.addToTree)(uncollapsedTree, source, debuggeeHost, thread.actor);
    }
  });

  const newSourceTree = (0, _collapseTree.collapseTree)(uncollapsedTree);

  return {
    uncollapsedTree,
    sourceTree: newSourceTree,
    parentMap: (0, _utils.createParentMap)(newSourceTree)
  };
}

/***/ }),
/* 631 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _redux = __webpack_require__(517);

var _waitService = __webpack_require__(632);

var _log = __webpack_require__(633);

var _history = __webpack_require__(634);

var _promise = __webpack_require__(500);

var _thunk = __webpack_require__(636);

var _timing = __webpack_require__(637);

var _context = __webpack_require__(638);

/**
 * This creates a dispatcher with all the standard middleware in place
 * that all code requires. It can also be optionally configured in
 * various ways, such as logging and recording.
 *
 * @param {object} opts:
 *        - log: log all dispatched actions to console
 *        - history: an array to store every action in. Should only be
 *                   used in tests.
 *        - middleware: array of middleware to be included in the redux store
 * @memberof utils/create-store
 * @static
 */


/**
 * @memberof utils/create-store
 * @static
 */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/* global window */

/**
 * Redux store utils
 * @module utils/create-store
 */

const configureStore = (opts = {}) => {
  const middleware = [(0, _thunk.thunk)(opts.makeThunkArgs), _context.context, _promise.promise,

  // Order is important: services must go last as they always
  // operate on "already transformed" actions. Actions going through
  // them shouldn't have any special fields like promises, they
  // should just be normal JSON objects.
  _waitService.waitUntilService];

  if (opts.history) {
    middleware.push((0, _history.history)(opts.history));
  }

  if (opts.middleware) {
    opts.middleware.forEach(fn => middleware.push(fn));
  }

  if (opts.log) {
    middleware.push(_log.log);
  }

  if (opts.timing) {
    middleware.push(_timing.timing);
  }

  // Hook in the redux devtools browser extension if it exists
  const devtoolsExt = typeof window === "object" && window.devToolsExtension ? window.devToolsExtension() : f => f;

  return (0, _redux.applyMiddleware)(...middleware)(devtoolsExt(_redux.createStore));
};

exports.default = configureStore;

/***/ }),
/* 632 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.waitUntilService = waitUntilService;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/* global window */

/**
 * A middleware which acts like a service, because it is stateful
 * and "long-running" in the background. It provides the ability
 * for actions to install a function to be run once when a specific
 * condition is met by an action coming through the system. Think of
 * it as a thunk that blocks until the condition is met. Example:
 *
 * ```js
 * const services = { WAIT_UNTIL: require('wait-service').NAME };
 *
 * { type: services.WAIT_UNTIL,
 *   predicate: action => action.type === "ADD_ITEM",
 *   run: (dispatch, getState, action) => {
 *     // Do anything here. You only need to accept the arguments
 *     // if you need them. `action` is the action that satisfied
 *     // the predicate.
 *   }
 * }
 * ```
 */
const NAME = exports.NAME = "@@service/waitUntil";
function waitUntilService({ dispatch, getState }) {
  let pending = [];

  function checkPending(action) {
    const readyRequests = [];
    const stillPending = [];

    // Find the pending requests whose predicates are satisfied with
    // this action. Wait to run the requests until after we update the
    // pending queue because the request handler may synchronously
    // dispatch again and run this service (that use case is
    // completely valid).
    for (const request of pending) {
      if (request.predicate(action)) {
        readyRequests.push(request);
      } else {
        stillPending.push(request);
      }
    }

    pending = stillPending;
    for (const request of readyRequests) {
      request.run(dispatch, getState, action);
    }
  }

  return next => action => {
    if (action.type === NAME) {
      pending.push(action);
      return null;
    }
    const result = next(action);
    checkPending(action);
    return result;
  };
}

/***/ }),
/* 633 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.log = log;

var _devtoolsEnvironment = __webpack_require__(102);

var _prefs = __webpack_require__(492);

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */
/* global window */

const blacklist = ["ADD_BREAKPOINT_POSITIONS", "SET_SYMBOLS", "OUT_OF_SCOPE_LOCATIONS", "MAP_SCOPES", "MAP_FRAMES", "ADD_SCOPES", "IN_SCOPE_LINES", "REMOVE_BREAKPOINT", "NODE_PROPERTIES_LOADED", "SET_FOCUSED_SOURCE_ITEM", "NODE_EXPAND"];

function cloneAction(action) {
  action = action || {};
  action = { ...action };

  // ADD_TAB, ...
  if (action.source && action.source.text) {
    const source = { ...action.source, text: "" };
    action.source = source;
  }

  if (action.sources) {
    const sources = action.sources.slice(0, 20).map(source => {
      const url = !source.url || source.url.includes("data:") ? "" : source.url;
      return { ...source, url };
    });
    action.sources = sources;
  }

  // LOAD_SOURCE_TEXT
  if (action.text) {
    action.text = "";
  }

  if (action.value && action.value.text) {
    const value = { ...action.value, text: "" };
    action.value = value;
  }

  return action;
}

function formatFrame(frame) {
  const { id, location, displayName } = frame;
  return { id, location, displayName };
}

function formatPause(pause) {
  return {
    ...pause,
    pauseInfo: { why: pause.why },
    scopes: [],
    frames: pause.frames.map(formatFrame),
    loadedObjects: []
  };
}

function serializeAction(action) {
  try {
    action = cloneAction(action);
    if (blacklist.includes(action.type)) {
      action = {};
    }

    if (action.type === "PAUSED") {
      action = formatPause(action);
    }

    // dump(`> ${action.type}...\n ${JSON.stringify(action)}\n`);
    return JSON.stringify(action);
  } catch (e) {
    console.error(e);
    return "";
  }
}

/**
 * A middleware that logs all actions coming through the system
 * to the console.
 */
function log({ dispatch, getState }) {
  return next => action => {
    const asyncMsg = !action.status ? "" : `[${action.status}]`;

    if ((0, _devtoolsEnvironment.isTesting)() && _prefs.prefs.logActions) {
      // $FlowIgnore
      dump(`[ACTION] ${action.type} ${asyncMsg} - ${serializeAction(action)}\n`);
    } else {
      console.log(action, asyncMsg);
    }

    next(action);
  };
}

/***/ }),
/* 634 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.history = undefined;

var _devtoolsEnvironment = __webpack_require__(102);

/**
 * A middleware that stores every action coming through the store in the passed
 * in logging object. Should only be used for tests, as it collects all
 * action information, which will cause memory bloat.
 */
const history = exports.history = (log = []) => ({
  dispatch,
  getState
}) => {
  return next => action => {
    if ((0, _devtoolsEnvironment.isDevelopment)()) {
      log.push(action);
    }

    return next(action);
  };
}; /* This Source Code Form is subject to the terms of the Mozilla Public
    * License, v. 2.0. If a copy of the MPL was not distributed with this
    * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/* global window */

/***/ }),
/* 635 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.reportException = reportException;
exports.executeSoon = executeSoon;

var _assert = __webpack_require__(385);

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function reportException(who, exception) {
  const msg = `${who} threw an exception: `;
  console.error(msg, exception);
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function executeSoon(fn) {
  setTimeout(fn, 0);
}

exports.default = _assert2.default;

/***/ }),
/* 636 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.thunk = thunk;


/**
 * A middleware that allows thunks (functions) to be dispatched. If
 * it's a thunk, it is called with an argument that contains
 * `dispatch`, `getState`, and any additional args passed in via the
 * middleware constructure. This allows the action to create multiple
 * actions (most likely asynchronously).
 */
function thunk(makeArgs) {
  return ({ dispatch, getState }) => {
    const args = { dispatch, getState };

    return next => action => {
      return typeof action === "function" ? action(makeArgs ? makeArgs(args, getState()) : args) : next(action);
    };
  };
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/* global window */

/***/ }),
/* 637 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.timing = timing;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/* global window */

/**
 * Redux middleware that sets performance markers for all actions such that they
 * will appear in performance tooling under the User Timing API
 */

const mark = window.performance && window.performance.mark ? window.performance.mark.bind(window.performance) : a => {};

const measure = window.performance && window.performance.measure ? window.performance.measure.bind(window.performance) : (a, b, c) => {};

function timing(store) {
  return next => action => {
    mark(`${action.type}_start`);
    const result = next(action);
    mark(`${action.type}_end`);
    measure(`${action.type}`, `${action.type}_start`, `${action.type}_end`);
    return result;
  };
}

/***/ }),
/* 638 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.context = undefined;

var _context = __webpack_require__(568);

function validateActionContext(getState, action) {
  if (action.type == "COMMAND" && action.status == "done") {
    // The thread will have resumed execution since the action was initiated,
    // so just make sure we haven't navigated.
    (0, _context.validateNavigateContext)(getState(), action.cx);
    return;
  }

  // Validate using all available information in the context.
  (0, _context.validateContext)(getState(), action.cx);
}

// Middleware which looks for actions that have a cx property and ignores
// them if the context is no longer valid.
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function context({ dispatch, getState }) {
  return next => action => {
    if ("cx" in action) {
      validateActionContext(getState, action);
    }
    return next(action);
  };
}

exports.context = context;

/***/ }),
/* 639 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasResource = hasResource;
exports.getResourceIds = getResourceIds;
exports.getResource = getResource;
exports.getMappedResource = getMappedResource;

var _core = __webpack_require__(544);

function hasResource(state, id) {
  return !!(0, _core.getResourcePair)(state, id);
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function getResourceIds(state) {
  return Object.keys((0, _core.getResourceValues)(state));
}

function getResource(state, id) {
  const pair = (0, _core.getResourcePair)(state, id);
  if (!pair) {
    throw new Error(`Resource ${id} does not exist`);
  }
  return pair.value;
}

function getMappedResource(state, id, map) {
  const pair = (0, _core.getResourcePair)(state, id);
  if (!pair) {
    throw new Error(`Resource ${id} does not exist`);
  }

  return map(pair.value, pair.identity);
}

/***/ }),
/* 640 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.filterAllIds = filterAllIds;
exports.makeWeakQuery = makeWeakQuery;
exports.makeShallowQuery = makeShallowQuery;
exports.makeStrictQuery = makeStrictQuery;
exports.makeIdQuery = makeIdQuery;
exports.makeLoadQuery = makeLoadQuery;
exports.makeFilterQuery = makeFilterQuery;
exports.makeReduceQuery = makeReduceQuery;
exports.makeReduceAllQuery = makeReduceAllQuery;

var _baseQuery = __webpack_require__(571);

var _queryCache = __webpack_require__(572);

var _memoize = __webpack_require__(573);

var _compare = __webpack_require__(528);

function filterAllIds(values) {
  return Object.keys(values);
}

/**
 * Create a query function to take a list of IDs and map each Reduceding
 * resource object into a mapped form.
 */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function makeWeakQuery({
  filter,
  map,
  reduce
}) {
  return (0, _baseQuery.makeResourceQuery)({
    cache: _queryCache.queryCacheWeak,
    filter,
    map: (0, _memoize.memoizeResourceShallow)(map),
    reduce,
    resultCompare: _compare.shallowEqual
  });
}

/**
 * Create a query function to take a list of IDs and map each Reduceding
 * resource object into a mapped form.
 */
function makeShallowQuery({
  filter,
  map,
  reduce
}) {
  return (0, _baseQuery.makeResourceQuery)({
    cache: _queryCache.queryCacheShallow,
    filter,
    map: (0, _memoize.memoizeResourceShallow)(map),
    reduce,
    resultCompare: _compare.shallowEqual
  });
}

/**
 * Create a query function to take a list of IDs and map each Reduceding
 * resource object into a mapped form.
 */
function makeStrictQuery({
  filter,
  map,
  reduce
}) {
  return (0, _baseQuery.makeResourceQuery)({
    cache: _queryCache.queryCacheStrict,
    filter,
    map: (0, _memoize.memoizeResourceShallow)(map),
    reduce,
    resultCompare: _compare.shallowEqual
  });
}

/**
 * Create a query function to take a list of IDs and map each Reduceding
 * resource object into a mapped form.
 */
function makeIdQuery(map) {
  return makeWeakQuery({
    filter: (state, ids) => ids,
    map: (r, identity) => map(r, identity),
    reduce: items => items.slice()
  });
}

/**
 * Create a query function to take a list of IDs and map each Reduceding
 * resource object into a mapped form.
 */
function makeLoadQuery(map) {
  return makeWeakQuery({
    filter: (state, ids) => ids,
    map: (r, identity) => map(r, identity),
    reduce: reduceMappedArrayToObject
  });
}

/**
 * Create a query function that accepts an argument and can filter the
 * resource items to a subset before mapping each reduced resource.
 */
function makeFilterQuery(filter, map) {
  return makeWeakQuery({
    filter: (values, args) => {
      const ids = [];
      for (const id of Object.keys(values)) {
        if (filter(values[id], args)) {
          ids.push(id);
        }
      }
      return ids;
    },
    map,
    reduce: reduceMappedArrayToObject
  });
}

/**
 * Create a query function that accepts an argument and can filter the
 * resource items to a subset before mapping each resulting resource.
 */
function makeReduceQuery(map, reduce) {
  return makeShallowQuery({
    filter: filterAllIds,
    map,
    reduce
  });
}

/**
 * Create a query function that accepts an argument and can filter the
 * resource items to a subset before mapping each resulting resource.
 */
function makeReduceAllQuery(map, reduce) {
  return makeStrictQuery({
    filter: filterAllIds,
    map,
    reduce
  });
}

function reduceMappedArrayToObject(items, ids, args) {
  return items.reduce((acc, item, i) => {
    acc[ids[i]] = item;
    return acc;
  }, {});
}

/***/ }),
/* 641 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getASTLocation = getASTLocation;
exports.findFunctionByName = findFunctionByName;

var _ast = __webpack_require__(519);

function getASTLocation(source, symbols, location) {
  if (source.isWasm || !symbols || symbols.loading) {
    return { name: undefined, offset: location, index: 0 };
  }

  const scope = (0, _ast.findClosestFunction)(symbols, location);
  if (scope) {
    // we only record the line, but at some point we may
    // also do column offsets
    const line = location.line - scope.location.start.line;
    return {
      name: scope.name,
      offset: { line, column: undefined },
      index: scope.index
    };
  }
  return { name: undefined, offset: location, index: 0 };
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function findFunctionByName(symbols, name, index) {
  if (symbols.loading) {
    return null;
  }

  const functions = symbols.functions;
  return functions.find(node => node.name === name && node.index === index);
}

/***/ }),
/* 642 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getBreakpointAtLocation = getBreakpointAtLocation;
exports.getBreakpointsAtLine = getBreakpointsAtLine;

var _sources = __webpack_require__(498);

var _breakpoints = __webpack_require__(518);

var _source = __webpack_require__(494);

function getColumn(column, selectedSource) {
  if (column) {
    return column;
  }

  return (0, _source.isGenerated)(selectedSource) ? undefined : 0;
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function getLocation(bp, selectedSource) {
  return (0, _source.isGenerated)(selectedSource) ? bp.generatedLocation || bp.location : bp.location;
}

function getBreakpointsForSource(state, selectedSource) {
  const breakpoints = (0, _breakpoints.getBreakpointsList)(state);

  return breakpoints.filter(bp => {
    const location = getLocation(bp, selectedSource);
    return location.sourceId === selectedSource.id;
  });
}

function findBreakpointAtLocation(breakpoints, selectedSource, { line, column }) {
  return breakpoints.find(breakpoint => {
    const location = getLocation(breakpoint, selectedSource);
    const sameLine = location.line === line;
    if (!sameLine) {
      return false;
    }

    if (column === undefined) {
      return true;
    }

    return location.column === getColumn(column, selectedSource);
  });
}

/*
 * Finds a breakpoint at a location (line, column) of the
 * selected source.
 *
 * This is useful for finding a breakpoint when the
 * user clicks in the gutter or on a token.
 */
function getBreakpointAtLocation(state, location) {
  const selectedSource = (0, _sources.getSelectedSource)(state);
  if (!selectedSource) {
    throw new Error("no selectedSource");
  }
  const breakpoints = getBreakpointsForSource(state, selectedSource);

  return findBreakpointAtLocation(breakpoints, selectedSource, location);
}

function getBreakpointsAtLine(state, line) {
  const selectedSource = (0, _sources.getSelectedSource)(state);
  if (!selectedSource) {
    throw new Error("no selectedSource");
  }
  const breakpoints = getBreakpointsForSource(state, selectedSource);

  return breakpoints.filter(breakpoint => getLocation(breakpoint, selectedSource).line === line);
}

/***/ }),
/* 643 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.inComponent = inComponent;

var _ = __webpack_require__(490);

var _ast = __webpack_require__(519);

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function inComponent(state) {
  const thread = (0, _.getCurrentThread)(state);
  const selectedFrame = (0, _.getSelectedFrame)(state, thread);
  if (!selectedFrame) {
    return;
  }

  const source = (0, _.getSource)(state, selectedFrame.location.sourceId);
  if (!source) {
    return;
  }

  const symbols = (0, _.getSymbols)(state, source);

  if (!symbols || symbols.loading) {
    return;
  }

  const closestClass = (0, _ast.findClosestClass)(symbols, selectedFrame.location);
  if (!closestClass) {
    return null;
  }

  const inReactFile = symbols.framework == "React";
  const { parent } = closestClass;
  const isComponent = parent && parent.name.includes("Component");

  if (inReactFile && isComponent) {
    return closestClass.name;
  }
}

/***/ }),
/* 644 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isSelectedFrameVisible = isSelectedFrameVisible;

var _devtoolsSourceMap = __webpack_require__(182);

var _ = __webpack_require__(490);

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function getGeneratedId(sourceId) {
  if ((0, _devtoolsSourceMap.isOriginalId)(sourceId)) {
    return (0, _devtoolsSourceMap.originalToGeneratedId)(sourceId);
  }

  return sourceId;
}

/*
 * Checks to if the selected frame's source is currently
 * selected.
 */
function isSelectedFrameVisible(state) {
  const thread = (0, _.getCurrentThread)(state);
  const selectedLocation = (0, _.getSelectedLocation)(state);
  const selectedFrame = (0, _.getSelectedFrame)(state, thread);

  if (!selectedFrame || !selectedLocation) {
    return false;
  }

  if ((0, _devtoolsSourceMap.isOriginalId)(selectedLocation.sourceId)) {
    return selectedLocation.sourceId === selectedFrame.location.sourceId;
  }

  return selectedLocation.sourceId === getGeneratedId(selectedFrame.location.sourceId);
}

/***/ }),
/* 645 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCallStackFrames = undefined;
exports.formatCallStackFrames = formatCallStackFrames;

var _sources = __webpack_require__(498);

var _pause = __webpack_require__(530);

var _frames = __webpack_require__(510);

var _source = __webpack_require__(494);

var _lodash = __webpack_require__(417);

var _reselect = __webpack_require__(444);

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function getLocation(frame, isGeneratedSource) {
  return isGeneratedSource ? frame.generatedLocation || frame.location : frame.location;
}

function getSourceForFrame(sources, frame, isGeneratedSource) {
  const sourceId = getLocation(frame, isGeneratedSource).sourceId;
  return (0, _sources.getSourceInSources)(sources, sourceId);
}

function appendSource(sources, frame, selectedSource) {
  const isGeneratedSource = selectedSource && !(0, _source.isOriginal)(selectedSource);
  return {
    ...frame,
    location: getLocation(frame, isGeneratedSource),
    source: getSourceForFrame(sources, frame, isGeneratedSource)
  };
}

function formatCallStackFrames(frames, sources, selectedSource) {
  if (!frames) {
    return null;
  }

  const formattedFrames = frames.filter(frame => getSourceForFrame(sources, frame)).map(frame => appendSource(sources, frame, selectedSource)).filter(frame => !(0, _lodash.get)(frame, "source.isBlackBoxed"));

  return (0, _frames.annotateFrames)(formattedFrames);
}

// eslint-disable-next-line
const getCallStackFrames = exports.getCallStackFrames = (0, _reselect.createSelector)(_pause.getCurrentThreadFrames, _sources.getSources, _sources.getSelectedSource, formatCallStackFrames);

/***/ }),
/* 646 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.annotateFrames = annotateFrames;

var _lodash = __webpack_require__(417);

var _getFrameUrl = __webpack_require__(533);

var _getLibraryFromUrl = __webpack_require__(588);

function annotateFrames(frames) {
  const annotatedFrames = frames.map(f => annotateFrame(f, frames));
  return annotateBabelAsyncFrames(annotatedFrames);
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function annotateFrame(frame, frames) {
  const library = (0, _getLibraryFromUrl.getLibraryFromUrl)(frame, frames);
  if (library) {
    return { ...frame, library };
  }

  return frame;
}

function annotateBabelAsyncFrames(frames) {
  const babelFrameIndexes = getBabelFrameIndexes(frames);
  const isBabelFrame = frameIndex => babelFrameIndexes.includes(frameIndex);

  return frames.map((frame, frameIndex) => isBabelFrame(frameIndex) ? { ...frame, library: "Babel" } : frame);
}

// Receives an array of frames and looks for babel async
// call stack groups.
function getBabelFrameIndexes(frames) {
  const startIndexes = frames.reduce((accumulator, frame, index) => {
    if ((0, _getFrameUrl.getFrameUrl)(frame).match(/regenerator-runtime/i) && frame.displayName === "tryCatch") {
      return [...accumulator, index];
    }
    return accumulator;
  }, []);

  const endIndexes = frames.reduce((accumulator, frame, index) => {
    if ((0, _getFrameUrl.getFrameUrl)(frame).match(/_microtask/i) && frame.displayName === "flush") {
      return [...accumulator, index];
    }
    if (frame.displayName === "_asyncToGenerator/<") {
      return [...accumulator, index + 1];
    }
    return accumulator;
  }, []);

  if (startIndexes.length != endIndexes.length || startIndexes.length === 0) {
    return frames;
  }

  // Receives an array of start and end index tuples and returns
  // an array of async call stack index ranges.
  // e.g. [[1,3], [5,7]] => [[1,2,3], [5,6,7]]
  // $FlowIgnore
  return (0, _lodash.flatMap)((0, _lodash.zip)(startIndexes, endIndexes), ([startIndex, endIndex]) => (0, _lodash.range)(startIndex, endIndex + 1));
}

/***/ }),
/* 647 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.collapseFrames = collapseFrames;

var _lodash = __webpack_require__(417);

var _getFrameUrl = __webpack_require__(533);

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function collapseLastFrames(frames) {
  const index = (0, _lodash.findIndex)(frames, frame => (0, _getFrameUrl.getFrameUrl)(frame).match(/webpack\/bootstrap/i));

  if (index == -1) {
    return { newFrames: frames, lastGroup: [] };
  }

  const newFrames = frames.slice(0, index);
  const lastGroup = frames.slice(index);
  return { newFrames, lastGroup };
}

// eslint-disable-next-line max-len
function collapseFrames(frames) {
  // We collapse groups of one so that user frames
  // are not in a group of one
  function addGroupToList(group, list) {
    if (!group) {
      return list;
    }

    if (group.length > 1) {
      list.push(group);
    } else {
      list = list.concat(group);
    }

    return list;
  }
  const { newFrames, lastGroup } = collapseLastFrames(frames);
  frames = newFrames;
  let items = [];
  let currentGroup = null;
  let prevItem = null;
  for (const frame of frames) {
    const prevLibrary = (0, _lodash.get)(prevItem, "library");

    if (!currentGroup) {
      currentGroup = [frame];
    } else if (prevLibrary && prevLibrary == frame.library) {
      currentGroup.push(frame);
    } else {
      items = addGroupToList(currentGroup, items);
      currentGroup = [frame];
    }

    prevItem = frame;
  }

  items = addGroupToList(currentGroup, items);
  items = addGroupToList(lastGroup, items);
  return items;
}

/***/ }),
/* 648 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.simplifyDisplayName = simplifyDisplayName;
exports.formatDisplayName = formatDisplayName;
exports.formatCopyName = formatCopyName;

var _source = __webpack_require__(494);

// Decodes an anonymous naming scheme that
// spider monkey implements based on "Naming Anonymous JavaScript Functions"
// http://johnjbarton.github.io/nonymous/index.html
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// eslint-disable-next-line max-len
const objectProperty = /([\w\d\$]+)$/;
const arrayProperty = /\[(.*?)\]$/;
const functionProperty = /([\w\d]+)[\/\.<]*?$/;
const annonymousProperty = /([\w\d]+)\(\^\)$/;

function simplifyDisplayName(displayName) {
  // if the display name has a space it has already been mapped
  if (!displayName || /\s/.exec(displayName)) {
    return displayName;
  }

  const scenarios = [objectProperty, arrayProperty, functionProperty, annonymousProperty];

  for (const reg of scenarios) {
    const match = reg.exec(displayName);
    if (match) {
      return match[1];
    }
  }

  return displayName;
}

const displayNameMap = {
  Babel: {
    tryCatch: "Async"
  },
  Backbone: {
    "extend/child": "Create Class",
    ".create": "Create Model"
  },
  jQuery: {
    "jQuery.event.dispatch": "Dispatch Event"
  },
  React: {
    // eslint-disable-next-line max-len
    "ReactCompositeComponent._renderValidatedComponentWithoutOwnerOrContext/renderedElement<": "Render",
    _renderValidatedComponentWithoutOwnerOrContext: "Render"
  },
  VueJS: {
    "renderMixin/Vue.prototype._render": "Render"
  },
  Webpack: {
    // eslint-disable-next-line camelcase
    __webpack_require__: "Bootstrap"
  }
};

function mapDisplayNames(frame, library) {
  const { displayName } = frame;
  return displayNameMap[library] && displayNameMap[library][displayName] || displayName;
}

function getFrameDisplayName(frame) {
  const {
    displayName,
    originalDisplayName,
    userDisplayName,
    name
  } = frame;
  return originalDisplayName || userDisplayName || displayName || name;
}

function formatDisplayName(frame, { shouldMapDisplayName = true } = {}, l10n) {
  const { library } = frame;
  let displayName = getFrameDisplayName(frame);
  if (library && shouldMapDisplayName) {
    displayName = mapDisplayNames(frame, library);
  }

  return simplifyDisplayName(displayName) || l10n.getStr("anonymousFunction");
}

function formatCopyName(frame, l10n) {
  const displayName = formatDisplayName(frame, undefined, l10n);
  if (!frame.source) {
    throw new Error("no frame source");
  }
  const fileName = (0, _source.getFilename)(frame.source);
  const frameLocation = frame.location.line;

  return `${displayName} (${fileName}#${frameLocation})`;
}

/***/ }),
/* 649 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getBreakpointSources = undefined;

var _lodash = __webpack_require__(417);

var _reselect = __webpack_require__(444);

var _selectors = __webpack_require__(490);

var _source = __webpack_require__(494);

var _selectedLocation = __webpack_require__(501);

var _breakpoint = __webpack_require__(499);

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function getBreakpointsForSource(source, selectedSource, breakpoints) {
  return (0, _breakpoint.sortSelectedBreakpoints)(breakpoints, selectedSource).filter(bp => !bp.options.hidden && (bp.text || bp.originalText || bp.options.condition || bp.disabled)).filter(bp => (0, _selectedLocation.getSelectedLocation)(bp, selectedSource).sourceId == source.id);
}

function findBreakpointSources(sources, breakpoints, selectedSource) {
  const sourceIds = (0, _lodash.uniq)(breakpoints.map(bp => (0, _selectedLocation.getSelectedLocation)(bp, selectedSource).sourceId));

  const breakpointSources = sourceIds.reduce((acc, id) => {
    const source = (0, _selectors.getSourceInSources)(sources, id);
    if (source && !source.isBlackBoxed) {
      acc.push(source);
    }
    return acc;
  }, []);

  return (0, _lodash.sortBy)(breakpointSources, source => (0, _source.getFilename)(source));
}

const getBreakpointSources = exports.getBreakpointSources = (0, _reselect.createSelector)(_selectors.getBreakpointsList, _selectors.getSources, _selectors.getSelectedSource, (breakpoints, sources, selectedSource) => findBreakpointSources(sources, breakpoints, selectedSource).map(source => ({
  source,
  breakpoints: getBreakpointsForSource(source, selectedSource, breakpoints)
})).filter(({ breakpoints: bpSources }) => bpSources.length > 0));

/***/ }),
/* 650 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.visibleColumnBreakpoints = undefined;
exports.getColumnBreakpoints = getColumnBreakpoints;
exports.getFirstBreakpointPosition = getFirstBreakpointPosition;

var _lodash = __webpack_require__(417);

var _reselect = __webpack_require__(444);

var _selectors = __webpack_require__(490);

var _visibleBreakpoints = __webpack_require__(587);

var _selectedLocation = __webpack_require__(501);

var _location = __webpack_require__(509);

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */
function contains(location, range) {
  return location.line >= range.start.line && location.line <= range.end.line && (!location.column || location.column >= range.start.column && location.column <= range.end.column);
}

function groupBreakpoints(breakpoints, selectedSource) {
  if (!breakpoints) {
    return {};
  }

  const map = (0, _lodash.groupBy)(breakpoints.filter(breakpoint => !breakpoint.options.hidden), breakpoint => (0, _selectedLocation.getSelectedLocation)(breakpoint, selectedSource).line);

  for (const line in map) {
    map[line] = (0, _lodash.groupBy)(map[line], breakpoint => (0, _selectedLocation.getSelectedLocation)(breakpoint, selectedSource).column);
  }

  return map;
}

function findBreakpoint(location, breakpointMap) {
  const { line, column } = location;
  const breakpoints = breakpointMap[line] && breakpointMap[line][column];

  if (breakpoints) {
    return breakpoints[0];
  }
}

function filterByLineCount(positions, selectedSource) {
  const lineCount = {};

  for (const breakpoint of positions) {
    const { line } = (0, _selectedLocation.getSelectedLocation)(breakpoint, selectedSource);
    if (!lineCount[line]) {
      lineCount[line] = 0;
    }

    lineCount[line] = lineCount[line] + 1;
  }

  return positions.filter(breakpoint => lineCount[(0, _selectedLocation.getSelectedLocation)(breakpoint, selectedSource).line] > 1);
}

function filterVisible(positions, selectedSource, viewport) {
  return positions.filter(columnBreakpoint => {
    const location = (0, _selectedLocation.getSelectedLocation)(columnBreakpoint, selectedSource);
    return viewport && contains(location, viewport);
  });
}

function filterByBreakpoints(positions, selectedSource, breakpointMap) {
  return positions.filter(position => {
    const location = (0, _selectedLocation.getSelectedLocation)(position, selectedSource);
    return breakpointMap[location.line];
  });
}

function formatPositions(positions, selectedSource, breakpointMap) {
  return positions.map(position => {
    const location = (0, _selectedLocation.getSelectedLocation)(position, selectedSource);
    return {
      location,
      breakpoint: findBreakpoint(location, breakpointMap)
    };
  });
}

function convertToList(breakpointPositions) {
  return [].concat(...Object.values(breakpointPositions));
}

function getColumnBreakpoints(positions, breakpoints, viewport, selectedSource) {
  if (!positions) {
    return [];
  }

  // We only want to show a column breakpoint if several conditions are matched
  // - it is the first breakpoint to appear at an the original location
  // - the position is in the current viewport
  // - there is atleast one other breakpoint on that line
  // - there is a breakpoint on that line
  const breakpointMap = groupBreakpoints(breakpoints, selectedSource);
  let newPositions = convertToList(positions);
  newPositions = filterByLineCount(newPositions, selectedSource);
  newPositions = filterVisible(newPositions, selectedSource, viewport);
  newPositions = filterByBreakpoints(newPositions, selectedSource, breakpointMap);

  return formatPositions(newPositions, selectedSource, breakpointMap);
}

const getVisibleBreakpointPositions = (0, _reselect.createSelector)(_selectors.getSelectedSource, _selectors.getBreakpointPositions, (source, positions) => source && positions[source.id]);

const visibleColumnBreakpoints = exports.visibleColumnBreakpoints = (0, _reselect.createSelector)(getVisibleBreakpointPositions, _visibleBreakpoints.getVisibleBreakpoints, _selectors.getViewport, _selectors.getSelectedSource, getColumnBreakpoints);

function getFirstBreakpointPosition(state, { line, sourceId }) {
  const positions = (0, _selectors.getBreakpointPositionsForSource)(state, sourceId);
  const source = (0, _selectors.getSource)(state, sourceId);

  if (!source || !positions) {
    return;
  }

  return (0, _location.sortSelectedLocations)(convertToList(positions), source).find(position => (0, _selectedLocation.getSelectedLocation)(position, source).line == line);
}

/***/ }),
/* 651 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _expressions = __webpack_require__(569);

var _expressions2 = _interopRequireDefault(_expressions);

var _sourceActors = __webpack_require__(529);

var _sourceActors2 = _interopRequireDefault(_sourceActors);

var _sources = __webpack_require__(498);

var _sources2 = _interopRequireDefault(_sources);

var _tabs = __webpack_require__(545);

var _tabs2 = _interopRequireDefault(_tabs);

var _breakpoints = __webpack_require__(518);

var _breakpoints2 = _interopRequireDefault(_breakpoints);

var _pendingBreakpoints = __webpack_require__(580);

var _pendingBreakpoints2 = _interopRequireDefault(_pendingBreakpoints);

var _asyncRequests = __webpack_require__(652);

var _asyncRequests2 = _interopRequireDefault(_asyncRequests);

var _pause = __webpack_require__(530);

var _pause2 = _interopRequireDefault(_pause);

var _ui = __webpack_require__(581);

var _ui2 = _interopRequireDefault(_ui);

var _fileSearch = __webpack_require__(582);

var _fileSearch2 = _interopRequireDefault(_fileSearch);

var _ast = __webpack_require__(583);

var _ast2 = _interopRequireDefault(_ast);

var _projectTextSearch = __webpack_require__(532);

var _projectTextSearch2 = _interopRequireDefault(_projectTextSearch);

var _quickOpen = __webpack_require__(585);

var _quickOpen2 = _interopRequireDefault(_quickOpen);

var _sourceTree = __webpack_require__(584);

var _sourceTree2 = _interopRequireDefault(_sourceTree);

var _debuggee = __webpack_require__(577);

var _debuggee2 = _interopRequireDefault(_debuggee);

var _eventListeners = __webpack_require__(575);

var _eventListeners2 = _interopRequireDefault(_eventListeners);

var _devtoolsReps = __webpack_require__(457);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  expressions: _expressions2.default,
  sourceActors: _sourceActors2.default,
  sources: _sources2.default,
  tabs: _tabs2.default,
  breakpoints: _breakpoints2.default,
  pendingBreakpoints: _pendingBreakpoints2.default,
  asyncRequests: _asyncRequests2.default,
  pause: _pause2.default,
  ui: _ui2.default,
  fileSearch: _fileSearch2.default,
  ast: _ast2.default,
  projectTextSearch: _projectTextSearch2.default,
  quickOpen: _quickOpen2.default,
  sourceTree: _sourceTree2.default,
  debuggee: _debuggee2.default,
  objectInspector: _devtoolsReps.objectInspector.reducer.default,
  eventListenerBreakpoints: _eventListeners2.default
};

// eslint-disable-next-line import/named
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/**
 * Reducer index
 * @module reducers/index
 */

/***/ }),
/* 652 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/**
 * Async request reducer
 * @module reducers/async-request
 */

const initialAsyncRequestState = [];

function update(state = initialAsyncRequestState, action) {
  const { seqId } = action;

  if (action.type === "NAVIGATE") {
    return initialAsyncRequestState;
  } else if (seqId) {
    let newState;
    if (action.status === "start") {
      newState = [...state, seqId];
    } else if (action.status === "error" || action.status === "done") {
      newState = state.filter(id => id !== seqId);
    }

    return newState;
  }

  return state;
}

exports.default = update;

/***/ }),
/* 653 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(67);

var _classnames2 = _interopRequireDefault(_classnames);

var _connect = __webpack_require__(491);

var _prefs = __webpack_require__(492);

var _actions = __webpack_require__(493);

var _actions2 = _interopRequireDefault(_actions);

var _A11yIntention = __webpack_require__(683);

var _A11yIntention2 = _interopRequireDefault(_A11yIntention);

var _ShortcutsModal = __webpack_require__(685);

var _selectors = __webpack_require__(490);

var _devtoolsModules = __webpack_require__(183);

var _devtoolsServices = __webpack_require__(37);

var _devtoolsServices2 = _interopRequireDefault(_devtoolsServices);

__webpack_require__(688);

__webpack_require__(689);

__webpack_require__(690);

__webpack_require__(691);

__webpack_require__(692);

var _devtoolsSplitter = __webpack_require__(445);

var _devtoolsSplitter2 = _interopRequireDefault(_devtoolsSplitter);

var _ProjectSearch = __webpack_require__(693);

var _ProjectSearch2 = _interopRequireDefault(_ProjectSearch);

var _PrimaryPanes = __webpack_require__(704);

var _PrimaryPanes2 = _interopRequireDefault(_PrimaryPanes);

var _Editor = __webpack_require__(715);

var _Editor2 = _interopRequireDefault(_Editor);

var _SecondaryPanes = __webpack_require__(739);

var _SecondaryPanes2 = _interopRequireDefault(_SecondaryPanes);

var _WelcomeBox = __webpack_require__(772);

var _WelcomeBox2 = _interopRequireDefault(_WelcomeBox);

var _Tabs = __webpack_require__(774);

var _Tabs2 = _interopRequireDefault(_Tabs);

var _Footer = __webpack_require__(779);

var _Footer2 = _interopRequireDefault(_Footer);

var _QuickOpenModal = __webpack_require__(781);

var _QuickOpenModal2 = _interopRequireDefault(_QuickOpenModal);

var _WhyPaused = __webpack_require__(610);

var _WhyPaused2 = _interopRequireDefault(_WhyPaused);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const shortcuts = new _devtoolsModules.KeyShortcuts({ window }); /* This Source Code Form is subject to the terms of the Mozilla Public
                                                                  * License, v. 2.0. If a copy of the MPL was not distributed with this
                                                                  * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const { appinfo } = _devtoolsServices2.default;

const isMacOS = appinfo.OS === "Darwin";

const horizontalLayoutBreakpoint = window.matchMedia("(min-width: 800px)");
const verticalLayoutBreakpoint = window.matchMedia("(min-width: 10px) and (max-width: 799px)");

// $FlowIgnore


class App extends _react.Component {

  constructor(props) {
    super(props);

    this.getChildContext = () => {
      return { shortcuts, l10n: L10N };
    };

    this.onEscape = (_, e) => {
      const {
        activeSearch,
        closeActiveSearch,
        closeQuickOpen,
        quickOpenEnabled
      } = this.props;
      const { shortcutsModalEnabled } = this.state;

      if (activeSearch) {
        e.preventDefault();
        closeActiveSearch();
      }

      if (quickOpenEnabled) {
        e.preventDefault();
        closeQuickOpen();
      }

      if (shortcutsModalEnabled) {
        this.toggleShortcutsModal();
      }
    };

    this.onCommandSlash = () => {
      this.toggleShortcutsModal();
    };

    this.toggleQuickOpenModal = (_, e, query) => {
      const { quickOpenEnabled, openQuickOpen, closeQuickOpen } = this.props;

      e.preventDefault();
      e.stopPropagation();

      if (quickOpenEnabled === true) {
        closeQuickOpen();
        return;
      }

      if (query != null) {
        openQuickOpen(query);
        return;
      }
      openQuickOpen();
    };

    this.onLayoutChange = () => {
      this.setOrientation();
    };

    this.renderEditorPane = () => {
      const { startPanelCollapsed, endPanelCollapsed } = this.props;
      const { endPanelSize, startPanelSize } = this.state;
      const horizontal = this.isHorizontal();

      return _react2.default.createElement(
        "div",
        { className: "editor-pane" },
        _react2.default.createElement(
          "div",
          { className: "editor-container" },
          _react2.default.createElement(_Tabs2.default, {
            startPanelCollapsed: startPanelCollapsed,
            endPanelCollapsed: endPanelCollapsed,
            horizontal: horizontal,
            startPanelSize: startPanelSize,
            endPanelSize: endPanelSize
          }),
          _react2.default.createElement(_Editor2.default, {
            horizontal: horizontal,
            startPanelSize: startPanelSize,
            endPanelSize: endPanelSize
          }),
          this.props.endPanelCollapsed ? _react2.default.createElement(_WhyPaused2.default, { horizontal: horizontal }) : null,
          !this.props.selectedSource ? _react2.default.createElement(_WelcomeBox2.default, {
            horizontal: horizontal,
            toggleShortcutsModal: () => this.toggleShortcutsModal()
          }) : null,
          _react2.default.createElement(_Footer2.default, { horizontal: horizontal }),
          _react2.default.createElement(_ProjectSearch2.default, null)
        )
      );
    };

    this.renderLayout = () => {
      const { startPanelCollapsed, endPanelCollapsed } = this.props;
      const horizontal = this.isHorizontal();

      const maxSize = horizontal ? "70%" : "95%";

      return _react2.default.createElement(_devtoolsSplitter2.default, {
        style: { width: "100vw" },
        initialSize: _prefs.prefs.endPanelSize,
        minSize: 30,
        maxSize: maxSize,
        splitterSize: 1,
        vert: horizontal,
        onResizeEnd: num => {
          _prefs.prefs.endPanelSize = num;
          this.triggerEditorPaneResize();
        },
        startPanel: _react2.default.createElement(_devtoolsSplitter2.default, {
          style: { width: "100vw" },
          initialSize: _prefs.prefs.startPanelSize,
          minSize: 30,
          maxSize: "85%",
          splitterSize: 1,
          onResizeEnd: num => {
            _prefs.prefs.startPanelSize = num;
          },
          startPanelCollapsed: startPanelCollapsed,
          startPanel: _react2.default.createElement(_PrimaryPanes2.default, { horizontal: horizontal }),
          endPanel: this.renderEditorPane()
        }),
        endPanelControl: true,
        endPanel: _react2.default.createElement(_SecondaryPanes2.default, {
          horizontal: horizontal,
          toggleShortcutsModal: () => this.toggleShortcutsModal()
        }),
        endPanelCollapsed: endPanelCollapsed
      });
    };

    this.state = {
      shortcutsModalEnabled: false,
      startPanelSize: 0,
      endPanelSize: 0
    };
  }

  componentDidMount() {
    horizontalLayoutBreakpoint.addListener(this.onLayoutChange);
    verticalLayoutBreakpoint.addListener(this.onLayoutChange);
    this.setOrientation();

    shortcuts.on(L10N.getStr("symbolSearch.search.key2"), (_, e) => this.toggleQuickOpenModal(_, e, "@"));

    const searchKeys = [L10N.getStr("sources.search.key2"), L10N.getStr("sources.search.alt.key")];
    searchKeys.forEach(key => shortcuts.on(key, this.toggleQuickOpenModal));

    shortcuts.on(L10N.getStr("gotoLineModal.key2"), (_, e) => this.toggleQuickOpenModal(_, e, ":"));

    shortcuts.on("Escape", this.onEscape);
    shortcuts.on("Cmd+/", this.onCommandSlash);
  }

  componentWillUnmount() {
    horizontalLayoutBreakpoint.removeListener(this.onLayoutChange);
    verticalLayoutBreakpoint.removeListener(this.onLayoutChange);
    shortcuts.off(L10N.getStr("symbolSearch.search.key2"), this.toggleQuickOpenModal);

    const searchKeys = [L10N.getStr("sources.search.key2"), L10N.getStr("sources.search.alt.key")];
    searchKeys.forEach(key => shortcuts.off(key, this.toggleQuickOpenModal));

    shortcuts.off(L10N.getStr("gotoLineModal.key2"), this.toggleQuickOpenModal);

    shortcuts.off("Escape", this.onEscape);
  }

  isHorizontal() {
    return this.props.orientation === "horizontal";
  }

  setOrientation() {
    // If the orientation does not match (if it is not visible) it will
    // not setOrientation, or if it is the same as before, calling
    // setOrientation will not cause a rerender.
    if (horizontalLayoutBreakpoint.matches) {
      this.props.setOrientation("horizontal");
    } else if (verticalLayoutBreakpoint.matches) {
      this.props.setOrientation("vertical");
    }
  }

  toggleShortcutsModal() {
    this.setState(prevState => ({
      shortcutsModalEnabled: !prevState.shortcutsModalEnabled
    }));
  }

  // Important so that the tabs chevron updates appropriately when
  // the user resizes the left or right columns
  triggerEditorPaneResize() {
    const editorPane = window.document.querySelector(".editor-pane");
    if (editorPane) {
      editorPane.dispatchEvent(new Event("resizeend"));
    }
  }

  renderShortcutsModal() {
    const additionalClass = isMacOS ? "mac" : "";

    if (!_prefs.features.shortcuts) {
      return;
    }

    return _react2.default.createElement(_ShortcutsModal.ShortcutsModal, {
      additionalClass: additionalClass,
      enabled: this.state.shortcutsModalEnabled,
      handleClose: () => this.toggleShortcutsModal()
    });
  }

  render() {
    const { quickOpenEnabled, canRewind } = this.props;
    return _react2.default.createElement(
      "div",
      { className: (0, _classnames2.default)("debugger", { "can-rewind": canRewind }) },
      _react2.default.createElement(
        _A11yIntention2.default,
        null,
        this.renderLayout(),
        quickOpenEnabled === true && _react2.default.createElement(_QuickOpenModal2.default, {
          shortcutsModalEnabled: this.state.shortcutsModalEnabled,
          toggleShortcutsModal: () => this.toggleShortcutsModal()
        }),
        this.renderShortcutsModal()
      )
    );
  }
}

App.childContextTypes = {
  shortcuts: _propTypes2.default.object,
  l10n: _propTypes2.default.object
};

const mapStateToProps = state => ({
  canRewind: (0, _selectors.getCanRewind)(state),
  selectedSource: (0, _selectors.getSelectedSource)(state),
  startPanelCollapsed: (0, _selectors.getPaneCollapse)(state, "start"),
  endPanelCollapsed: (0, _selectors.getPaneCollapse)(state, "end"),
  activeSearch: (0, _selectors.getActiveSearch)(state),
  quickOpenEnabled: (0, _selectors.getQuickOpenEnabled)(state),
  orientation: (0, _selectors.getOrientation)(state)
});

exports.default = (0, _connect.connect)(mapStateToProps, {
  setActiveSearch: _actions2.default.setActiveSearch,
  closeActiveSearch: _actions2.default.closeActiveSearch,
  closeProjectSearch: _actions2.default.closeProjectSearch,
  openQuickOpen: _actions2.default.openQuickOpen,
  closeQuickOpen: _actions2.default.closeQuickOpen,
  setOrientation: _actions2.default.setOrientation
})(App);

/***/ }),
/* 654 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.enableBreakpoint = enableBreakpoint;
exports.addBreakpoint = addBreakpoint;
exports.removeBreakpoint = removeBreakpoint;
exports.removeBreakpointAtGeneratedLocation = removeBreakpointAtGeneratedLocation;
exports.disableBreakpoint = disableBreakpoint;
exports.setBreakpointOptions = setBreakpointOptions;

var _breakpoint = __webpack_require__(499);

var _selectors = __webpack_require__(490);

var _breakpointPositions = __webpack_require__(534);

var _telemetry = __webpack_require__(520);

var _location = __webpack_require__(509);

var _source = __webpack_require__(494);

// This file has the primitive operations used to modify individual breakpoints
// and keep them in sync with the breakpoints installed on server threads. These
// are collected here to make it easier to preserve the following invariant:
//
// Breakpoints are included in reducer state iff they are disabled or requests
// have been dispatched to set them in all server threads.
//
// To maintain this property, updates to the reducer and installed breakpoints
// must happen with no intervening await. Using await allows other operations to
// modify the breakpoint state in the interim and potentially cause breakpoint
// state to go out of sync.
//
// The reducer is optimistically updated when users set or remove a breakpoint,
// but it might take a little while before the breakpoints have been set or
// removed in each thread. Once all outstanding requests sent to a thread have
// been processed, the reducer and server threads will be in sync.
//
// There is another exception to the above invariant when first connecting to
// the server: breakpoints have been installed on all generated locations in the
// pending breakpoints, but no breakpoints have been added to the reducer. When
// a matching source appears, either the server breakpoint will be removed or a
// breakpoint will be added to the reducer, to restore the above invariant.
// See syncBreakpoint.js for more.

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function clientSetBreakpoint(breakpoint) {
  return ({ getState, client }) => {
    const breakpointLocation = (0, _breakpoint.makeBreakpointLocation)(getState(), breakpoint.generatedLocation);
    return client.setBreakpoint(breakpointLocation, breakpoint.options);
  };
}

function clientRemoveBreakpoint(generatedLocation) {
  return ({ getState, client }) => {
    const breakpointLocation = (0, _breakpoint.makeBreakpointLocation)(getState(), generatedLocation);
    return client.removeBreakpoint(breakpointLocation);
  };
}

function enableBreakpoint(cx, initialBreakpoint) {
  return async ({ dispatch, getState, client, sourceMaps }) => {
    const breakpoint = (0, _selectors.getBreakpoint)(getState(), initialBreakpoint.location);
    if (!breakpoint || !breakpoint.disabled) {
      return;
    }

    dispatch({
      type: "SET_BREAKPOINT",
      cx,
      breakpoint: { ...breakpoint, disabled: false }
    });

    return dispatch(clientSetBreakpoint(breakpoint));
  };
}

function addBreakpoint(cx, initialLocation, options = {}, disabled = false, shouldCancel = () => false) {
  return async ({ dispatch, getState, sourceMaps, client }) => {
    (0, _telemetry.recordEvent)("add_breakpoint");

    const { sourceId, column, line } = initialLocation;

    await dispatch((0, _breakpointPositions.setBreakpointPositions)({ cx, sourceId, line }));

    const position = column ? (0, _selectors.getBreakpointPositionsForLocation)(getState(), initialLocation) : (0, _selectors.getFirstBreakpointPosition)(getState(), initialLocation);

    if (!position) {
      return;
    }

    const { location, generatedLocation } = position;

    const source = (0, _selectors.getSource)(getState(), location.sourceId);
    const generatedSource = (0, _selectors.getSource)(getState(), generatedLocation.sourceId);

    if (!source || !generatedSource) {
      return;
    }

    const symbols = (0, _selectors.getSymbols)(getState(), source);
    const astLocation = (0, _breakpoint.getASTLocation)(source, symbols, location);

    const originalContent = (0, _selectors.getSourceContent)(getState(), source.id);
    const originalText = (0, _source.getTextAtPosition)(source.id, originalContent, location);

    const content = (0, _selectors.getSourceContent)(getState(), generatedSource.id);
    const text = (0, _source.getTextAtPosition)(generatedSource.id, content, generatedLocation);

    const id = (0, _breakpoint.makeBreakpointId)(location);
    const breakpoint = {
      id,
      disabled,
      options,
      location,
      astLocation,
      generatedLocation,
      text,
      originalText
    };

    if (shouldCancel()) {
      return;
    }

    dispatch({ type: "SET_BREAKPOINT", cx, breakpoint });

    if (disabled) {
      // If we just clobbered an enabled breakpoint with a disabled one, we need
      // to remove any installed breakpoint in the server.
      return dispatch(clientRemoveBreakpoint(generatedLocation));
    }

    return dispatch(clientSetBreakpoint(breakpoint));
  };
}

/**
 * Remove a single breakpoint
 *
 * @memberof actions/breakpoints
 * @static
 */
function removeBreakpoint(cx, initialBreakpoint) {
  return ({ dispatch, getState, client }) => {
    (0, _telemetry.recordEvent)("remove_breakpoint");

    const breakpoint = (0, _selectors.getBreakpoint)(getState(), initialBreakpoint.location);
    if (!breakpoint) {
      return;
    }

    dispatch({
      type: "REMOVE_BREAKPOINT",
      cx,
      location: breakpoint.location
    });

    // If the breakpoint is disabled then it is not installed in the server.
    if (breakpoint.disabled) {
      return;
    }

    return dispatch(clientRemoveBreakpoint(breakpoint.generatedLocation));
  };
}

/**
 * Remove all installed, pending, and client breakpoints associated with a
 * target generated location.
 *
 * @memberof actions/breakpoints
 * @static
 */
function removeBreakpointAtGeneratedLocation(cx, target) {
  return ({ dispatch, getState, client }) => {
    // Remove any breakpoints matching the generated location.
    const breakpoints = (0, _selectors.getBreakpointsList)(getState());
    for (const { location, generatedLocation } of breakpoints) {
      if (generatedLocation.sourceId == target.sourceId && (0, _location.comparePosition)(generatedLocation, target)) {
        dispatch({
          type: "REMOVE_BREAKPOINT",
          cx,
          location
        });
      }
    }

    // Remove any remaining pending breakpoints matching the generated location.
    const pending = (0, _selectors.getPendingBreakpointList)(getState());
    for (const { location, generatedLocation } of pending) {
      if (generatedLocation.sourceUrl == target.sourceUrl && (0, _location.comparePosition)(generatedLocation, target)) {
        dispatch({
          type: "REMOVE_PENDING_BREAKPOINT",
          cx,
          location
        });
      }
    }

    // Remove the breakpoint from the client itself.
    return dispatch(clientRemoveBreakpoint(target));
  };
}

/**
 * Disable a single breakpoint
 *
 * @memberof actions/breakpoints
 * @static
 */
function disableBreakpoint(cx, initialBreakpoint) {
  return ({ dispatch, getState, client }) => {
    const breakpoint = (0, _selectors.getBreakpoint)(getState(), initialBreakpoint.location);
    if (!breakpoint || breakpoint.disabled) {
      return;
    }

    dispatch({
      type: "SET_BREAKPOINT",
      cx,
      breakpoint: { ...breakpoint, disabled: true }
    });

    return dispatch(clientRemoveBreakpoint(breakpoint.generatedLocation));
  };
}

/**
 * Update the options of a breakpoint.
 *
 * @throws {Error} "not implemented"
 * @memberof actions/breakpoints
 * @static
 * @param {SourceLocation} location
 *        @see DebuggerController.Breakpoints.addBreakpoint
 * @param {Object} options
 *        Any options to set on the breakpoint
 */
function setBreakpointOptions(cx, location, options = {}) {
  return ({ dispatch, getState, client, sourceMaps }) => {
    let breakpoint = (0, _selectors.getBreakpoint)(getState(), location);
    if (!breakpoint) {
      return dispatch(addBreakpoint(cx, location, options));
    }

    // Note: setting a breakpoint's options implicitly enables it.
    breakpoint = { ...breakpoint, disabled: false, options };

    dispatch({
      type: "SET_BREAKPOINT",
      cx,
      breakpoint
    });

    return dispatch(clientSetBreakpoint(breakpoint));
  };
}

/***/ }),
/* 655 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.syncBreakpoint = syncBreakpoint;

var _breakpointPositions = __webpack_require__(534);

var _symbols = __webpack_require__(521);

var _breakpoint = __webpack_require__(499);

var _location = __webpack_require__(509);

var _devtoolsSourceMap = __webpack_require__(182);

var _selectors = __webpack_require__(490);

var _ = __webpack_require__(504);

async function findBreakpointPosition(cx, { getState, dispatch }, location) {
  const { sourceId, line } = location;
  const positions = await dispatch((0, _breakpointPositions.setBreakpointPositions)({ cx, sourceId, line }));

  const position = (0, _breakpoint.findPosition)(positions, location);
  return position && position.generatedLocation;
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

async function findNewLocation(cx, { name, offset, index }, location, source, thunkArgs) {
  const symbols = await thunkArgs.dispatch((0, _symbols.setSymbols)({ cx, source }));
  const func = symbols ? (0, _breakpoint.findFunctionByName)(symbols, name, index) : null;

  // Fallback onto the location line, if we do not find a function.
  let line = location.line;
  if (func) {
    line = func.location.start.line + offset.line;
  }

  return {
    line,
    column: location.column,
    sourceUrl: source.url,
    sourceId: source.id
  };
}

// Breakpoint syncing occurs when a source is found that matches either the
// original or generated URL of a pending breakpoint. A new breakpoint is
// constructed that might have a different original and/or generated location,
// if the original source has changed since the pending breakpoint was created.
// There are a couple subtle aspects to syncing:
//
// - We handle both the original and generated source because there is no
//   guarantee that seeing the generated source means we will also see the
//   original source. When connecting, a breakpoint will be installed in the
//   client for the generated location in the pending breakpoint, and we need
//   to make sure that either a breakpoint is added to the reducer or that this
//   client breakpoint is deleted.
//
// - If we see both the original and generated sources and the source mapping
//   has changed, we need to make sure that only a single breakpoint is added
//   to the reducer for the new location corresponding to the original location
//   in the pending breakpoint.
function syncBreakpoint(cx, sourceId, pendingBreakpoint) {
  return async thunkArgs => {
    const { getState, client, dispatch } = thunkArgs;
    (0, _breakpoint.assertPendingBreakpoint)(pendingBreakpoint);

    const source = (0, _selectors.getSource)(getState(), sourceId);

    const generatedSourceId = (0, _devtoolsSourceMap.isOriginalId)(sourceId) ? (0, _devtoolsSourceMap.originalToGeneratedId)(sourceId) : sourceId;

    const generatedSource = (0, _selectors.getSource)(getState(), generatedSourceId);

    if (!source || !generatedSource) {
      return;
    }

    const { location, generatedLocation, astLocation } = pendingBreakpoint;
    const sourceGeneratedLocation = (0, _location.createLocation)({
      ...generatedLocation,
      sourceId: generatedSourceId
    });

    if (source == generatedSource && location.sourceUrl != generatedLocation.sourceUrl) {
      // We are handling the generated source and the pending breakpoint has a
      // source mapping. Supply a cancellation callback that will abort the
      // breakpoint if the original source was synced to a different location,
      // in which case the client breakpoint has been removed.
      const breakpointLocation = (0, _breakpoint.makeBreakpointLocation)(getState(), sourceGeneratedLocation);
      return dispatch((0, _.addBreakpoint)(cx, sourceGeneratedLocation, pendingBreakpoint.options, pendingBreakpoint.disabled, () => !client.hasBreakpoint(breakpointLocation)));
    }

    const previousLocation = { ...location, sourceId };

    const newLocation = await findNewLocation(cx, astLocation, previousLocation, source, thunkArgs);

    const newGeneratedLocation = await findBreakpointPosition(cx, thunkArgs, newLocation);

    if (!newGeneratedLocation) {
      // We couldn't find a new mapping for the breakpoint. If there is a source
      // mapping, remove any breakpoints for the generated location, as if the
      // breakpoint moved. If the old generated location still maps to an
      // original location then we don't want to add a breakpoint for it.
      if (location.sourceUrl != generatedLocation.sourceUrl) {
        dispatch((0, _.removeBreakpointAtGeneratedLocation)(cx, sourceGeneratedLocation));
      }
      return;
    }

    const isSameLocation = (0, _location.comparePosition)(generatedLocation, newGeneratedLocation);

    // If the new generated location has changed from that in the pending
    // breakpoint, remove any breakpoint associated with the old generated
    // location.
    if (!isSameLocation) {
      dispatch((0, _.removeBreakpointAtGeneratedLocation)(cx, sourceGeneratedLocation));
    }

    return dispatch((0, _.addBreakpoint)(cx, newLocation, pendingBreakpoint.options, pendingBreakpoint.disabled));
  };
}

/***/ }),
/* 656 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildMappedScopes = buildMappedScopes;

var _parser = __webpack_require__(503);

var _locColumn = __webpack_require__(522);

var _rangeMetadata = __webpack_require__(657);

var _findGeneratedBindingFromPosition = __webpack_require__(658);

var _buildGeneratedBindingList = __webpack_require__(659);

var _getApplicableBindingsForOriginalPosition = __webpack_require__(660);

var _log = __webpack_require__(594);

// eslint-disable-next-line max-len
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

async function buildMappedScopes(source, content, frame, scopes, sourceMaps, client) {
  const originalAstScopes = await (0, _parser.getScopes)(frame.location);
  const generatedAstScopes = await (0, _parser.getScopes)(frame.generatedLocation);

  if (!originalAstScopes || !generatedAstScopes) {
    return null;
  }

  const originalRanges = await (0, _rangeMetadata.loadRangeMetadata)(source, frame, originalAstScopes, sourceMaps);

  if (hasLineMappings(originalRanges)) {
    return null;
  }

  const generatedAstBindings = (0, _buildGeneratedBindingList.buildGeneratedBindingList)(scopes, generatedAstScopes, frame.this);

  const {
    mappedOriginalScopes,
    expressionLookup
  } = await mapOriginalBindingsToGenerated(source, content, originalRanges, originalAstScopes, generatedAstBindings, client, sourceMaps);

  const mappedGeneratedScopes = generateClientScope(scopes, mappedOriginalScopes);

  return isReliableScope(mappedGeneratedScopes) ? { mappings: expressionLookup, scope: mappedGeneratedScopes } : null;
}

async function mapOriginalBindingsToGenerated(source, content, originalRanges, originalAstScopes, generatedAstBindings, client, sourceMaps) {
  const expressionLookup = {};
  const mappedOriginalScopes = [];

  const cachedSourceMaps = batchScopeMappings(originalAstScopes, source, sourceMaps);

  for (const item of originalAstScopes) {
    const generatedBindings = {};

    for (const name of Object.keys(item.bindings)) {
      const binding = item.bindings[name];

      const result = await findGeneratedBinding(cachedSourceMaps, client, source, content, name, binding, originalRanges, generatedAstBindings);

      if (result) {
        generatedBindings[name] = result.grip;

        if (binding.refs.length !== 0 &&
        // These are assigned depth-first, so we don't want shadowed
        // bindings in parent scopes overwriting the expression.
        !Object.prototype.hasOwnProperty.call(expressionLookup, name)) {
          expressionLookup[name] = result.expression;
        }
      }
    }

    mappedOriginalScopes.push({
      ...item,
      generatedBindings
    });
  }

  return {
    mappedOriginalScopes,
    expressionLookup
  };
}

/**
 * Consider a scope and its parents reliable if the vast majority of its
 * bindings were successfully mapped to generated scope bindings.
 */
function isReliableScope(scope) {
  let totalBindings = 0;
  let unknownBindings = 0;

  for (let s = scope; s; s = s.parent) {
    const vars = s.bindings && s.bindings.variables || {};
    for (const key of Object.keys(vars)) {
      const binding = vars[key];

      totalBindings += 1;
      if (binding.value && typeof binding.value === "object" && (binding.value.type === "unscoped" || binding.value.type === "unmapped")) {
        unknownBindings += 1;
      }
    }
  }

  // As determined by fair dice roll.
  return totalBindings === 0 || unknownBindings / totalBindings < 0.25;
}

function hasLineMappings(ranges) {
  return ranges.every(range => range.columnStart === 0 && range.columnEnd === Infinity);
}

function batchScopeMappings(originalAstScopes, source, sourceMaps) {
  const precalculatedRanges = new Map();
  const precalculatedLocations = new Map();

  // Explicitly dispatch all of the sourcemap requests synchronously up front so
  // that they will be batched into a single request for the worker to process.
  for (const item of originalAstScopes) {
    for (const name of Object.keys(item.bindings)) {
      for (const ref of item.bindings[name].refs) {
        const locs = [ref];
        if (ref.type !== "ref") {
          locs.push(ref.declaration);
        }

        for (const loc of locs) {
          precalculatedRanges.set(buildLocationKey(loc.start), sourceMaps.getGeneratedRanges(loc.start, source));
          precalculatedLocations.set(buildLocationKey(loc.start), sourceMaps.getGeneratedLocation(loc.start, source));
          precalculatedLocations.set(buildLocationKey(loc.end), sourceMaps.getGeneratedLocation(loc.end, source));
        }
      }
    }
  }

  return {
    async getGeneratedRanges(pos, s) {
      const key = buildLocationKey(pos);

      if (s !== source || !precalculatedRanges.has(key)) {
        (0, _log.log)("Bad precalculated mapping");
        return sourceMaps.getGeneratedRanges(pos, s);
      }
      return precalculatedRanges.get(key);
    },
    async getGeneratedLocation(pos, s) {
      const key = buildLocationKey(pos);

      if (s !== source || !precalculatedLocations.has(key)) {
        (0, _log.log)("Bad precalculated mapping");
        return sourceMaps.getGeneratedLocation(pos, s);
      }
      return precalculatedLocations.get(key);
    }
  };
}
function buildLocationKey(loc) {
  return `${loc.line}:${(0, _locColumn.locColumn)(loc)}`;
}

function generateClientScope(scopes, originalScopes) {
  // Pull the root object scope and root lexical scope to reuse them in
  // our mapped scopes. This assumes that file file being processed is
  // a CommonJS or ES6 module, which might not be ideal. Potentially
  let globalLexicalScope = null;
  for (let s = scopes; s.parent; s = s.parent) {
    // $FlowIgnore - Flow doesn't like casting 'parent'.
    globalLexicalScope = s;
  }
  if (!globalLexicalScope) {
    throw new Error("Assertion failure - there should always be a scope");
  }

  // Build a structure similar to the client's linked scope object using
  // the original AST scopes, but pulling in the generated bindings
  // linked to each scope.
  const result = originalScopes.slice(0, -2).reverse().reduce((acc, orig, i) => {
    const {
      // The 'this' binding data we have is handled independently, so
      // the binding data is not included here.
      // eslint-disable-next-line no-unused-vars
      this: _this,
      ...variables
    } = orig.generatedBindings;

    return {
      parent: acc,
      actor: `originalActor${i}`,
      type: orig.type,
      bindings: {
        arguments: [],
        variables
      },
      ...(orig.type === "function" ? {
        function: {
          displayName: orig.displayName
        }
      } : null),
      ...(orig.type === "block" ? {
        block: {
          displayName: orig.displayName
        }
      } : null)
    };
  }, globalLexicalScope);

  // The rendering logic in getScope 'this' bindings only runs on the current
  // selected frame scope, so we pluck out the 'this' binding that was mapped,
  // and put it in a special location
  const thisScope = originalScopes.find(scope => scope.bindings.this);
  if (result.bindings && thisScope) {
    result.bindings.this = thisScope.generatedBindings.this || null;
  }

  return result;
}

function hasValidIdent(range, pos) {
  return range.type === "match" ||
  // For declarations, we allow the range on the identifier to be a
  // more general "contains" to increase the chances of a match.
  pos.type !== "ref" && range.type === "contains";
}

// eslint-disable-next-line complexity
async function findGeneratedBinding(sourceMaps, client, source, content, name, originalBinding, originalRanges, generatedAstBindings) {
  // If there are no references to the implicits, then we have no way to
  // even attempt to map it back to the original since there is no location
  // data to use. Bail out instead of just showing it as unmapped.
  if (originalBinding.type === "implicit" && !originalBinding.refs.some(item => item.type === "ref")) {
    return null;
  }

  const loadApplicableBindings = async (pos, locationType) => {
    let applicableBindings = await (0, _getApplicableBindingsForOriginalPosition.getApplicableBindingsForOriginalPosition)(generatedAstBindings, source, pos, originalBinding.type, locationType, sourceMaps);
    if (applicableBindings.length > 0) {
      hadApplicableBindings = true;
    }
    if (locationType === "ref") {
      // Some tooling creates ranges that map a line as a whole, which is useful
      // for step-debugging, but can easily lead to finding the wrong binding.
      // To avoid these false-positives, we entirely ignore bindings matched
      // by ranges that cover full lines.
      applicableBindings = applicableBindings.filter(({ range }) => !(range.start.column === 0 && range.end.column === Infinity));
    }
    if (locationType !== "ref" && !(await (0, _getApplicableBindingsForOriginalPosition.originalRangeStartsInside)(source, pos, sourceMaps))) {
      applicableBindings = [];
    }
    return applicableBindings;
  };

  const { refs } = originalBinding;

  let hadApplicableBindings = false;
  let genContent = null;
  for (const pos of refs) {
    const applicableBindings = await loadApplicableBindings(pos, pos.type);

    const range = (0, _rangeMetadata.findMatchingRange)(originalRanges, pos);
    if (range && hasValidIdent(range, pos)) {
      if (originalBinding.type === "import") {
        genContent = await (0, _findGeneratedBindingFromPosition.findGeneratedImportReference)(applicableBindings);
      } else {
        genContent = await (0, _findGeneratedBindingFromPosition.findGeneratedReference)(applicableBindings);
      }
    }

    if ((pos.type === "class-decl" || pos.type === "class-inner") && content.contentType && content.contentType.match(/\/typescript/)) {
      const declRange = (0, _rangeMetadata.findMatchingRange)(originalRanges, pos.declaration);
      if (declRange && declRange.type !== "multiple") {
        const applicableDeclBindings = await loadApplicableBindings(pos.declaration, pos.type);

        // Resolve to first binding in the range
        const declContent = await (0, _findGeneratedBindingFromPosition.findGeneratedReference)(applicableDeclBindings);

        if (declContent) {
          // Prefer the declaration mapping in this case because TS sometimes
          // maps class declaration names to "export.Foo = Foo;" or to
          // the decorator logic itself
          genContent = declContent;
        }
      }
    }

    if (!genContent && pos.type === "import-decl" && typeof pos.importName === "string") {
      const { importName } = pos;
      const declRange = (0, _rangeMetadata.findMatchingRange)(originalRanges, pos.declaration);

      // The import declaration should have an original position mapping,
      // but otherwise we don't really have preferences on the range type
      // because it can have multiple bindings, but we do want to make sure
      // that all of the bindings that match the range are part of the same
      // import declaration.
      if (declRange && declRange.singleDeclaration) {
        const applicableDeclBindings = await loadApplicableBindings(pos.declaration, pos.type);

        // match the import declaration location
        genContent = await (0, _findGeneratedBindingFromPosition.findGeneratedImportDeclaration)(applicableDeclBindings, importName);
      }
    }

    if (genContent) {
      break;
    }
  }

  if (genContent && genContent.desc) {
    return {
      grip: genContent.desc,
      expression: genContent.expression
    };
  } else if (genContent) {
    // If there is no descriptor for 'this', then this is not the top-level
    // 'this' that the server gave us a binding for, and we can just ignore it.
    if (name === "this") {
      return null;
    }

    // If the location is found but the descriptor is not, then it
    // means that the server scope information didn't match the scope
    // information from the DevTools parsed scopes.
    return {
      grip: {
        configurable: false,
        enumerable: true,
        writable: false,
        value: {
          type: "unscoped",
          unscoped: true,

          // HACK: Until support for "unscoped" lands in devtools-reps,
          // this will make these show as (unavailable).
          missingArguments: true
        }
      },
      expression: null
    };
  } else if (!hadApplicableBindings && name !== "this") {
    // If there were no applicable bindings to consider while searching for
    // matching bindings, then the source map for this file didn't make any
    // attempt to map the binding, and that most likely means that the
    // code was entirely emitted from the output code.
    return {
      grip: {
        configurable: false,
        enumerable: true,
        writable: false,
        value: {
          type: "null",
          optimizedOut: true
        }
      },
      expression: `
        (() => {
          throw new Error('"' + ${JSON.stringify(name)} + '" has been optimized out.');
        })()
      `
    };
  }

  // If no location mapping is found, then the map is bad, or
  // the map is okay but it original location is inside
  // of some scope, but the generated location is outside, leading
  // us to search for bindings that don't technically exist.
  return {
    grip: {
      configurable: false,
      enumerable: true,
      writable: false,
      value: {
        type: "unmapped",
        unmapped: true,

        // HACK: Until support for "unmapped" lands in devtools-reps,
        // this will make these show as (unavailable).
        missingArguments: true
      }
    },
    expression: null
  };
}

/***/ }),
/* 657 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadRangeMetadata = loadRangeMetadata;
exports.findMatchingRange = findMatchingRange;

var _locColumn = __webpack_require__(522);

var _positionCmp = __webpack_require__(549);

var _filtering = __webpack_require__(595);

// * match - Range contains a single identifier with matching start location
// * contains - Range contains a single identifier with non-matching start
// * multiple - Range contains multiple identifiers
// * empty - Range contains no identifiers
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

async function loadRangeMetadata(source, frame, originalAstScopes, sourceMaps) {
  const originalRanges = await sourceMaps.getOriginalRanges(frame.location.sourceId, source.url);

  const sortedOriginalAstBindings = [];
  for (const item of originalAstScopes) {
    for (const name of Object.keys(item.bindings)) {
      for (const ref of item.bindings[name].refs) {
        sortedOriginalAstBindings.push(ref);
      }
    }
  }
  sortedOriginalAstBindings.sort((a, b) => (0, _positionCmp.positionCmp)(a.start, b.start));

  let i = 0;

  return originalRanges.map(range => {
    const bindings = [];

    while (i < sortedOriginalAstBindings.length && (sortedOriginalAstBindings[i].start.line < range.line || sortedOriginalAstBindings[i].start.line === range.line && (0, _locColumn.locColumn)(sortedOriginalAstBindings[i].start) < range.columnStart)) {
      i++;
    }

    while (i < sortedOriginalAstBindings.length && sortedOriginalAstBindings[i].start.line === range.line && (0, _locColumn.locColumn)(sortedOriginalAstBindings[i].start) >= range.columnStart && (0, _locColumn.locColumn)(sortedOriginalAstBindings[i].start) < range.columnEnd) {
      const lastBinding = bindings[bindings.length - 1];
      // Only add bindings when they're in new positions
      if (!lastBinding || (0, _positionCmp.positionCmp)(lastBinding.start, sortedOriginalAstBindings[i].start) !== 0) {
        bindings.push(sortedOriginalAstBindings[i]);
      }
      i++;
    }

    let type = "empty";
    let singleDeclaration = true;
    if (bindings.length === 1) {
      const binding = bindings[0];
      if (binding.start.line === range.line && binding.start.column === range.columnStart) {
        type = "match";
      } else {
        type = "contains";
      }
    } else if (bindings.length > 1) {
      type = "multiple";
      const binding = bindings[0];
      const declStart = binding.type !== "ref" ? binding.declaration.start : null;

      singleDeclaration = bindings.every(b => {
        return declStart && b.type !== "ref" && (0, _positionCmp.positionCmp)(declStart, b.declaration.start) === 0;
      });
    }

    return {
      type,
      singleDeclaration,
      ...range
    };
  });
}

function findMatchingRange(sortedOriginalRanges, bindingRange) {
  return (0, _filtering.filterSortedArray)(sortedOriginalRanges, range => {
    if (range.line < bindingRange.start.line) {
      return -1;
    }
    if (range.line > bindingRange.start.line) {
      return 1;
    }

    if (range.columnEnd <= (0, _locColumn.locColumn)(bindingRange.start)) {
      return -1;
    }
    if (range.columnStart > (0, _locColumn.locColumn)(bindingRange.start)) {
      return 1;
    }

    return 0;
  }).pop();
}

/***/ }),
/* 658 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findGeneratedReference = findGeneratedReference;
exports.findGeneratedImportReference = findGeneratedImportReference;
exports.findGeneratedImportDeclaration = findGeneratedImportDeclaration;

var _locColumn = __webpack_require__(522);

var _mappingContains = __webpack_require__(596);

var _firefox = __webpack_require__(508);

/**
 * Given a mapped range over the generated source, attempt to resolve a real
 * binding descriptor that can be used to access the value.
 */
async function findGeneratedReference(applicableBindings) {
  // We can adjust this number as we go, but these are a decent start as a
  // general heuristic to assume the bindings were bad or just map a chunk of
  // whole line or something.
  if (applicableBindings.length > 4) {
    // Babel's for..of generates at least 3 bindings inside one range for
    // block-scoped loop variables, so we shouldn't go below that.
    applicableBindings = [];
  }

  for (const applicable of applicableBindings) {
    const result = await mapBindingReferenceToDescriptor(applicable);
    if (result) {
      return result;
    }
  }
  return null;
}
// eslint-disable-next-line max-len
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

async function findGeneratedImportReference(applicableBindings) {
  // When wrapped, for instance as `Object(ns.default)`, the `Object` binding
  // will be the first in the list. To avoid resolving `Object` as the
  // value of the import itself, we potentially skip the first binding.
  applicableBindings = applicableBindings.filter((applicable, i) => {
    if (!applicable.firstInRange || applicable.binding.loc.type !== "ref" || applicable.binding.loc.meta) {
      return true;
    }

    const next = i + 1 < applicableBindings.length ? applicableBindings[i + 1] : null;

    return !next || next.binding.loc.type !== "ref" || !next.binding.loc.meta;
  });

  // We can adjust this number as we go, but these are a decent start as a
  // general heuristic to assume the bindings were bad or just map a chunk of
  // whole line or something.
  if (applicableBindings.length > 2) {
    // Babel's for..of generates at least 3 bindings inside one range for
    // block-scoped loop variables, so we shouldn't go below that.
    applicableBindings = [];
  }

  for (const applicable of applicableBindings) {
    const result = await mapImportReferenceToDescriptor(applicable);
    if (result) {
      return result;
    }
  }

  return null;
}

/**
 * Given a mapped range over the generated source and the name of the imported
 * value that is referenced, attempt to resolve a binding descriptor for
 * the import's value.
 */
async function findGeneratedImportDeclaration(applicableBindings, importName) {
  // We can adjust this number as we go, but these are a decent start as a
  // general heuristic to assume the bindings were bad or just map a chunk of
  // whole line or something.
  if (applicableBindings.length > 10) {
    // Import declarations tend to have a large number of bindings for
    // for things like 'require' and 'interop', so this number is larger
    // than other binding count checks.
    applicableBindings = [];
  }

  let result = null;

  for (const { binding } of applicableBindings) {
    if (binding.loc.type === "ref") {
      continue;
    }

    const namespaceDesc = await binding.desc();
    if (isPrimitiveValue(namespaceDesc)) {
      continue;
    }
    if (!isObjectValue(namespaceDesc)) {
      // We want to handle cases like
      //
      //   var _mod = require(...);
      //   var _mod2 = _interopRequire(_mod);
      //
      // where "_mod" is optimized out because it is only referenced once. To
      // allow that, we track the optimized-out value as a possible result,
      // but allow later binding values to overwrite the result.
      result = {
        name: binding.name,
        desc: namespaceDesc,
        expression: binding.name
      };
      continue;
    }

    const desc = await readDescriptorProperty(namespaceDesc, importName);
    const expression = `${binding.name}.${importName}`;

    if (desc) {
      result = {
        name: binding.name,
        desc,
        expression
      };
      break;
    }
  }

  return result;
}

/**
 * Given a generated binding, and a range over the generated code, statically
 * check if the given binding matches the range.
 */
async function mapBindingReferenceToDescriptor({
  binding,
  range,
  firstInRange,
  firstOnLine
}) {
  // Allow the mapping to point anywhere within the generated binding
  // location to allow for less than perfect sourcemaps. Since you also
  // need at least one character between identifiers, we also give one
  // characters of space at the front the generated binding in order
  // to increase the probability of finding the right mapping.
  if (range.start.line === binding.loc.start.line && (
  // If a binding is the first on a line, Babel will extend the mapping to
  // include the whitespace between the newline and the binding. To handle
  // that, we skip the range requirement for starting location.
  firstInRange || firstOnLine || (0, _locColumn.locColumn)(range.start) >= (0, _locColumn.locColumn)(binding.loc.start)) && (0, _locColumn.locColumn)(range.start) <= (0, _locColumn.locColumn)(binding.loc.end)) {
    return {
      name: binding.name,
      desc: await binding.desc(),
      expression: binding.name
    };
  }

  return null;
}

/**
 * Given an generated binding, and a range over the generated code, statically
 * evaluate accessed properties within the mapped range to resolve the actual
 * imported value.
 */
async function mapImportReferenceToDescriptor({
  binding,
  range
}) {
  if (binding.loc.type !== "ref") {
    return null;
  }

  // Expression matches require broader searching because sourcemaps usage
  // varies in how they map certain things. For instance given
  //
  //   import { bar } from "mod";
  //   bar();
  //
  // The "bar()" expression is generally expanded into one of two possibly
  // forms, both of which map the "bar" identifier in different ways. See
  // the "^^" markers below for the ranges.
  //
  //   (0, foo.bar)()    // Babel
  //       ^^^^^^^       // mapping
  //       ^^^           // binding
  // vs
  //
  //   __webpack_require__.i(foo.bar)() // Webpack 2
  //   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   // mapping
  //                         ^^^        // binding
  // vs
  //
  //   Object(foo.bar)() // Webpack >= 3
  //   ^^^^^^^^^^^^^^^   // mapping
  //          ^^^        // binding
  //
  // Unfortunately, Webpack also has a tendancy to over-map past the call
  // expression to the start of the next line, at least when there isn't
  // anything else on that line that is mapped, e.g.
  //
  //   Object(foo.bar)()
  //   ^^^^^^^^^^^^^^^^^
  //   ^                 // wrapped to column 0 of next line

  if (!(0, _mappingContains.mappingContains)(range, binding.loc)) {
    return null;
  }

  // Webpack 2's import declarations wrap calls with an identity fn, so we
  // need to make sure to skip that binding because it is mapped to the
  // location of the original binding usage.
  if (binding.name === "__webpack_require__" && binding.loc.meta && binding.loc.meta.type === "member" && binding.loc.meta.property === "i") {
    return null;
  }

  let expression = binding.name;
  let desc = await binding.desc();

  if (binding.loc.type === "ref") {
    const { meta } = binding.loc;

    // Limit to 2 simple property or inherits operartions, since it would
    // just be more work to search more and it is very unlikely that
    // bindings would be mapped to more than a single member + inherits
    // wrapper.
    for (let op = meta, index = 0; op && (0, _mappingContains.mappingContains)(range, op) && desc && index < 2; index++, op = op && op.parent) {
      // Calling could potentially trigger side-effects, which would not
      // be ideal for this case.
      if (op.type === "call") {
        return null;
      }

      if (op.type === "inherit") {
        continue;
      }

      desc = await readDescriptorProperty(desc, op.property);
      expression += `.${op.property}`;
    }
  }

  return desc ? {
    name: binding.name,
    desc,
    expression
  } : null;
}

function isPrimitiveValue(desc) {
  return desc && (!desc.value || typeof desc.value !== "object");
}
function isObjectValue(desc) {
  return desc && !isPrimitiveValue(desc) && desc.value.type === "object" &&
  // Note: The check for `.type` might already cover the optimizedOut case
  // but not 100% sure, so just being cautious.
  !desc.value.optimizedOut;
}

async function readDescriptorProperty(desc, property) {
  if (!desc) {
    return null;
  }

  if (typeof desc.value !== "object" || !desc.value) {
    // If accessing a property on a primitive type, just return 'undefined'
    // as the value.
    return {
      value: {
        type: "undefined"
      }
    };
  }

  if (!isObjectValue(desc)) {
    // If we got a non-primitive descriptor but it isn't an object, then
    // it's definitely not the namespace and it is probably an error.
    return desc;
  }

  const objectClient = (0, _firefox.createObjectClient)(desc.value);
  return (await objectClient.getProperty(property)).descriptor;
}

/***/ }),
/* 659 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildGeneratedBindingList = buildGeneratedBindingList;

var _lodash = __webpack_require__(417);

var _firefox = __webpack_require__(508);

var _locColumn = __webpack_require__(522);

function buildGeneratedBindingList(scopes, generatedAstScopes, thisBinding) {
  // The server's binding data doesn't include general 'this' binding
  // information, so we manually inject the one 'this' binding we have into
  // the normal binding data we are working with.
  const frameThisOwner = generatedAstScopes.find(generated => "this" in generated.bindings);

  let globalScope = null;
  const clientScopes = [];
  for (let s = scopes; s; s = s.parent) {
    const bindings = s.bindings ? Object.assign({}, ...s.bindings.arguments, s.bindings.variables) : {};

    clientScopes.push(bindings);
    globalScope = s;
  }

  const generatedMainScopes = generatedAstScopes.slice(0, -2);
  const generatedGlobalScopes = generatedAstScopes.slice(-2);

  const clientMainScopes = clientScopes.slice(0, generatedMainScopes.length);
  const clientGlobalScopes = clientScopes.slice(generatedMainScopes.length);

  // Map the main parsed script body using the nesting hierarchy of the
  // generated and client scopes.
  const generatedBindings = generatedMainScopes.reduce((acc, generated, i) => {
    const bindings = clientMainScopes[i];

    if (generated === frameThisOwner && thisBinding) {
      bindings.this = {
        value: thisBinding
      };
    }

    for (const name of Object.keys(generated.bindings)) {
      // If there is no 'this' value, we exclude the binding entirely.
      // Otherwise it would pass through as found, but "(unscoped)", causing
      // the search logic to stop with a match.
      if (name === "this" && !bindings[name]) {
        continue;
      }

      const { refs } = generated.bindings[name];
      for (const loc of refs) {
        acc.push({
          name,
          loc,
          desc: () => Promise.resolve(bindings[name] || null)
        });
      }
    }
    return acc;
  }, []);

  // Bindings in the global/lexical global of the generated code may or
  // may not be the real global if the generated code is running inside
  // of an evaled context. To handle this, we just look up the client scope
  // hierarchy to find the closest binding with that name.
  for (const generated of generatedGlobalScopes) {
    for (const name of Object.keys(generated.bindings)) {
      const { refs } = generated.bindings[name];
      const bindings = clientGlobalScopes.find(b => (0, _lodash.has)(b, name));

      for (const loc of refs) {
        if (bindings) {
          generatedBindings.push({
            name,
            loc,
            desc: () => Promise.resolve(bindings[name])
          });
        } else {
          const globalGrip = globalScope && globalScope.object;
          if (globalGrip) {
            // Should always exist, just checking to keep Flow happy.

            generatedBindings.push({
              name,
              loc,
              desc: async () => {
                const objectClient = (0, _firefox.createObjectClient)(globalGrip);
                return (await objectClient.getProperty(name)).descriptor;
              }
            });
          }
        }
      }
    }
  }

  // Sort so we can binary-search.
  return generatedBindings.sort((a, b) => {
    const aStart = a.loc.start;
    const bStart = b.loc.start;

    if (aStart.line === bStart.line) {
      return (0, _locColumn.locColumn)(aStart) - (0, _locColumn.locColumn)(bStart);
    }
    return aStart.line - bStart.line;
  });
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/***/ }),
/* 660 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.originalRangeStartsInside = originalRangeStartsInside;
exports.getApplicableBindingsForOriginalPosition = getApplicableBindingsForOriginalPosition;

var _positionCmp = __webpack_require__(549);

var _filtering = __webpack_require__(595);

var _mappingContains = __webpack_require__(596);

async function originalRangeStartsInside(source, {
  start,
  end
}, sourceMaps) {
  const endPosition = await sourceMaps.getGeneratedLocation(end, source);
  const startPosition = await sourceMaps.getGeneratedLocation(start, source);

  // If the start and end positions collapse into eachother, it means that
  // the range in the original content didn't _start_ at the start position.
  // Since this likely means that the range doesn't logically apply to this
  // binding location, we skip it.
  return (0, _positionCmp.positionCmp)(startPosition, endPosition) !== 0;
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

async function getApplicableBindingsForOriginalPosition(generatedAstBindings, source, {
  start,
  end
}, bindingType, locationType, sourceMaps) {
  const ranges = await sourceMaps.getGeneratedRanges(start, source);

  const resultRanges = ranges.map(mapRange => ({
    start: {
      line: mapRange.line,
      column: mapRange.columnStart
    },
    end: {
      line: mapRange.line,
      // SourceMapConsumer's 'lastColumn' is inclusive, so we add 1 to make
      // it exclusive like all other locations.
      column: mapRange.columnEnd + 1
    }
  }));

  // When searching for imports, we expand the range to up to the next available
  // mapping to allow for import declarations that are composed of multiple
  // variable statements, where the later ones are entirely unmapped.
  // Babel 6 produces imports in this style, e.g.
  //
  // var _mod = require("mod"); // mapped from import statement
  // var _mod2 = interop(_mod); // entirely unmapped
  if (bindingType === "import" && locationType !== "ref") {
    const endPosition = await sourceMaps.getGeneratedLocation(end, source);
    const startPosition = await sourceMaps.getGeneratedLocation(start, source);

    for (const range of resultRanges) {
      if ((0, _mappingContains.mappingContains)(range, { start: startPosition, end: startPosition }) && (0, _positionCmp.positionCmp)(range.end, endPosition) < 0) {
        range.end = {
          line: endPosition.line,
          column: endPosition.column
        };
        break;
      }
    }
  }

  return filterApplicableBindings(generatedAstBindings, resultRanges);
}

function filterApplicableBindings(bindings, ranges) {
  const result = [];
  for (const range of ranges) {
    // Any binding overlapping a part of the mapping range.
    const filteredBindings = (0, _filtering.filterSortedArray)(bindings, binding => {
      if ((0, _positionCmp.positionCmp)(binding.loc.end, range.start) <= 0) {
        return -1;
      }
      if ((0, _positionCmp.positionCmp)(binding.loc.start, range.end) >= 0) {
        return 1;
      }

      return 0;
    });

    let firstInRange = true;
    let firstOnLine = true;
    let line = -1;

    for (const binding of filteredBindings) {
      if (binding.loc.start.line === line) {
        firstOnLine = false;
      } else {
        line = binding.loc.start.line;
        firstOnLine = true;
      }

      result.push({
        binding,
        range,
        firstOnLine,
        firstInRange
      });

      firstInRange = false;
    }
  }

  return result;
}

/***/ }),
/* 661 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.paused = paused;

var _selectors = __webpack_require__(490);

var _ = __webpack_require__(548);

var _breakpoints = __webpack_require__(504);

var _expressions = __webpack_require__(511);

var _sources = __webpack_require__(505);

var _assert = __webpack_require__(385);

var _assert2 = _interopRequireDefault(_assert);

var _fetchScopes = __webpack_require__(537);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Debugger has just paused
 *
 * @param {object} pauseInfo
 * @memberof actions/pause
 * @static
 */
function paused(pauseInfo) {
  return async function ({ dispatch, getState, client, sourceMaps }) {
    const { thread, frames, why } = pauseInfo;
    const topFrame = frames.length > 0 ? frames[0] : null;

    dispatch({
      type: "PAUSED",
      thread,
      why,
      frames,
      selectedFrameId: topFrame ? topFrame.id : undefined
    });

    // Get a context capturing the newly paused and selected thread.
    const cx = (0, _selectors.getThreadContext)(getState());
    (0, _assert2.default)(cx.thread == thread, "Thread mismatch");

    const hiddenBreakpoint = (0, _selectors.getHiddenBreakpoint)(getState());
    if (hiddenBreakpoint) {
      dispatch((0, _breakpoints.removeBreakpoint)(cx, hiddenBreakpoint));
    }

    await dispatch((0, _.mapFrames)(cx));

    const selectedFrame = (0, _selectors.getSelectedFrame)(getState(), thread);
    if (selectedFrame) {
      await dispatch((0, _sources.selectLocation)(cx, selectedFrame.location));
    }

    await dispatch((0, _fetchScopes.fetchScopes)(cx));

    // Run after fetching scoping data so that it may make use of the sourcemap
    // expression mappings for local variables.
    const atException = why.type == "exception";
    if (!atException || !(0, _selectors.isEvaluatingExpression)(getState(), thread)) {
      await dispatch((0, _expressions.evaluateExpressions)(cx));
    }
  };
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/***/ }),
/* 662 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resumed = resumed;

var _selectors = __webpack_require__(490);

var _expressions = __webpack_require__(511);

var _pause = __webpack_require__(550);

/**
 * Debugger has just resumed
 *
 * @memberof actions/pause
 * @static
 */
function resumed(packet) {
  return async ({ dispatch, client, getState }) => {
    const thread = packet.from;
    const why = (0, _selectors.getPauseReason)(getState(), thread);
    const wasPausedInEval = (0, _pause.inDebuggerEval)(why);
    const wasStepping = (0, _selectors.isStepping)(getState(), thread);

    dispatch({ type: "RESUME", thread, wasStepping });

    const cx = (0, _selectors.getThreadContext)(getState());
    if (!wasStepping && !wasPausedInEval && cx.thread == thread) {
      await dispatch((0, _expressions.evaluateExpressions)(cx));
    }
  };
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/***/ }),
/* 663 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPauseReason = getPauseReason;
exports.isException = isException;
exports.isInterrupted = isInterrupted;
exports.inDebuggerEval = inDebuggerEval;


// Map protocol pause "why" reason to a valid L10N key
// These are the known unhandled reasons:
// "breakpointConditionThrown", "clientEvaluated"
// "interrupted", "attached"
const reasons = {
  debuggerStatement: "whyPaused.debuggerStatement",
  breakpoint: "whyPaused.breakpoint",
  exception: "whyPaused.exception",
  resumeLimit: "whyPaused.resumeLimit",
  breakpointConditionThrown: "whyPaused.breakpointConditionThrown",

  // V8
  DOM: "whyPaused.breakpoint",
  EventListener: "whyPaused.pauseOnDOMEvents",
  XHR: "whyPaused.xhr",
  promiseRejection: "whyPaused.promiseRejection",
  assert: "whyPaused.assert",
  debugCommand: "whyPaused.debugCommand",
  other: "whyPaused.other"
}; /* This Source Code Form is subject to the terms of the Mozilla Public
    * License, v. 2.0. If a copy of the MPL was not distributed with this
    * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function getPauseReason(why) {
  if (!why) {
    return null;
  }

  const reasonType = why.type;
  if (!reasons[reasonType]) {
    console.log("Please file an issue: reasonType=", reasonType);
  }

  return reasons[reasonType];
}

function isException(why) {
  return why && why.type && why.type === "exception";
}

function isInterrupted(why) {
  return why && why.type && why.type === "interrupted";
}

function inDebuggerEval(why) {
  if (why && why.type === "exception" && why.exception && why.exception.preview && why.exception.preview.fileName) {
    return why.exception.preview.fileName === "debugger eval code";
  }

  return false;
}

/***/ }),
/* 664 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.continueToHere = continueToHere;

var _selectors = __webpack_require__(490);

var _breakpoints = __webpack_require__(504);

var _commands = __webpack_require__(591);

function continueToHere(cx, line, column) {
  return async function ({ dispatch, getState }) {
    const selectedSource = (0, _selectors.getSelectedSource)(getState());
    const selectedFrame = (0, _selectors.getSelectedFrame)(getState(), cx.thread);

    if (!selectedFrame || !selectedSource) {
      return;
    }

    const debugLine = selectedFrame.location.line;
    if (debugLine == line) {
      return;
    }

    const action = (0, _selectors.getCanRewind)(getState()) && line < debugLine ? _commands.rewind : _commands.resume;

    await dispatch((0, _breakpoints.addHiddenBreakpoint)(cx, {
      line,
      column: column,
      sourceId: selectedSource.id
    }));

    dispatch(action(cx));
  };
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/***/ }),
/* 665 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.breakOnNext = breakOnNext;


/**
 * Debugger breakOnNext command.
 * It's different from the comand action because we also want to
 * highlight the pause icon.
 *
 * @memberof actions/pause
 * @static
 */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function breakOnNext(cx) {
  return async ({ dispatch, getState, client }) => {
    await client.breakOnNext(cx.thread);
    return dispatch({ type: "BREAK_ON_NEXT", thread: cx.thread });
  };
}

/***/ }),
/* 666 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateFrameLocation = updateFrameLocation;
exports.mapDisplayNames = mapDisplayNames;
exports.mapFrames = mapFrames;

var _selectors = __webpack_require__(490);

var _assert = __webpack_require__(385);

var _assert2 = _interopRequireDefault(_assert);

var _ast = __webpack_require__(519);

var _symbols = __webpack_require__(521);

var _devtoolsSourceMap = __webpack_require__(182);

var _devtoolsSourceMap2 = _interopRequireDefault(_devtoolsSourceMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isFrameBlackboxed(state, frame) {
  const source = (0, _selectors.getSource)(state, frame.location.sourceId);
  return source && source.isBlackBoxed;
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function getSelectedFrameId(state, thread, frames) {
  let selectedFrame = (0, _selectors.getSelectedFrame)(state, thread);
  if (selectedFrame && !isFrameBlackboxed(state, selectedFrame)) {
    return selectedFrame.id;
  }

  selectedFrame = frames.find(frame => !isFrameBlackboxed(state, frame));
  return selectedFrame && selectedFrame.id;
}

function updateFrameLocation(frame, sourceMaps) {
  if (frame.isOriginal) {
    return Promise.resolve(frame);
  }
  return sourceMaps.getOriginalLocation(frame.location).then(loc => ({
    ...frame,
    location: loc,
    generatedLocation: frame.generatedLocation || frame.location
  }));
}

function updateFrameLocations(frames, sourceMaps) {
  if (!frames || frames.length == 0) {
    return Promise.resolve(frames);
  }

  return Promise.all(frames.map(frame => updateFrameLocation(frame, sourceMaps)));
}

function mapDisplayNames(frames, getState) {
  return frames.map(frame => {
    if (frame.isOriginal) {
      return frame;
    }

    const source = (0, _selectors.getSource)(getState(), frame.location.sourceId);

    if (!source) {
      return frame;
    }

    const symbols = (0, _selectors.getSymbols)(getState(), source);

    if (!symbols || !symbols.functions) {
      return frame;
    }

    const originalFunction = (0, _ast.findClosestFunction)(symbols, frame.location);

    if (!originalFunction) {
      return frame;
    }

    const originalDisplayName = originalFunction.name;
    return { ...frame, originalDisplayName };
  });
}

function isWasmOriginalSourceFrame(frame, getState) {
  if ((0, _devtoolsSourceMap.isGeneratedId)(frame.location.sourceId)) {
    return false;
  }
  const generatedSource = (0, _selectors.getSource)(getState(), frame.generatedLocation.sourceId);

  return Boolean(generatedSource && generatedSource.isWasm);
}

async function expandFrames(frames, sourceMaps, getState) {
  const result = [];
  for (let i = 0; i < frames.length; ++i) {
    const frame = frames[i];
    if (frame.isOriginal || !isWasmOriginalSourceFrame(frame, getState)) {
      result.push(frame);
      continue;
    }
    const originalFrames = await sourceMaps.getOriginalStackFrames(frame.generatedLocation);
    if (!originalFrames) {
      result.push(frame);
      continue;
    }

    (0, _assert2.default)(originalFrames.length > 0, "Expected at least one original frame");
    // First entry has not specific location -- use one from original frame.
    originalFrames[0] = {
      ...originalFrames[0],
      location: frame.location
    };

    originalFrames.forEach((originalFrame, j) => {
      if (!originalFrame.location || !originalFrame.thread) {
        return;
      }

      // Keep outer most frame with true actor ID, and generate uniquie
      // one for the nested frames.
      const id = j == 0 ? frame.id : `${frame.id}-originalFrame${j}`;
      result.push({
        id,
        thread: originalFrame.thread,
        displayName: originalFrame.displayName,
        location: originalFrame.location,
        source: null,
        scope: frame.scope,
        this: frame.this,
        isOriginal: true,
        // More fields that will be added by the mapDisplayNames and
        // updateFrameLocation.
        generatedLocation: frame.generatedLocation,
        originalDisplayName: originalFrame.displayName
      });
    });
  }
  return result;
}

async function updateFrameSymbols(cx, frames, { dispatch, getState }) {
  await Promise.all(frames.map(frame => {
    const source = (0, _selectors.getSourceFromId)(getState(), frame.location.sourceId);
    return dispatch((0, _symbols.setSymbols)({ cx, source }));
  }));
}

/**
 * Map call stack frame locations and display names to originals.
 * e.g.
 * 1. When the debuggee pauses
 * 2. When a source is pretty printed
 * 3. When symbols are loaded
 * @memberof actions/pause
 * @static
 */
function mapFrames(cx) {
  return async function (thunkArgs) {
    const { dispatch, getState, sourceMaps } = thunkArgs;
    const frames = (0, _selectors.getFrames)(getState(), cx.thread);
    if (!frames) {
      return;
    }

    let mappedFrames = await updateFrameLocations(frames, sourceMaps);
    await updateFrameSymbols(cx, mappedFrames, thunkArgs);

    mappedFrames = await expandFrames(mappedFrames, sourceMaps, getState);
    mappedFrames = mapDisplayNames(mappedFrames, getState);

    const selectedFrameId = getSelectedFrameId(getState(), cx.thread, mappedFrames);
    dispatch({
      type: "MAP_FRAMES",
      cx,
      thread: cx.thread,
      frames: mappedFrames,
      selectedFrameId
    });
  };
}

/***/ }),
/* 667 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pauseOnExceptions = pauseOnExceptions;

var _promise = __webpack_require__(500);

var _telemetry = __webpack_require__(520);

/**
 *
 * @memberof actions/pause
 * @static
 */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function pauseOnExceptions(shouldPauseOnExceptions, shouldPauseOnCaughtExceptions) {
  return ({ dispatch, getState, client }) => {
    (0, _telemetry.recordEvent)("pause_on_exceptions", {
      exceptions: shouldPauseOnExceptions,
      // There's no "n" in the key below (#1463117)
      ["caught_exceptio"]: shouldPauseOnCaughtExceptions
    });

    return dispatch({
      type: "PAUSE_ON_EXCEPTIONS",
      shouldPauseOnExceptions,
      shouldPauseOnCaughtExceptions,
      [_promise.PROMISE]: client.pauseOnExceptions(shouldPauseOnExceptions, shouldPauseOnCaughtExceptions)
    });
  };
}

/***/ }),
/* 668 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.selectFrame = selectFrame;

var _sources = __webpack_require__(505);

var _expressions = __webpack_require__(511);

var _fetchScopes = __webpack_require__(537);

var _assert = __webpack_require__(385);

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @memberof actions/pause
 * @static
 */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function selectFrame(cx, frame) {
  return async ({ dispatch, client, getState, sourceMaps }) => {
    (0, _assert2.default)(cx.thread == frame.thread, "Thread mismatch");

    dispatch({
      type: "SELECT_FRAME",
      cx,
      thread: cx.thread,
      frame
    });

    dispatch((0, _sources.selectLocation)(cx, frame.location));

    dispatch((0, _expressions.evaluateExpressions)(cx));
    dispatch((0, _fetchScopes.fetchScopes)(cx));
  };
}

/***/ }),
/* 669 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toggleSkipPausing = toggleSkipPausing;

var _selectors = __webpack_require__(490);

/**
 * @memberof actions/pause
 * @static
 */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function toggleSkipPausing() {
  return async ({ dispatch, client, getState, sourceMaps }) => {
    const skipPausing = !(0, _selectors.getSkipPausing)(getState());
    await client.setSkipPausing(skipPausing);
    dispatch({ type: "TOGGLE_SKIP_PAUSING", skipPausing });
  };
}

/***/ }),
/* 670 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setInScopeLines = setInScopeLines;

var _selectors = __webpack_require__(490);

var _source = __webpack_require__(494);

var _lodash = __webpack_require__(417);

var _asyncValue = __webpack_require__(497);

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function getOutOfScopeLines(outOfScopeLocations) {
  if (!outOfScopeLocations) {
    return null;
  }

  return (0, _lodash.uniq)((0, _lodash.flatMap)(outOfScopeLocations, location => (0, _lodash.range)(location.start.line, location.end.line)));
}

function setInScopeLines(cx) {
  return ({ dispatch, getState }) => {
    const sourceWithContent = (0, _selectors.getSelectedSourceWithContent)(getState());
    const outOfScopeLocations = (0, _selectors.getOutOfScopeLocations)(getState());

    if (!sourceWithContent || !sourceWithContent.content) {
      return;
    }
    const content = sourceWithContent.content;

    const linesOutOfScope = getOutOfScopeLines(outOfScopeLocations);

    const sourceNumLines = (0, _asyncValue.isFulfilled)(content) ? (0, _source.getSourceLineCount)(content.value) : 0;
    const sourceLines = (0, _lodash.range)(1, sourceNumLines + 1);

    const inScopeLines = !linesOutOfScope ? sourceLines : (0, _lodash.without)(sourceLines, ...linesOutOfScope);

    dispatch({
      type: "IN_SCOPE_LINES",
      cx,
      lines: inScopeLines
    });
  };
}

/***/ }),
/* 671 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getGeneratedLocation = getGeneratedLocation;
exports.getOriginalLocation = getOriginalLocation;
exports.getMappedLocation = getMappedLocation;
exports.mapLocation = mapLocation;
exports.isOriginalSource = isOriginalSource;

var _devtoolsSourceMap = __webpack_require__(182);

var _devtoolsSourceMap2 = _interopRequireDefault(_devtoolsSourceMap);

var _selectors = __webpack_require__(490);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

async function getGeneratedLocation(state, source, location, sourceMaps) {
  if (!(0, _devtoolsSourceMap.isOriginalId)(location.sourceId)) {
    return location;
  }

  const { line, sourceId, column } = await sourceMaps.getGeneratedLocation(location, source);

  const generatedSource = (0, _selectors.getSource)(state, sourceId);
  if (!generatedSource) {
    throw new Error(`Could not find generated source ${sourceId}`);
  }

  return {
    line,
    sourceId,
    column: column === 0 ? undefined : column,
    sourceUrl: generatedSource.url
  };
}

async function getOriginalLocation(generatedLocation, sourceMaps) {
  if ((0, _devtoolsSourceMap.isOriginalId)(generatedLocation.sourceId)) {
    return location;
  }

  return sourceMaps.getOriginalLocation(generatedLocation);
}

async function getMappedLocation(state, sourceMaps, location) {
  const source = (0, _selectors.getSource)(state, location.sourceId);

  if (!source) {
    throw new Error(`no source ${location.sourceId}`);
  }

  if ((0, _devtoolsSourceMap.isOriginalId)(location.sourceId)) {
    const generatedLocation = await getGeneratedLocation(state, source, location, sourceMaps);
    return { location, generatedLocation };
  }

  const generatedLocation = location;
  const originalLocation = await sourceMaps.getOriginalLocation(generatedLocation);

  return { location: originalLocation, generatedLocation };
}

async function mapLocation(state, sourceMaps, location) {
  const source = (0, _selectors.getSource)(state, location.sourceId);

  if (!source) {
    return location;
  }

  if ((0, _devtoolsSourceMap.isOriginalId)(location.sourceId)) {
    return getGeneratedLocation(state, source, location, sourceMaps);
  }

  return sourceMaps.getOriginalLocation(location);
}

function isOriginalSource(source) {
  return source && (0, _devtoolsSourceMap.isOriginalId)(source.id);
}

/***/ }),
/* 672 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.newQueuedSources = newQueuedSources;
exports.newOriginalSource = newOriginalSource;
exports.newOriginalSources = newOriginalSources;
exports.newGeneratedSource = newGeneratedSource;
exports.newGeneratedSources = newGeneratedSources;

var _devtoolsSourceMap = __webpack_require__(182);

var _lodash = __webpack_require__(417);

var _sourceActors = __webpack_require__(529);

var _sourceActors2 = __webpack_require__(552);

var _create = __webpack_require__(539);

var _blackbox = __webpack_require__(589);

var _breakpoints = __webpack_require__(504);

var _loadSourceText = __webpack_require__(507);

var _prettyPrint = __webpack_require__(535);

var _sources = __webpack_require__(505);

var _source = __webpack_require__(494);

var _selectors = __webpack_require__(490);

var _prefs = __webpack_require__(492);

var _sourceQueue = __webpack_require__(513);

var _sourceQueue2 = _interopRequireDefault(_sourceQueue);

var _context = __webpack_require__(568);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function loadSourceMaps(cx, sources) {
  return async function ({
    dispatch,
    sourceMaps
  }) {
    try {
      const sourceList = await Promise.all(sources.map(async ({ id }) => {
        const originalSources = await dispatch(loadSourceMap(cx, id));
        _sourceQueue2.default.queueSources(originalSources.map(data => ({
          type: "original",
          data
        })));
        return originalSources;
      }));

      await _sourceQueue2.default.flush();

      // We would like to sync breakpoints after we are done
      // loading source maps as sometimes generated and original
      // files share the same paths.
      for (const source of sources) {
        dispatch(checkPendingBreakpoints(cx, source.id));
      }

      return (0, _lodash.flatten)(sourceList);
    } catch (error) {
      if (!(error instanceof _context.ContextError)) {
        throw error;
      }
    }
  };
}

/**
 * @memberof actions/sources
 * @static
 */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/**
 * Redux actions for the sources state
 * @module actions/sources
 */

function loadSourceMap(cx, sourceId) {
  return async function ({
    dispatch,
    getState,
    sourceMaps
  }) {
    const source = (0, _selectors.getSource)(getState(), sourceId);

    if (!_prefs.prefs.clientSourceMapsEnabled || !source || (0, _source.isOriginal)(source) || !source.sourceMapURL) {
      return [];
    }

    let urls = null;
    try {
      // Unable to correctly type the result of a spread on a union type.
      const urlInfo = { ...source };
      if (!urlInfo.url && typeof urlInfo.introductionUrl === "string") {
        // If the source was dynamically generated (via eval, dynamically
        // created script elements, and so forth), it won't have a URL, so that
        // it is not collapsed into other sources from the same place. The
        // introduction URL will include the point it was constructed at,
        // however, so use that for resolving any source maps in the source.
        urlInfo.url = urlInfo.introductionUrl;
      }
      urls = await sourceMaps.getOriginalURLs(urlInfo);
    } catch (e) {
      console.error(e);
    }

    if (!urls) {
      // If this source doesn't have a sourcemap, enable it for pretty printing
      dispatch({
        type: "CLEAR_SOURCE_MAP_URL",
        cx,
        sourceId
      });
      return [];
    }

    (0, _context.validateNavigateContext)(getState(), cx);
    return urls.map(url => ({
      id: (0, _devtoolsSourceMap.generatedToOriginalId)(source.id, url),
      url
    }));
  };
}

// If a request has been made to show this source, go ahead and
// select it.
function checkSelectedSource(cx, sourceId) {
  return async ({ dispatch, getState }) => {
    const source = (0, _selectors.getSource)(getState(), sourceId);
    const pendingLocation = (0, _selectors.getPendingSelectedLocation)(getState());

    if (!pendingLocation || !pendingLocation.url || !source || !source.url) {
      return;
    }

    const pendingUrl = pendingLocation.url;
    const rawPendingUrl = (0, _source.getRawSourceURL)(pendingUrl);

    if (rawPendingUrl === source.url) {
      if ((0, _source.isPrettyURL)(pendingUrl)) {
        const prettySource = await dispatch((0, _prettyPrint.togglePrettyPrint)(cx, source.id));
        return dispatch(checkPendingBreakpoints(cx, prettySource.id));
      }

      await dispatch((0, _sources.selectLocation)(cx, {
        sourceId: source.id,
        line: typeof pendingLocation.line === "number" ? pendingLocation.line : 0,
        column: pendingLocation.column
      }));
    }
  };
}

function checkPendingBreakpoints(cx, sourceId) {
  return async ({ dispatch, getState }) => {
    // source may have been modified by selectLocation
    const source = (0, _selectors.getSource)(getState(), sourceId);
    if (!source) {
      return;
    }

    const pendingBreakpoints = (0, _selectors.getPendingBreakpointsForSource)(getState(), source);

    if (pendingBreakpoints.length === 0) {
      return;
    }

    // load the source text if there is a pending breakpoint for it
    await dispatch((0, _loadSourceText.loadSourceText)({ cx, source }));

    await Promise.all(pendingBreakpoints.map(bp => {
      return dispatch((0, _breakpoints.syncBreakpoint)(cx, sourceId, bp));
    }));
  };
}

function restoreBlackBoxedSources(cx, sources) {
  return async ({ dispatch }) => {
    const tabs = (0, _selectors.getBlackBoxList)();
    if (tabs.length == 0) {
      return;
    }
    for (const source of sources) {
      if (tabs.includes(source.url) && !source.isBlackBoxed) {
        dispatch((0, _blackbox.toggleBlackBox)(cx, source));
      }
    }
  };
}

function newQueuedSources(sourceInfo) {
  return async ({ dispatch }) => {
    const generated = [];
    const original = [];
    for (const source of sourceInfo) {
      if (source.type === "generated") {
        generated.push(source.data);
      } else {
        original.push(source.data);
      }
    }

    if (generated.length > 0) {
      await dispatch(newGeneratedSources(generated));
    }
    if (original.length > 0) {
      await dispatch(newOriginalSources(original));
    }
  };
}

function newOriginalSource(sourceInfo) {
  return async ({ dispatch }) => {
    const sources = await dispatch(newOriginalSources([sourceInfo]));
    return sources[0];
  };
}
function newOriginalSources(sourceInfo) {
  return async ({ dispatch, getState }) => {
    const sources = sourceInfo.map(({ id, url }) => ({
      id,
      url,
      relativeUrl: url,
      isPrettyPrinted: false,
      isWasm: false,
      isBlackBoxed: false,
      introductionUrl: null,
      introductionType: undefined,
      isExtension: false
    }));

    const cx = (0, _selectors.getContext)(getState());
    dispatch(addSources(cx, sources));

    await dispatch(checkNewSources(cx, sources));

    return sources;
  };
}

function newGeneratedSource(sourceInfo) {
  return async ({ dispatch }) => {
    const sources = await dispatch(newGeneratedSources([sourceInfo]));
    return sources[0];
  };
}
function newGeneratedSources(sourceInfo) {
  return async ({
    dispatch,
    getState,
    client
  }) => {
    const supportsWasm = client.hasWasmSupport();

    const resultIds = [];
    const newSourcesObj = {};
    const newSourceActors = [];

    for (const { thread, source, id } of sourceInfo) {
      const newId = id || (0, _create.makeSourceId)(source);

      if (!(0, _selectors.getSource)(getState(), newId) && !newSourcesObj[newId]) {
        newSourcesObj[newId] = {
          id: newId,
          url: source.url,
          relativeUrl: source.url,
          isPrettyPrinted: false,
          sourceMapURL: source.sourceMapURL,
          introductionUrl: source.introductionUrl,
          introductionType: source.introductionType,
          isBlackBoxed: false,
          isWasm: !!supportsWasm && source.introductionType === "wasm",
          isExtension: source.url && (0, _source.isUrlExtension)(source.url) || false
        };
      }

      const actorId = (0, _sourceActors.stringToSourceActorId)(source.actor);

      // We are sometimes notified about a new source multiple times if we
      // request a new source list and also get a source event from the server.
      if (!(0, _selectors.hasSourceActor)(getState(), actorId)) {
        newSourceActors.push({
          id: actorId,
          actor: source.actor,
          thread,
          source: newId,
          isBlackBoxed: source.isBlackBoxed,
          sourceMapURL: source.sourceMapURL,
          url: source.url,
          introductionUrl: source.introductionUrl,
          introductionType: source.introductionType
        });
      }

      resultIds.push(newId);
    }

    const newSources = Object.values(newSourcesObj);

    const cx = (0, _selectors.getContext)(getState());
    dispatch(addSources(cx, newSources));
    dispatch((0, _sourceActors2.insertSourceActors)(newSourceActors));

    for (const newSourceActor of newSourceActors) {
      // Fetch breakable lines for new HTML scripts
      // when the HTML file has started loading
      if ((0, _source.isInlineScript)(newSourceActor) && (0, _selectors.isSourceLoadingOrLoaded)(getState(), newSourceActor.source)) {
        dispatch((0, _sources.setBreakableLines)(cx, newSourceActor.source)).catch(error => {
          if (!(error instanceof _context.ContextError)) {
            throw error;
          }
        });
      }
    }
    await dispatch(checkNewSources(cx, newSources));

    return resultIds.map(id => (0, _selectors.getSourceFromId)(getState(), id));
  };
}

function addSources(cx, sources) {
  return ({ dispatch, getState }) => {
    dispatch({ type: "ADD_SOURCES", cx, sources });
  };
}

function checkNewSources(cx, sources) {
  return async ({ dispatch, getState }) => {
    for (const source of sources) {
      dispatch(checkSelectedSource(cx, source.id));
    }

    dispatch(restoreBlackBoxedSources(cx, sources));
    dispatch(loadSourceMaps(cx, sources));

    return sources;
  };
}

/***/ }),
/* 673 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = remapLocations;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function remapLocations(breakpoints, sourceId, sourceMaps) {
  const sourceBreakpoints = breakpoints.map(async breakpoint => {
    if (breakpoint.location.sourceId !== sourceId) {
      return breakpoint;
    }
    const location = await sourceMaps.getOriginalLocation(breakpoint.location);
    return { ...breakpoint, location };
  });

  return Promise.all(sourceBreakpoints);
}

/***/ }),
/* 674 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addEventListeners = addEventListeners;
exports.removeEventListeners = removeEventListeners;

var _prefs = __webpack_require__(492);

function addEventListeners(events) {
  return async ({ dispatch, client }) => {
    await dispatch({
      type: "ADD_EVENT_LISTENERS",
      events
    });
    const newList = await _prefs.asyncStore.eventListenerBreakpoints;
    client.setEventListenerBreakpoints(newList);
  };
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function removeEventListeners(events) {
  return async ({ dispatch, client }) => {
    await dispatch({
      type: "REMOVE_EVENT_LISTENERS",
      events
    });
    const newList = await _prefs.asyncStore.eventListenerBreakpoints;
    client.setEventListenerBreakpoints(newList);
  };
}

/***/ }),
/* 675 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.willNavigate = willNavigate;
exports.connect = connect;
exports.navigated = navigated;

var _editor = __webpack_require__(496);

var _sourceQueue = __webpack_require__(513);

var _sourceQueue2 = _interopRequireDefault(_sourceQueue);

var _sources = __webpack_require__(498);

var _utils = __webpack_require__(524);

var _sources2 = __webpack_require__(505);

var _debuggee = __webpack_require__(599);

var _parser = __webpack_require__(503);

var _wasm = __webpack_require__(516);

var _selectors = __webpack_require__(490);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Redux actions for the navigation state
 * @module actions/navigation
 */

/**
 * @memberof actions/navigation
 * @static
 */
function willNavigate(event) {
  return function ({ dispatch, getState, client, sourceMaps }) {
    _sourceQueue2.default.clear();
    sourceMaps.clearSourceMaps();
    (0, _wasm.clearWasmStates)();
    (0, _editor.clearDocuments)();
    (0, _parser.clearSymbols)();
    (0, _parser.clearASTs)();
    (0, _parser.clearScopes)();
    (0, _parser.clearSources)();
    client.detachWorkers();
    const thread = (0, _selectors.getMainThread)(getState());

    dispatch({
      type: "NAVIGATE",
      mainThread: { ...thread, url: event.url }
    });
  };
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function connect(url, actor, canRewind) {
  return async function ({ dispatch }) {
    await dispatch((0, _debuggee.updateWorkers)());
    dispatch({
      type: "CONNECT",
      mainThread: { url, actor, type: -1, name: "" },
      canRewind
    });
  };
}

/**
 * @memberof actions/navigation
 * @static
 */
function navigated() {
  return async function ({ dispatch, getState, client, panel }) {
    // this time out is used to wait for sources. If we have 0 sources,
    // it is likely that the sources are being loaded from the bfcache,
    // and we should make an explicit request to the server to load them.
    await (0, _utils.waitForMs)(100);
    if ((0, _sources.getSourceList)(getState()).length == 0) {
      const sources = await client.fetchSources();
      dispatch((0, _sources2.newGeneratedSources)(sources));
    }
    panel.emit("reloaded");
  };
}

/***/ }),
/* 676 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addSearchQuery = addSearchQuery;
exports.addOngoingSearch = addOngoingSearch;
exports.addSearchResult = addSearchResult;
exports.clearSearchResults = clearSearchResults;
exports.clearSearch = clearSearch;
exports.updateSearchStatus = updateSearchStatus;
exports.closeProjectSearch = closeProjectSearch;
exports.stopOngoingSearch = stopOngoingSearch;
exports.searchSources = searchSources;
exports.searchSource = searchSource;

var _asyncValue = __webpack_require__(497);

var _search = __webpack_require__(542);

var _selectors = __webpack_require__(490);

var _source = __webpack_require__(494);

var _loadSourceText = __webpack_require__(507);

var _projectTextSearch = __webpack_require__(532);

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/**
 * Redux actions for the search state
 * @module actions/search
 */

function addSearchQuery(cx, query) {
  return { type: "ADD_QUERY", cx, query };
}

function addOngoingSearch(cx, ongoingSearch) {
  return { type: "ADD_ONGOING_SEARCH", cx, ongoingSearch };
}

function addSearchResult(cx, sourceId, filepath, matches) {
  return {
    type: "ADD_SEARCH_RESULT",
    cx,
    result: { sourceId, filepath, matches }
  };
}

function clearSearchResults(cx) {
  return { type: "CLEAR_SEARCH_RESULTS", cx };
}

function clearSearch(cx) {
  return { type: "CLEAR_SEARCH", cx };
}

function updateSearchStatus(cx, status) {
  return { type: "UPDATE_STATUS", cx, status };
}

function closeProjectSearch(cx) {
  return ({ dispatch, getState }) => {
    dispatch(stopOngoingSearch(cx));
    dispatch({ type: "CLOSE_PROJECT_SEARCH" });
  };
}

function stopOngoingSearch(cx) {
  return ({ dispatch, getState }) => {
    const state = getState();
    const ongoingSearch = (0, _projectTextSearch.getTextSearchOperation)(state);
    const status = (0, _projectTextSearch.getTextSearchStatus)(state);
    if (ongoingSearch && status !== _projectTextSearch.statusType.done) {
      ongoingSearch.cancel();
      dispatch(updateSearchStatus(cx, _projectTextSearch.statusType.cancelled));
    }
  };
}

function searchSources(cx, query) {
  let cancelled = false;

  const search = async ({ dispatch, getState }) => {
    dispatch(stopOngoingSearch(cx));
    await dispatch(addOngoingSearch(cx, search));
    await dispatch(clearSearchResults(cx));
    await dispatch(addSearchQuery(cx, query));
    dispatch(updateSearchStatus(cx, _projectTextSearch.statusType.fetching));
    const validSources = (0, _selectors.getSourceList)(getState()).filter(source => !(0, _selectors.hasPrettySource)(getState(), source.id) && !(0, _source.isThirdParty)(source));
    for (const source of validSources) {
      if (cancelled) {
        return;
      }
      await dispatch((0, _loadSourceText.loadSourceText)({ cx, source }));
      await dispatch(searchSource(cx, source.id, query));
    }
    dispatch(updateSearchStatus(cx, _projectTextSearch.statusType.done));
  };

  search.cancel = () => {
    cancelled = true;
  };

  return search;
}

function searchSource(cx, sourceId, query) {
  return async ({ dispatch, getState }) => {
    const source = (0, _selectors.getSource)(getState(), sourceId);
    if (!source) {
      return;
    }

    const content = (0, _selectors.getSourceContent)(getState(), source.id);
    let matches = [];
    if (content && (0, _asyncValue.isFulfilled)(content) && content.value.type === "text") {
      matches = await (0, _search.findSourceMatches)(source.id, content.value, query);
    }
    if (!matches.length) {
      return;
    }
    dispatch(addSearchResult(cx, source.id, source.url, matches));
  };
}

/***/ }),
/* 677 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setQuickOpenQuery = setQuickOpenQuery;
exports.openQuickOpen = openQuickOpen;
exports.closeQuickOpen = closeQuickOpen;
function setQuickOpenQuery(query) {
  return {
    type: "SET_QUICK_OPEN_QUERY",
    query
  };
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function openQuickOpen(query) {
  if (query != null) {
    return { type: "OPEN_QUICK_OPEN", query };
  }
  return { type: "OPEN_QUICK_OPEN" };
}

function closeQuickOpen() {
  return { type: "CLOSE_QUICK_OPEN" };
}

/***/ }),
/* 678 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setExpandedState = setExpandedState;
exports.focusItem = focusItem;
function setExpandedState(expanded) {
  return { type: "SET_EXPANDED_STATE", expanded };
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */


function focusItem(item) {
  return { type: "SET_FOCUSED_SOURCE_ITEM", item };
}

/***/ }),
/* 679 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.openLink = openLink;
exports.openWorkerToolbox = openWorkerToolbox;
exports.evaluateInConsole = evaluateInConsole;
exports.openElementInInspectorCommand = openElementInInspectorCommand;
exports.highlightDomElement = highlightDomElement;
exports.unHighlightDomElement = unHighlightDomElement;


/**
 * @memberof actions/toolbox
 * @static
 */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function openLink(url) {
  return async function ({ panel }) {
    return panel.openLink(url);
  };
}

function openWorkerToolbox(worker) {
  return async function ({ getState, panel }) {
    return panel.openWorkerToolbox(worker);
  };
}

function evaluateInConsole(inputString) {
  return async ({ panel }) => {
    return panel.openConsoleAndEvaluate(inputString);
  };
}

function openElementInInspectorCommand(grip) {
  return async ({ panel }) => {
    return panel.openElementInInspector(grip);
  };
}

function highlightDomElement(grip) {
  return async ({ panel }) => {
    return panel.highlightDomElement(grip);
  };
}

function unHighlightDomElement(grip) {
  return async ({ panel }) => {
    return panel.unHighlightDomElement(grip);
  };
}

/***/ }),
/* 680 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updatePreview = updatePreview;
exports.setPreview = setPreview;
exports.clearPreview = clearPreview;

var _preview = __webpack_require__(681);

var _ast = __webpack_require__(519);

var _promise = __webpack_require__(500);

var _getExpression = __webpack_require__(682);

var _source = __webpack_require__(494);

var _selectors = __webpack_require__(490);

var _expressions = __webpack_require__(511);

function findExpressionMatch(state, codeMirror, tokenPos) {
  const source = (0, _selectors.getSelectedSource)(state);
  if (!source) {
    return;
  }

  const symbols = (0, _selectors.getSymbols)(state, source);

  let match;
  if (!symbols || symbols.loading) {
    match = (0, _getExpression.getExpressionFromCoords)(codeMirror, tokenPos);
  } else {
    match = (0, _ast.findBestMatchExpression)(symbols, tokenPos);
  }
  return match;
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function updatePreview(cx, target, tokenPos, codeMirror) {
  return ({ dispatch, getState, client, sourceMaps }) => {
    const cursorPos = target.getBoundingClientRect();

    if (!(0, _selectors.isSelectedFrameVisible)(getState()) || !(0, _selectors.isLineInScope)(getState(), tokenPos.line)) {
      return;
    }

    const match = findExpressionMatch(getState(), codeMirror, tokenPos);
    if (!match) {
      return;
    }

    const { expression, location } = match;

    if ((0, _preview.isConsole)(expression)) {
      return;
    }

    dispatch(setPreview(cx, expression, location, tokenPos, cursorPos));
  };
}

function setPreview(cx, expression, location, tokenPos, cursorPos) {
  return async ({ dispatch, getState, client, sourceMaps }) => {
    await dispatch({
      type: "SET_PREVIEW",
      cx,
      [_promise.PROMISE]: async function () {
        const source = (0, _selectors.getSelectedSource)(getState());
        if (!source) {
          return;
        }

        const thread = (0, _selectors.getCurrentThread)(getState());
        const selectedFrame = (0, _selectors.getSelectedFrame)(getState(), thread);

        if (location && (0, _source.isOriginal)(source)) {
          const mapResult = await dispatch((0, _expressions.getMappedExpression)(expression));
          if (mapResult) {
            expression = mapResult.expression;
          }
        }

        if (!selectedFrame) {
          return;
        }

        const { result } = await client.evaluateInFrame(expression, {
          frameId: selectedFrame.id,
          thread
        });

        // Error case occurs for a token that follows an errored evaluation
        // https://github.com/firefox-devtools/debugger/pull/8056
        // Accommodating for null allows us to show preview for falsy values
        // line "", false, null, Nan, and more
        if (result === null) {
          return;
        }

        // Handle cases where the result is invisible to the debugger
        // and not possible to preview. Bug 1548256
        if (result.class && result.class.includes("InvisibleToDebugger")) {
          return;
        }

        const root = {
          name: expression,
          path: expression,
          contents: { value: result }
        };
        const properties = await client.loadObjectProperties(root);

        return {
          expression,
          result,
          properties,
          root,
          location,
          tokenPos,
          cursorPos
        };
      }()
    });
  };
}

function clearPreview(cx) {
  return ({ dispatch, getState, client }) => {
    const currentSelection = (0, _selectors.getPreview)(getState());
    if (!currentSelection) {
      return;
    }

    return dispatch({
      type: "CLEAR_SELECTION",
      cx
    });
  };
}

/***/ }),
/* 681 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isConsole = isConsole;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function isConsole(expression) {
  return (/^console/.test(expression)
  );
}

/***/ }),
/* 682 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tokenAtTextPosition = tokenAtTextPosition;
exports.getExpressionFromCoords = getExpressionFromCoords;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function tokenAtTextPosition(cm, { line, column }) {
  if (line < 0 || line >= cm.lineCount()) {
    return null;
  }

  const token = cm.getTokenAt({ line: line - 1, ch: column });
  if (!token) {
    return null;
  }

  return { startColumn: token.start, endColumn: token.end, type: token.type };
}

// The strategy of querying codeMirror tokens was borrowed
// from Chrome's inital implementation in JavaScriptSourceFrame.js#L414
function getExpressionFromCoords(cm, coord) {
  const token = tokenAtTextPosition(cm, coord);
  if (!token) {
    return null;
  }

  let startHighlight = token.startColumn;
  const endHighlight = token.endColumn;
  const lineNumber = coord.line;
  const line = cm.doc.getLine(coord.line - 1);
  while (startHighlight > 1 && line.charAt(startHighlight - 1) === ".") {
    const tokenBefore = tokenAtTextPosition(cm, {
      line: coord.line,
      column: startHighlight - 2
    });

    if (!tokenBefore || !tokenBefore.type) {
      return null;
    }

    startHighlight = tokenBefore.startColumn;
  }

  const expression = line.substring(startHighlight, endHighlight) || "";

  if (!expression) {
    return null;
  }

  const location = {
    start: { line: lineNumber, column: startHighlight },
    end: { line: lineNumber, column: endHighlight }
  };
  return { expression, location };
}

/***/ }),
/* 683 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

__webpack_require__(684);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

class A11yIntention extends _react2.default.Component {
  constructor(...args) {
    var _temp;

    return _temp = super(...args), this.state = { keyboard: false }, this.handleKeyDown = () => {
      this.setState({ keyboard: true });
    }, this.handleMouseDown = () => {
      this.setState({ keyboard: false });
    }, _temp;
  }

  render() {
    return _react2.default.createElement(
      "div",
      {
        className: this.state.keyboard ? "A11y-keyboard" : "A11y-mouse",
        onKeyDown: this.handleKeyDown,
        onMouseDown: this.handleMouseDown
      },
      this.props.children
    );
  }
}
exports.default = A11yIntention;

/***/ }),
/* 684 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 685 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ShortcutsModal = undefined;

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _Modal = __webpack_require__(600);

var _Modal2 = _interopRequireDefault(_Modal);

var _classnames = __webpack_require__(67);

var _classnames2 = _interopRequireDefault(_classnames);

var _text = __webpack_require__(514);

__webpack_require__(687);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class ShortcutsModal extends _react.Component {
  renderPrettyCombos(combo) {
    return combo.split(" ").map(c => _react2.default.createElement(
      "span",
      { key: c, className: "keystroke" },
      c
    )).reduce((prev, curr) => [prev, " + ", curr]);
  }

  renderShorcutItem(title, combo) {
    return _react2.default.createElement(
      "li",
      null,
      _react2.default.createElement(
        "span",
        null,
        title
      ),
      _react2.default.createElement(
        "span",
        null,
        this.renderPrettyCombos(combo)
      )
    );
  }

  renderEditorShortcuts() {
    return _react2.default.createElement(
      "ul",
      { className: "shortcuts-list" },
      this.renderShorcutItem(L10N.getStr("shortcuts.toggleBreakpoint"), (0, _text.formatKeyShortcut)(L10N.getStr("toggleBreakpoint.key"))),
      this.renderShorcutItem(L10N.getStr("shortcuts.toggleCondPanel.breakpoint"), (0, _text.formatKeyShortcut)(L10N.getStr("toggleCondPanel.breakpoint.key"))),
      this.renderShorcutItem(L10N.getStr("shortcuts.toggleCondPanel.logPoint"), (0, _text.formatKeyShortcut)(L10N.getStr("toggleCondPanel.logPoint.key")))
    );
  }

  renderSteppingShortcuts() {
    return _react2.default.createElement(
      "ul",
      { className: "shortcuts-list" },
      this.renderShorcutItem(L10N.getStr("shortcuts.pauseOrResume"), "F8"),
      this.renderShorcutItem(L10N.getStr("shortcuts.stepOver"), "F10"),
      this.renderShorcutItem(L10N.getStr("shortcuts.stepIn"), "F11"),
      this.renderShorcutItem(L10N.getStr("shortcuts.stepOut"), (0, _text.formatKeyShortcut)(L10N.getStr("stepOut.key")))
    );
  }

  renderSearchShortcuts() {
    return _react2.default.createElement(
      "ul",
      { className: "shortcuts-list" },
      this.renderShorcutItem(L10N.getStr("shortcuts.fileSearch2"), (0, _text.formatKeyShortcut)(L10N.getStr("sources.search.key2"))),
      this.renderShorcutItem(L10N.getStr("shortcuts.searchAgain2"), (0, _text.formatKeyShortcut)(L10N.getStr("sourceSearch.search.again.key2"))),
      this.renderShorcutItem(L10N.getStr("shortcuts.projectSearch2"), (0, _text.formatKeyShortcut)(L10N.getStr("projectTextSearch.key"))),
      this.renderShorcutItem(L10N.getStr("shortcuts.functionSearch2"), (0, _text.formatKeyShortcut)(L10N.getStr("functionSearch.key"))),
      this.renderShorcutItem(L10N.getStr("shortcuts.gotoLine"), (0, _text.formatKeyShortcut)(L10N.getStr("gotoLineModal.key2")))
    );
  }

  renderShortcutsContent() {
    return _react2.default.createElement(
      "div",
      {
        className: (0, _classnames2.default)("shortcuts-content", this.props.additionalClass)
      },
      _react2.default.createElement(
        "div",
        { className: "shortcuts-section" },
        _react2.default.createElement(
          "h2",
          null,
          L10N.getStr("shortcuts.header.editor")
        ),
        this.renderEditorShortcuts()
      ),
      _react2.default.createElement(
        "div",
        { className: "shortcuts-section" },
        _react2.default.createElement(
          "h2",
          null,
          L10N.getStr("shortcuts.header.stepping")
        ),
        this.renderSteppingShortcuts()
      ),
      _react2.default.createElement(
        "div",
        { className: "shortcuts-section" },
        _react2.default.createElement(
          "h2",
          null,
          L10N.getStr("shortcuts.header.search")
        ),
        this.renderSearchShortcuts()
      )
    );
  }

  render() {
    const { enabled } = this.props;

    if (!enabled) {
      return null;
    }

    return _react2.default.createElement(
      _Modal2.default,
      {
        "in": enabled,
        additionalClass: "shortcuts-modal",
        handleClose: this.props.handleClose
      },
      this.renderShortcutsContent()
    );
  }
}
exports.ShortcutsModal = ShortcutsModal; /* This Source Code Form is subject to the terms of the Mozilla Public
                                          * License, v. 2.0. If a copy of the MPL was not distributed with this
                                          * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/***/ }),
/* 686 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 687 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 688 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 689 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 690 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 691 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 692 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 693 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ProjectSearch = undefined;

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _connect = __webpack_require__(491);

var _classnames = __webpack_require__(67);

var _classnames2 = _interopRequireDefault(_classnames);

var _actions = __webpack_require__(493);

var _actions2 = _interopRequireDefault(_actions);

var _editor = __webpack_require__(496);

var _projectSearch = __webpack_require__(694);

var _projectTextSearch = __webpack_require__(532);

var _sourcesTree = __webpack_require__(526);

var _selectors = __webpack_require__(490);

var _ManagedTree = __webpack_require__(601);

var _ManagedTree2 = _interopRequireDefault(_ManagedTree);

var _SearchInput = __webpack_require__(553);

var _SearchInput2 = _interopRequireDefault(_SearchInput);

var _AccessibleImage = __webpack_require__(495);

var _AccessibleImage2 = _interopRequireDefault(_AccessibleImage);

__webpack_require__(703);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function getFilePath(item, index) {
  return item.type === "RESULT" ? `${item.sourceId}-${index || "$"}` : `${item.sourceId}-${item.line}-${item.column}-${index || "$"}`;
}

function sanitizeQuery(query) {
  // no '\' at end of query
  return query.replace(/\\$/, "");
}

class ProjectSearch extends _react.Component {
  constructor(props) {
    super(props);

    this.toggleProjectTextSearch = (key, e) => {
      const { cx, closeProjectSearch, setActiveSearch } = this.props;
      if (e) {
        e.preventDefault();
      }

      if (this.isProjectSearchEnabled()) {
        return closeProjectSearch(cx);
      }

      return setActiveSearch("project");
    };

    this.isProjectSearchEnabled = () => this.props.activeSearch === "project";

    this.selectMatchItem = matchItem => {
      this.props.selectSpecificLocation(this.props.cx, {
        sourceId: matchItem.sourceId,
        line: matchItem.line,
        column: matchItem.column
      });
      this.props.doSearchForHighlight(this.state.inputValue, (0, _editor.getEditor)(), matchItem.line, matchItem.column);
    };

    this.getResultCount = () => this.props.results.reduce((count, file) => count + file.matches.length, 0);

    this.onKeyDown = e => {
      if (e.key === "Escape") {
        return;
      }

      e.stopPropagation();

      if (e.key !== "Enter") {
        return;
      }
      this.setState({ focusedItem: null });
      const query = sanitizeQuery(this.state.inputValue);
      if (query) {
        this.doSearch(query);
      }
    };

    this.onHistoryScroll = query => {
      this.setState({ inputValue: query });
    };

    this.onEnterPress = () => {
      if (!this.isProjectSearchEnabled() || !this.state.focusedItem) {
        return;
      }
      if (this.state.focusedItem.type === "MATCH") {
        this.selectMatchItem(this.state.focusedItem);
      }
    };

    this.onFocus = item => {
      if (this.state.focusedItem !== item) {
        this.setState({ focusedItem: item });
      }
    };

    this.inputOnChange = e => {
      const inputValue = e.target.value;
      const { cx, clearSearch } = this.props;
      this.setState({ inputValue });
      if (inputValue === "") {
        clearSearch(cx);
      }
    };

    this.renderFile = (file, focused, expanded) => {
      const matchesLength = file.matches.length;
      const matches = ` (${matchesLength} match${matchesLength > 1 ? "es" : ""})`;

      return _react2.default.createElement(
        "div",
        {
          className: (0, _classnames2.default)("file-result", { focused }),
          key: file.sourceId
        },
        _react2.default.createElement(_AccessibleImage2.default, { className: (0, _classnames2.default)("arrow", { expanded }) }),
        _react2.default.createElement(_AccessibleImage2.default, { className: "file" }),
        _react2.default.createElement(
          "span",
          { className: "file-path" },
          (0, _sourcesTree.getRelativePath)(file.filepath)
        ),
        _react2.default.createElement(
          "span",
          { className: "matches-summary" },
          matches
        )
      );
    };

    this.renderMatch = (match, focused) => {
      return _react2.default.createElement(
        "div",
        {
          className: (0, _classnames2.default)("result", { focused }),
          onClick: () => setTimeout(() => this.selectMatchItem(match), 50)
        },
        _react2.default.createElement(
          "span",
          { className: "line-number", key: match.line },
          match.line
        ),
        (0, _projectSearch.highlightMatches)(match)
      );
    };

    this.renderItem = (item, depth, focused, _, expanded) => {
      if (item.type === "RESULT") {
        return this.renderFile(item, focused, expanded);
      }
      return this.renderMatch(item, focused);
    };

    this.renderResults = () => {
      const { status, results } = this.props;
      if (!this.props.query) {
        return;
      }
      if (results.length) {
        return _react2.default.createElement(_ManagedTree2.default, {
          getRoots: () => results,
          getChildren: file => file.matches || [],
          itemHeight: 24,
          autoExpandAll: true,
          autoExpandDepth: 1,
          autoExpandNodeChildrenLimit: 100,
          getParent: item => null,
          getPath: getFilePath,
          renderItem: this.renderItem,
          focused: this.state.focusedItem,
          onFocus: this.onFocus
        });
      }
      const msg = status === _projectTextSearch.statusType.fetching ? L10N.getStr("loadingText") : L10N.getStr("projectTextSearch.noResults");
      return _react2.default.createElement(
        "div",
        { className: "no-result-msg absolute-center" },
        msg
      );
    };

    this.renderSummary = () => {
      return this.props.query !== "" ? L10N.getFormatStr("sourceSearch.resultsSummary1", this.getResultCount()) : "";
    };

    this.state = {
      inputValue: this.props.query || "",
      focusedItem: null
    };
  }

  componentDidMount() {
    const { shortcuts } = this.context;

    shortcuts.on(L10N.getStr("projectTextSearch.key"), this.toggleProjectTextSearch);
    shortcuts.on("Enter", this.onEnterPress);
  }

  componentWillUnmount() {
    const { shortcuts } = this.context;
    shortcuts.off(L10N.getStr("projectTextSearch.key"), this.toggleProjectTextSearch);
    shortcuts.off("Enter", this.onEnterPress);
  }

  componentDidUpdate(prevProps) {
    // If the query changes in redux, also change it in the UI
    if (prevProps.query !== this.props.query) {
      this.setState({ inputValue: this.props.query });
    }
  }

  doSearch(searchTerm) {
    this.props.searchSources(this.props.cx, searchTerm);
  }

  shouldShowErrorEmoji() {
    return !this.getResultCount() && this.props.status === _projectTextSearch.statusType.done;
  }

  renderInput() {
    const { status } = this.props;
    return _react2.default.createElement(_SearchInput2.default, {
      query: this.state.inputValue,
      count: this.getResultCount(),
      placeholder: L10N.getStr("projectTextSearch.placeholder"),
      size: "big",
      showErrorEmoji: this.shouldShowErrorEmoji(),
      summaryMsg: this.renderSummary(),
      isLoading: status === _projectTextSearch.statusType.fetching,
      onChange: this.inputOnChange,
      onKeyDown: this.onKeyDown,
      onHistoryScroll: this.onHistoryScroll,
      handleClose:
      // TODO - This function doesn't quite match the signature.
      this.props.closeProjectSearch,
      ref: "searchInput"
    });
  }

  render() {
    if (!this.isProjectSearchEnabled()) {
      return null;
    }

    return _react2.default.createElement(
      "div",
      { className: "search-container" },
      _react2.default.createElement(
        "div",
        { className: "project-text-search" },
        _react2.default.createElement(
          "div",
          { className: "header" },
          this.renderInput()
        ),
        this.renderResults()
      )
    );
  }
}
exports.ProjectSearch = ProjectSearch;
ProjectSearch.contextTypes = {
  shortcuts: _propTypes2.default.object
};

const mapStateToProps = state => ({
  cx: (0, _selectors.getContext)(state),
  activeSearch: (0, _selectors.getActiveSearch)(state),
  results: (0, _selectors.getTextSearchResults)(state),
  query: (0, _selectors.getTextSearchQuery)(state),
  status: (0, _selectors.getTextSearchStatus)(state)
});

exports.default = (0, _connect.connect)(mapStateToProps, {
  closeProjectSearch: _actions2.default.closeProjectSearch,
  searchSources: _actions2.default.searchSources,
  clearSearch: _actions2.default.clearSearch,
  selectSpecificLocation: _actions2.default.selectSpecificLocation,
  setActiveSearch: _actions2.default.setActiveSearch,
  doSearchForHighlight: _actions2.default.doSearchForHighlight
})(ProjectSearch);

/***/ }),
/* 694 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.highlightMatches = highlightMatches;

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function highlightMatches(lineMatch) {
  const { value, matchIndex, match } = lineMatch;
  const len = match.length;

  return _react2.default.createElement(
    "span",
    { className: "line-value" },
    _react2.default.createElement(
      "span",
      { className: "line-match", key: 0 },
      value.slice(0, matchIndex)
    ),
    _react2.default.createElement(
      "span",
      { className: "query-match", key: 1 },
      value.substr(matchIndex, len)
    ),
    _react2.default.createElement(
      "span",
      { className: "line-match", key: 2 },
      value.slice(matchIndex + len, value.length)
    )
  );
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// Maybe reuse file search's functions?

/***/ }),
/* 695 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 696 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _AccessibleImage = __webpack_require__(495);

var _AccessibleImage2 = _interopRequireDefault(_AccessibleImage);

__webpack_require__(698);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function CloseButton({ handleClick, buttonClass, tooltip }) {
  return _react2.default.createElement(
    "button",
    {
      className: buttonClass ? `close-btn ${buttonClass}` : "close-btn",
      onClick: handleClick,
      title: tooltip
    },
    _react2.default.createElement(_AccessibleImage2.default, { className: "close" })
  );
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

exports.default = CloseButton;

/***/ }),
/* 697 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 698 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 699 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 700 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(67);

var _classnames2 = _interopRequireDefault(_classnames);

var _AccessibleImage = __webpack_require__(495);

var _AccessibleImage2 = _interopRequireDefault(_AccessibleImage);

var _ = __webpack_require__(502);

__webpack_require__(701);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class PaneToggleButton extends _react.PureComponent {

  label(position, collapsed) {
    switch (position) {
      case "start":
        return L10N.getStr(collapsed ? "expandSources" : "collapseSources");
      case "end":
        return L10N.getStr(collapsed ? "expandBreakpoints" : "collapseBreakpoints");
    }
  }

  render() {
    const { position, collapsed, horizontal, handleClick } = this.props;

    return _react2.default.createElement(
      _.CommandBarButton,
      {
        className: (0, _classnames2.default)("toggle-button", position, {
          collapsed,
          vertical: !horizontal
        }),
        onClick: () => handleClick(position, !collapsed),
        title: this.label(position, collapsed)
      },
      _react2.default.createElement(_AccessibleImage2.default, {
        className: collapsed ? "pane-expand" : "pane-collapse"
      })
    );
  }
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

PaneToggleButton.defaultProps = {
  horizontal: false,
  position: "start"
};
exports.default = PaneToggleButton;

/***/ }),
/* 701 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 702 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 703 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 704 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(67);

var _classnames2 = _interopRequireDefault(_classnames);

var _tabs = __webpack_require__(438);

var _actions = __webpack_require__(493);

var _actions2 = _interopRequireDefault(_actions);

var _selectors = __webpack_require__(490);

var _prefs = __webpack_require__(492);

var _connect = __webpack_require__(491);

var _text = __webpack_require__(514);

var _Outline = __webpack_require__(705);

var _Outline2 = _interopRequireDefault(_Outline);

var _SourcesTree = __webpack_require__(711);

var _SourcesTree2 = _interopRequireDefault(_SourcesTree);

var _AccessibleImage = __webpack_require__(495);

var _AccessibleImage2 = _interopRequireDefault(_AccessibleImage);

__webpack_require__(714);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

class PrimaryPanes extends _react.Component {
  constructor(props) {
    super(props);

    this.showPane = selectedPane => {
      this.props.setPrimaryPaneTab(selectedPane);
    };

    this.onAlphabetizeClick = () => {
      const alphabetizeOutline = !_prefs.prefs.alphabetizeOutline;
      _prefs.prefs.alphabetizeOutline = alphabetizeOutline;
      this.setState({ alphabetizeOutline });
    };

    this.onActivateTab = index => {
      if (index === 0) {
        this.showPane("sources");
      } else {
        this.showPane("outline");
      }
    };

    this.state = {
      alphabetizeOutline: _prefs.prefs.alphabetizeOutline
    };
  }

  renderOutlineTabs() {
    if (!_prefs.features.outline) {
      return;
    }

    const sources = (0, _text.formatKeyShortcut)(L10N.getStr("sources.header"));
    const outline = (0, _text.formatKeyShortcut)(L10N.getStr("outline.header"));
    const isSources = this.props.selectedTab === "sources";
    const isOutline = this.props.selectedTab === "outline";

    return [_react2.default.createElement(
      _tabs.Tab,
      {
        className: (0, _classnames2.default)("tab sources-tab", { active: isSources }),
        key: "sources-tab"
      },
      sources
    ), _react2.default.createElement(
      _tabs.Tab,
      {
        className: (0, _classnames2.default)("tab outline-tab", { active: isOutline }),
        key: "outline-tab"
      },
      outline
    )];
  }

  renderProjectRootHeader() {
    const { cx, projectRoot } = this.props;

    if (!projectRoot) {
      return null;
    }

    const rootLabel = projectRoot.split("/").pop();

    return _react2.default.createElement(
      "div",
      { key: "root", className: "sources-clear-root-container" },
      _react2.default.createElement(
        "button",
        {
          className: "sources-clear-root",
          onClick: () => this.props.clearProjectDirectoryRoot(cx),
          title: L10N.getStr("removeDirectoryRoot.label")
        },
        _react2.default.createElement(_AccessibleImage2.default, { className: "home" }),
        _react2.default.createElement(_AccessibleImage2.default, { className: "breadcrumb" }),
        _react2.default.createElement(
          "span",
          { className: "sources-clear-root-label" },
          rootLabel
        )
      )
    );
  }

  renderThreadSources() {
    return _react2.default.createElement(_SourcesTree2.default, { threads: this.props.threads });
  }

  render() {
    const { selectedTab, projectRoot } = this.props;
    const activeIndex = selectedTab === "sources" ? 0 : 1;

    return _react2.default.createElement(
      _tabs.Tabs,
      {
        activeIndex: activeIndex,
        className: "sources-panel",
        onActivateTab: this.onActivateTab
      },
      _react2.default.createElement(
        _tabs.TabList,
        { className: "source-outline-tabs" },
        this.renderOutlineTabs()
      ),
      _react2.default.createElement(
        _tabs.TabPanels,
        {
          className: (0, _classnames2.default)("source-outline-panel", {
            "has-root": projectRoot
          }),
          hasFocusableContent: true
        },
        _react2.default.createElement(
          "div",
          { className: "threads-list" },
          this.renderProjectRootHeader(),
          this.renderThreadSources()
        ),
        _react2.default.createElement(_Outline2.default, {
          alphabetizeOutline: this.state.alphabetizeOutline,
          onAlphabetizeClick: this.onAlphabetizeClick
        })
      )
    );
  }
}

const mapStateToProps = state => ({
  cx: (0, _selectors.getContext)(state),
  selectedTab: (0, _selectors.getSelectedPrimaryPaneTab)(state),
  sources: (0, _selectors.getDisplayedSources)(state),
  sourceSearchOn: (0, _selectors.getActiveSearch)(state) === "source",
  threads: (0, _selectors.getThreads)(state),
  projectRoot: (0, _selectors.getProjectDirectoryRoot)(state)
});

const connector = (0, _connect.connect)(mapStateToProps, {
  setPrimaryPaneTab: _actions2.default.setPrimaryPaneTab,
  setActiveSearch: _actions2.default.setActiveSearch,
  closeActiveSearch: _actions2.default.closeActiveSearch,
  clearProjectDirectoryRoot: _actions2.default.clearProjectDirectoryRoot
});

exports.default = connector(PrimaryPanes);

/***/ }),
/* 705 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Outline = undefined;

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _devtoolsContextmenu = __webpack_require__(420);

var _connect = __webpack_require__(491);

var _fuzzaldrinPlus = __webpack_require__(432);

var _clipboard = __webpack_require__(512);

var _function = __webpack_require__(706);

var _actions = __webpack_require__(493);

var _actions2 = _interopRequireDefault(_actions);

var _selectors = __webpack_require__(490);

var _OutlineFilter = __webpack_require__(707);

var _OutlineFilter2 = _interopRequireDefault(_OutlineFilter);

__webpack_require__(709);

var _PreviewFunction = __webpack_require__(602);

var _PreviewFunction2 = _interopRequireDefault(_PreviewFunction);

var _lodash = __webpack_require__(417);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Check whether the name argument matches the fuzzy filter argument
 */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const filterOutlineItem = (name, filter) => {
  // Set higher to make the fuzzaldrin filter more specific
  const FUZZALDRIN_FILTER_THRESHOLD = 15000;
  if (!filter) {
    return true;
  }

  if (filter.length === 1) {
    // when filter is a single char just check if it starts with the char
    return filter.toLowerCase() === name.toLowerCase()[0];
  }
  return (0, _fuzzaldrinPlus.score)(name, filter) > FUZZALDRIN_FILTER_THRESHOLD;
};

class Outline extends _react.Component {
  constructor(props) {
    super(props);
    this.updateFilter = this.updateFilter.bind(this);
    this.state = { filter: "" };
  }

  selectItem(location) {
    const { cx, selectedSource, selectLocation } = this.props;
    if (!selectedSource) {
      return;
    }

    selectLocation(cx, {
      sourceId: selectedSource.id,
      line: location.start.line,
      column: location.start.column
    });
  }

  onContextMenu(event, func) {
    event.stopPropagation();
    event.preventDefault();

    const {
      selectedSource,
      getFunctionText,
      flashLineRange,
      selectedLocation
    } = this.props;

    const copyFunctionKey = L10N.getStr("copyFunction.accesskey");
    const copyFunctionLabel = L10N.getStr("copyFunction.label");

    if (!selectedSource) {
      return;
    }

    const sourceLine = func.location.start.line;
    const functionText = getFunctionText(sourceLine);

    const copyFunctionItem = {
      id: "node-menu-copy-function",
      label: copyFunctionLabel,
      accesskey: copyFunctionKey,
      disabled: !functionText,
      click: () => {
        flashLineRange({
          start: func.location.start.line,
          end: func.location.end.line,
          sourceId: selectedLocation.sourceId
        });
        return (0, _clipboard.copyToTheClipboard)(functionText);
      }
    };
    const menuOptions = [copyFunctionItem];
    (0, _devtoolsContextmenu.showMenu)(event, menuOptions);
  }

  updateFilter(filter) {
    this.setState({ filter: filter.trim() });
  }

  renderPlaceholder() {
    const placeholderMessage = this.props.selectedSource ? L10N.getStr("outline.noFunctions") : L10N.getStr("outline.noFileSelected");

    return _react2.default.createElement(
      "div",
      { className: "outline-pane-info" },
      placeholderMessage
    );
  }

  renderLoading() {
    return _react2.default.createElement(
      "div",
      { className: "outline-pane-info" },
      L10N.getStr("loadingText")
    );
  }

  renderFunction(func) {
    const { name, location, parameterNames } = func;

    return _react2.default.createElement(
      "li",
      {
        key: `${name}:${location.start.line}:${location.start.column}`,
        className: "outline-list__element",
        onClick: () => this.selectItem(location),
        onContextMenu: e => this.onContextMenu(e, func)
      },
      _react2.default.createElement(
        "span",
        { className: "outline-list__element-icon" },
        "\u03BB"
      ),
      _react2.default.createElement(_PreviewFunction2.default, { func: { name, parameterNames } })
    );
  }

  renderClassFunctions(klass, functions) {
    if (klass == null || functions.length == 0) {
      return null;
    }

    const classFunc = functions.find(func => func.name === klass);
    const classFunctions = functions.filter(func => func.klass === klass);
    const classInfo = this.props.symbols.classes.find(c => c.name === klass);

    const heading = classFunc ? _react2.default.createElement(
      "h2",
      null,
      this.renderFunction(classFunc)
    ) : _react2.default.createElement(
      "h2",
      {
        onClick: classInfo ? () => this.selectItem(classInfo.location) : null
      },
      _react2.default.createElement(
        "span",
        { className: "keyword" },
        "class"
      ),
      " ",
      klass
    );

    return _react2.default.createElement(
      "li",
      { className: "outline-list__class", key: klass },
      heading,
      _react2.default.createElement(
        "ul",
        { className: "outline-list__class-list" },
        classFunctions.map(func => this.renderFunction(func))
      )
    );
  }

  renderFunctions(functions) {
    const { filter } = this.state;
    let classes = (0, _lodash.uniq)(functions.map(func => func.klass));
    let namedFunctions = functions.filter(func => filterOutlineItem(func.name, filter) && !func.klass && !classes.includes(func.name));

    let classFunctions = functions.filter(func => filterOutlineItem(func.name, filter) && !!func.klass);

    if (this.props.alphabetizeOutline) {
      namedFunctions = (0, _lodash.sortBy)(namedFunctions, "name");
      classes = (0, _lodash.sortBy)(classes, "klass");
      classFunctions = (0, _lodash.sortBy)(classFunctions, "name");
    }

    return _react2.default.createElement(
      "ul",
      { className: "outline-list devtools-monospace" },
      namedFunctions.map(func => this.renderFunction(func)),
      classes.map(klass => this.renderClassFunctions(klass, classFunctions))
    );
  }

  renderFooter() {
    return _react2.default.createElement(
      "div",
      { className: "outline-footer bottom" },
      _react2.default.createElement(
        "button",
        {
          onClick: this.props.onAlphabetizeClick,
          className: this.props.alphabetizeOutline ? "active" : ""
        },
        L10N.getStr("outline.sortLabel")
      )
    );
  }

  render() {
    const { symbols, selectedSource } = this.props;
    const { filter } = this.state;

    if (!selectedSource) {
      return this.renderPlaceholder();
    }

    if (!symbols || symbols.loading) {
      return this.renderLoading();
    }

    const symbolsToDisplay = symbols.functions.filter(func => func.name != "anonymous");

    if (symbolsToDisplay.length === 0) {
      return this.renderPlaceholder();
    }

    return _react2.default.createElement(
      "div",
      { className: "outline" },
      _react2.default.createElement(
        "div",
        null,
        _react2.default.createElement(_OutlineFilter2.default, { filter: filter, updateFilter: this.updateFilter }),
        this.renderFunctions(symbolsToDisplay),
        this.renderFooter()
      )
    );
  }
}

exports.Outline = Outline;
const mapStateToProps = state => {
  const selectedSource = (0, _selectors.getSelectedSourceWithContent)(state);
  const symbols = selectedSource ? (0, _selectors.getSymbols)(state, selectedSource.source) : null;

  return {
    cx: (0, _selectors.getContext)(state),
    symbols,
    selectedSource: selectedSource && selectedSource.source,
    selectedLocation: (0, _selectors.getSelectedLocation)(state),
    getFunctionText: line => {
      if (selectedSource) {
        return (0, _function.findFunctionText)(line, selectedSource, symbols);
      }

      return null;
    }
  };
};

exports.default = (0, _connect.connect)(mapStateToProps, {
  selectLocation: _actions2.default.selectLocation,
  flashLineRange: _actions2.default.flashLineRange
})(Outline);

/***/ }),
/* 706 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findFunctionText = findFunctionText;

var _asyncValue = __webpack_require__(497);

var _ast = __webpack_require__(519);

var _indentation = __webpack_require__(536);

function findFunctionText(line, { source, content }, symbols) {
  const func = (0, _ast.findClosestFunction)(symbols, {
    sourceId: source.id,
    line,
    column: Infinity
  });

  if (source.isWasm || !func || !content || !(0, _asyncValue.isFulfilled)(content) || content.value.type !== "text") {
    return null;
  }

  const {
    location: { start, end }
  } = func;
  const lines = content.value.value.split("\n");
  const firstLine = lines[start.line - 1].slice(start.column);
  const lastLine = lines[end.line - 1].slice(0, end.column);
  const middle = lines.slice(start.line, end.line - 1);
  const functionText = [firstLine, ...middle, lastLine].join("\n");
  const indentedFunctionText = (0, _indentation.correctIndentation)(functionText);

  return indentedFunctionText;
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/***/ }),
/* 707 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(67);

var _classnames2 = _interopRequireDefault(_classnames);

__webpack_require__(708);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class OutlineFilter extends _react.Component {
  constructor(...args) {
    var _temp;

    return _temp = super(...args), this.state = { focused: false }, this.setFocus = shouldFocus => {
      this.setState({ focused: shouldFocus });
    }, this.onChange = e => {
      this.props.updateFilter(e.target.value);
    }, this.onKeyDown = e => {
      if (e.key === "Escape" && this.props.filter !== "") {
        // use preventDefault to override toggling the split-console which is
        // also bound to the ESC key
        e.preventDefault();
        this.props.updateFilter("");
      } else if (e.key === "Enter") {
        // We must prevent the form submission from taking any action
        // https://github.com/firefox-devtools/debugger/pull/7308
        e.preventDefault();
      }
    }, _temp;
  }

  render() {
    const { focused } = this.state;
    return _react2.default.createElement(
      "div",
      { className: "outline-filter" },
      _react2.default.createElement(
        "form",
        null,
        _react2.default.createElement("input", {
          className: (0, _classnames2.default)("outline-filter-input", { focused }),
          onFocus: () => this.setFocus(true),
          onBlur: () => this.setFocus(false),
          placeholder: L10N.getStr("outline.placeholder"),
          value: this.props.filter,
          type: "text",
          onChange: this.onChange,
          onKeyDown: this.onKeyDown
        })
      )
    );
  }
}
exports.default = OutlineFilter; /* This Source Code Form is subject to the terms of the Mozilla Public
                                  * License, v. 2.0. If a copy of the MPL was not distributed with this
                                  * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/***/ }),
/* 708 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 709 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 710 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 711 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(67);

var _classnames2 = _interopRequireDefault(_classnames);

var _connect = __webpack_require__(491);

var _selectors = __webpack_require__(490);

var _sources = __webpack_require__(498);

var _actions = __webpack_require__(493);

var _actions2 = _interopRequireDefault(_actions);

var _SourcesTreeItem = __webpack_require__(712);

var _SourcesTreeItem2 = _interopRequireDefault(_SourcesTreeItem);

var _ManagedTree = __webpack_require__(601);

var _ManagedTree2 = _interopRequireDefault(_ManagedTree);

var _sourcesTree = __webpack_require__(526);

var _url = __webpack_require__(515);

var _source = __webpack_require__(494);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Actions


// Selectors
function shouldAutoExpand(depth, item, debuggeeUrl) {
  if (depth !== 1) {
    return false;
  }

  const { host } = (0, _url.parse)(debuggeeUrl);
  return item.name === host;
}

// Utils


// Components
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// Dependencies


class SourcesTree extends _react.Component {
  constructor(props) {
    super(props);

    _initialiseProps.call(this);

    const { debuggeeUrl, sources, threads } = this.props;

    this.state = (0, _sourcesTree.createTree)({
      debuggeeUrl,
      sources,
      threads
    });
  }

  componentWillReceiveProps(nextProps) {
    const {
      projectRoot,
      debuggeeUrl,
      sources,
      shownSource,
      selectedSource,
      threads
    } = this.props;
    const { uncollapsedTree, sourceTree } = this.state;

    if (projectRoot != nextProps.projectRoot || debuggeeUrl != nextProps.debuggeeUrl || threads != nextProps.threads || nextProps.sourceCount === 0) {
      // early recreate tree because of changes
      // to project root, debuggee url or lack of sources
      return this.setState((0, _sourcesTree.createTree)({
        sources: nextProps.sources,
        debuggeeUrl: nextProps.debuggeeUrl,
        threads: nextProps.threads
      }));
    }

    if (nextProps.shownSource && nextProps.shownSource != shownSource) {
      const listItems = (0, _sourcesTree.getDirectories)(nextProps.shownSource, sourceTree);
      return this.setState({ listItems });
    }

    if (nextProps.selectedSource && nextProps.selectedSource != selectedSource) {
      const highlightItems = (0, _sourcesTree.getDirectories)(nextProps.selectedSource, sourceTree);
      this.setState({ highlightItems });
    }

    // NOTE: do not run this every time a source is clicked,
    // only when a new source is added
    if (nextProps.sources != this.props.sources) {
      this.setState((0, _sourcesTree.updateTree)({
        newSources: nextProps.sources,
        threads: nextProps.threads,
        prevSources: sources,
        debuggeeUrl,
        uncollapsedTree,
        sourceTree
      }));
    }
  }

  // NOTE: we get the source from sources because item.contents is cached
  getSource(item) {
    return (0, _sourcesTree.getSourceFromNode)(item);
  }

  isEmpty() {
    const { sourceTree } = this.state;
    return sourceTree.contents.length === 0;
  }

  renderEmptyElement(message) {
    return _react2.default.createElement(
      "div",
      { key: "empty", className: "no-sources-message" },
      message
    );
  }

  renderTree() {
    const { expanded, focused } = this.props;

    const { highlightItems, listItems, parentMap } = this.state;

    const treeProps = {
      autoExpandAll: false,
      autoExpandDepth: 1,
      expanded,
      focused,
      getChildren: this.getChildren,
      getParent: item => parentMap.get(item),
      getPath: this.getPath,
      getRoots: this.getRoots,
      highlightItems,
      itemHeight: 21,
      key: this.isEmpty() ? "empty" : "full",
      listItems,
      onCollapse: this.onCollapse,
      onExpand: this.onExpand,
      onFocus: this.onFocus,
      onActivate: this.onActivate,
      renderItem: this.renderItem,
      preventBlur: true
    };

    return _react2.default.createElement(_ManagedTree2.default, treeProps);
  }

  renderPane(...children) {
    const { projectRoot } = this.props;

    return _react2.default.createElement(
      "div",
      {
        key: "pane",
        className: (0, _classnames2.default)("sources-pane", {
          "sources-list-custom-root": projectRoot
        })
      },
      children
    );
  }

  render() {
    return this.renderPane(this.isEmpty() ? this.renderEmptyElement(L10N.getStr("noSourcesText")) : _react2.default.createElement(
      "div",
      { key: "tree", className: "sources-list" },
      this.renderTree()
    ));
  }
}

var _initialiseProps = function () {
  this.selectItem = item => {
    if (item.type == "source" && !Array.isArray(item.contents)) {
      this.props.selectSource(this.props.cx, item.contents.id);
    }
  };

  this.onFocus = item => {
    this.props.focusItem(item);
  };

  this.onActivate = item => {
    this.selectItem(item);
  };

  this.getPath = item => {
    const { path } = item;
    const source = this.getSource(item);

    if (!source || (0, _sourcesTree.isDirectory)(item)) {
      return path;
    }

    const blackBoxedPart = source.isBlackBoxed ? ":blackboxed" : "";

    return `${path}/${source.id}/${blackBoxedPart}`;
  };

  this.onExpand = (item, expandedState) => {
    this.props.setExpandedState(expandedState);
  };

  this.onCollapse = (item, expandedState) => {
    this.props.setExpandedState(expandedState);
  };

  this.getRoots = () => {
    const { projectRoot } = this.props;
    const { sourceTree } = this.state;

    const sourceContents = sourceTree.contents[0];
    const rootLabel = projectRoot.split("/").pop();

    // The "sourceTree.contents[0]" check ensures that there are contents
    // A custom root with no existing sources will be ignored
    if (projectRoot && sourceContents) {
      if (sourceContents && sourceContents.name !== rootLabel) {
        return sourceContents.contents[0].contents;
      }
      return sourceContents.contents;
    }

    return sourceTree.contents;
  };

  this.getChildren = item => {
    return (0, _sourcesTree.nodeHasChildren)(item) ? item.contents : [];
  };

  this.renderItem = (item, depth, focused, _, expanded, { setExpanded }) => {
    const { debuggeeUrl, projectRoot, threads } = this.props;

    return _react2.default.createElement(_SourcesTreeItem2.default, {
      item: item,
      threads: threads,
      depth: depth,
      focused: focused,
      autoExpand: shouldAutoExpand(depth, item, debuggeeUrl),
      expanded: expanded,
      focusItem: this.onFocus,
      selectItem: this.selectItem,
      source: this.getSource(item),
      debuggeeUrl: debuggeeUrl,
      projectRoot: projectRoot,
      setExpanded: setExpanded
    });
  };
};

function getSourceForTree(state, displayedSources, source) {
  if (!source) {
    return null;
  }

  if (!source || !source.isPrettyPrinted) {
    return source;
  }

  return (0, _sources.getGeneratedSourceByURL)(state, (0, _source.getRawSourceURL)(source.url));
}

const mapStateToProps = (state, props) => {
  const selectedSource = (0, _selectors.getSelectedSource)(state);
  const shownSource = (0, _selectors.getShownSource)(state);
  const displayedSources = (0, _selectors.getDisplayedSources)(state);

  return {
    threads: props.threads,
    cx: (0, _selectors.getContext)(state),
    shownSource: getSourceForTree(state, displayedSources, shownSource),
    selectedSource: getSourceForTree(state, displayedSources, selectedSource),
    debuggeeUrl: (0, _selectors.getDebuggeeUrl)(state),
    expanded: (0, _selectors.getExpandedState)(state),
    focused: (0, _selectors.getFocusedSourceItem)(state),
    projectRoot: (0, _selectors.getProjectDirectoryRoot)(state),
    sources: displayedSources,
    sourceCount: Object.values(displayedSources).length
  };
};

exports.default = (0, _connect.connect)(mapStateToProps, {
  selectSource: _actions2.default.selectSource,
  setExpandedState: _actions2.default.setExpandedState,
  focusItem: _actions2.default.focusItem
})(SourcesTree);

/***/ }),
/* 712 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _connect = __webpack_require__(491);

var _classnames = __webpack_require__(67);

var _classnames2 = _interopRequireDefault(_classnames);

var _devtoolsContextmenu = __webpack_require__(420);

var _SourceIcon = __webpack_require__(555);

var _SourceIcon2 = _interopRequireDefault(_SourceIcon);

var _AccessibleImage = __webpack_require__(495);

var _AccessibleImage2 = _interopRequireDefault(_AccessibleImage);

var _workers = __webpack_require__(531);

var _selectors = __webpack_require__(490);

var _actions = __webpack_require__(493);

var _actions2 = _interopRequireDefault(_actions);

var _source = __webpack_require__(494);

var _sourcesTree = __webpack_require__(526);

var _clipboard = __webpack_require__(512);

var _prefs = __webpack_require__(492);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class SourceTreeItem extends _react.Component {
  constructor(...args) {
    var _temp;

    return _temp = super(...args), this.onClick = e => {
      const { item, focusItem, selectItem } = this.props;

      focusItem(item);
      if (!(0, _sourcesTree.isDirectory)(item)) {
        selectItem(item);
      }
    }, this.onContextMenu = (event, item) => {
      const copySourceUri2Label = L10N.getStr("copySourceUri2");
      const copySourceUri2Key = L10N.getStr("copySourceUri2.accesskey");
      const setDirectoryRootLabel = L10N.getStr("setDirectoryRoot.label");
      const setDirectoryRootKey = L10N.getStr("setDirectoryRoot.accesskey");
      const removeDirectoryRootLabel = L10N.getStr("removeDirectoryRoot.label");

      event.stopPropagation();
      event.preventDefault();

      const menuOptions = [];

      if (!(0, _sourcesTree.isDirectory)(item)) {
        // Flow requires some extra handling to ensure the value of contents.
        const { contents } = item;

        if (!Array.isArray(contents)) {
          const copySourceUri2 = {
            id: "node-menu-copy-source",
            label: copySourceUri2Label,
            accesskey: copySourceUri2Key,
            disabled: false,
            click: () => (0, _clipboard.copyToTheClipboard)(contents.url)
          };

          const { cx, source } = this.props;
          if (source) {
            const blackBoxMenuItem = {
              id: "node-menu-blackbox",
              label: source.isBlackBoxed ? L10N.getStr("sourceFooter.unblackbox") : L10N.getStr("sourceFooter.blackbox"),
              accesskey: L10N.getStr("sourceFooter.blackbox.accesskey"),
              disabled: !(0, _source.shouldBlackbox)(source),
              click: () => this.props.toggleBlackBox(cx, source)
            };
            menuOptions.push(copySourceUri2, blackBoxMenuItem);
          }
        }
      }

      if ((0, _sourcesTree.isDirectory)(item)) {
        this.addCollapseExpandAllOptions(menuOptions, item);

        if (_prefs.features.root) {
          const { path } = item;
          const { cx, projectRoot } = this.props;

          if (projectRoot.endsWith(path)) {
            menuOptions.push({
              id: "node-remove-directory-root",
              label: removeDirectoryRootLabel,
              disabled: false,
              click: () => this.props.clearProjectDirectoryRoot(cx)
            });
          } else {
            menuOptions.push({
              id: "node-set-directory-root",
              label: setDirectoryRootLabel,
              accesskey: setDirectoryRootKey,
              disabled: false,
              click: () => this.props.setProjectDirectoryRoot(cx, path)
            });
          }
        }
      }

      (0, _devtoolsContextmenu.showMenu)(event, menuOptions);
    }, this.addCollapseExpandAllOptions = (menuOptions, item) => {
      const { setExpanded } = this.props;

      menuOptions.push({
        id: "node-menu-collapse-all",
        label: L10N.getStr("collapseAll.label"),
        disabled: false,
        click: () => setExpanded(item, false, true)
      });

      menuOptions.push({
        id: "node-menu-expand-all",
        label: L10N.getStr("expandAll.label"),
        disabled: false,
        click: () => setExpanded(item, true, true)
      });
    }, _temp;
  }

  componentDidMount() {
    const { autoExpand, item } = this.props;
    if (autoExpand) {
      this.props.setExpanded(item, true, false);
    }
  }

  renderItemArrow() {
    const { item, expanded } = this.props;
    return (0, _sourcesTree.isDirectory)(item) ? _react2.default.createElement(_AccessibleImage2.default, { className: (0, _classnames2.default)("arrow", { expanded }) }) : _react2.default.createElement("span", { className: "img no-arrow" });
  }

  renderIcon(item, depth) {
    const {
      debuggeeUrl,
      projectRoot,
      source,
      hasPrettySource,
      threads
    } = this.props;

    if (item.name === "webpack://") {
      return _react2.default.createElement(_AccessibleImage2.default, { className: "webpack" });
    } else if (item.name === "ng://") {
      return _react2.default.createElement(_AccessibleImage2.default, { className: "angular" });
    } else if ((0, _source.isUrlExtension)(item.path) && depth === 1) {
      return _react2.default.createElement(_AccessibleImage2.default, { className: "extension" });
    }

    // Threads level
    if (depth === 0 && projectRoot === "") {
      const thread = threads.find(thrd => thrd.actor == item.name);

      if (thread) {
        const icon = thread === this.props.mainThread ? "window" : "worker";
        return _react2.default.createElement(_AccessibleImage2.default, {
          className: (0, _classnames2.default)(icon, {
            debuggee: debuggeeUrl && debuggeeUrl.includes(item.name)
          })
        });
      }
    }

    if ((0, _sourcesTree.isDirectory)(item)) {
      // Domain level
      if (depth === 1) {
        return _react2.default.createElement(_AccessibleImage2.default, { className: "globe-small" });
      }
      return _react2.default.createElement(_AccessibleImage2.default, { className: "folder" });
    }

    if (hasPrettySource) {
      return _react2.default.createElement(_AccessibleImage2.default, { className: "prettyPrint" });
    }

    if (source) {
      return _react2.default.createElement(_SourceIcon2.default, { source: source });
    }

    return null;
  }

  renderItemName(depth) {
    const { item, threads } = this.props;

    if (depth === 0) {
      const thread = threads.find(({ actor }) => actor == item.name);
      if (thread) {
        return (0, _workers.isWorker)(thread) ? (0, _workers.getDisplayName)(thread) : L10N.getStr("mainThread");
      }
    }

    switch (item.name) {
      case "ng://":
        return "Angular";
      case "webpack://":
        return "Webpack";
      default:
        return `${unescape(item.name)}`;
    }
  }

  render() {
    const {
      item,
      depth,
      source,
      focused,
      hasMatchingGeneratedSource,
      hasSiblingOfSameName
    } = this.props;

    const suffix = hasMatchingGeneratedSource ? _react2.default.createElement(
      "span",
      { className: "suffix" },
      L10N.getStr("sourceFooter.mappedSuffix")
    ) : null;

    let querystring;
    if (hasSiblingOfSameName) {
      querystring = (0, _source.getSourceQueryString)(source);
    }

    const query = hasSiblingOfSameName && querystring ? _react2.default.createElement(
      "span",
      { className: "query" },
      querystring
    ) : null;

    return _react2.default.createElement(
      "div",
      {
        className: (0, _classnames2.default)("node", { focused }),
        key: item.path,
        onClick: this.onClick,
        onContextMenu: e => this.onContextMenu(e, item)
      },
      this.renderItemArrow(),
      this.renderIcon(item, depth),
      _react2.default.createElement(
        "span",
        { className: "label" },
        this.renderItemName(depth),
        query,
        " ",
        suffix
      )
    );
  }
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function getHasMatchingGeneratedSource(state, source) {
  if (!source || !(0, _source.isOriginal)(source)) {
    return false;
  }

  return !!(0, _selectors.getGeneratedSourceByURL)(state, source.url);
}

const mapStateToProps = (state, props) => {
  const { source } = props;
  return {
    cx: (0, _selectors.getContext)(state),
    mainThread: (0, _selectors.getMainThread)(state),
    hasMatchingGeneratedSource: getHasMatchingGeneratedSource(state, source),
    hasSiblingOfSameName: (0, _selectors.getHasSiblingOfSameName)(state, source),
    hasPrettySource: source ? (0, _selectors.hasPrettySource)(state, source.id) : false
  };
};

exports.default = (0, _connect.connect)(mapStateToProps, {
  setProjectDirectoryRoot: _actions2.default.setProjectDirectoryRoot,
  clearProjectDirectoryRoot: _actions2.default.clearProjectDirectoryRoot,
  toggleBlackBox: _actions2.default.toggleBlackBox
})(SourceTreeItem);

/***/ }),
/* 713 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 714 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 715 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _redux = __webpack_require__(517);

var _reactDom = __webpack_require__(112);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _connect = __webpack_require__(491);

var _classnames = __webpack_require__(67);

var _classnames2 = _interopRequireDefault(_classnames);

var _lodash = __webpack_require__(417);

var _devtoolsEnvironment = __webpack_require__(102);

var _prefs = __webpack_require__(492);

var _indentation = __webpack_require__(536);

var _devtoolsContextmenu = __webpack_require__(420);

var _breakpoints = __webpack_require__(523);

var _editor = __webpack_require__(557);

var _selectors = __webpack_require__(490);

var _actions = __webpack_require__(493);

var _actions2 = _interopRequireDefault(_actions);

var _SearchBar = __webpack_require__(716);

var _SearchBar2 = _interopRequireDefault(_SearchBar);

var _HighlightLines = __webpack_require__(718);

var _HighlightLines2 = _interopRequireDefault(_HighlightLines);

var _Preview = __webpack_require__(719);

var _Preview2 = _interopRequireDefault(_Preview);

var _Breakpoints = __webpack_require__(726);

var _Breakpoints2 = _interopRequireDefault(_Breakpoints);

var _ColumnBreakpoints = __webpack_require__(728);

var _ColumnBreakpoints2 = _interopRequireDefault(_ColumnBreakpoints);

var _DebugLine = __webpack_require__(730);

var _DebugLine2 = _interopRequireDefault(_DebugLine);

var _HighlightLine = __webpack_require__(731);

var _HighlightLine2 = _interopRequireDefault(_HighlightLine);

var _EmptyLines = __webpack_require__(732);

var _EmptyLines2 = _interopRequireDefault(_EmptyLines);

var _EditorMenu = __webpack_require__(733);

var _EditorMenu2 = _interopRequireDefault(_EditorMenu);

var _ConditionalPanel = __webpack_require__(734);

var _ConditionalPanel2 = _interopRequireDefault(_ConditionalPanel);

var _editor2 = __webpack_require__(496);

var _ui = __webpack_require__(525);

__webpack_require__(736);

__webpack_require__(737);

__webpack_require__(738);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Redux actions
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const cssVars = {
  searchbarHeight: "var(--editor-searchbar-height)"
};

class Editor extends _react.PureComponent {
  constructor(props) {
    super(props);

    this.onClosePress = (key, e) => {
      const { cx, selectedSourceWithContent } = this.props;
      if (selectedSourceWithContent) {
        e.preventDefault();
        e.stopPropagation();
        this.props.closeTab(cx, selectedSourceWithContent.source);
      }
    };

    this.onToggleBreakpoint = (key, e) => {
      e.preventDefault();
      e.stopPropagation();

      const line = this.getCurrentLine();
      if (typeof line !== "number") {
        return;
      }

      this.props.toggleBreakpointAtLine(this.props.cx, line);
    };

    this.onToggleConditionalPanel = (key, e) => {
      e.stopPropagation();
      e.preventDefault();
      const line = this.getCurrentLine();

      if (typeof line !== "number") {
        return;
      }

      const isLog = key === L10N.getStr("toggleCondPanel.logPoint.key");
      this.toggleConditionalPanel(line, isLog);
    };

    this.onEditorScroll = (0, _lodash.throttle)(this.props.updateViewport, 100);

    this.onEscape = (key, e) => {
      if (!this.state.editor) {
        return;
      }

      const { codeMirror } = this.state.editor;
      if (codeMirror.listSelections().length > 1) {
        codeMirror.execCommand("singleSelection");
        e.preventDefault();
      }
    };

    this.clearContextMenu = () => {
      this.setState({ contextMenu: null });
    };

    this.onGutterClick = (cm, line, gutter, ev) => {
      const {
        cx,
        selectedSourceWithContent,
        conditionalPanelLocation,
        closeConditionalPanel,
        addBreakpointAtLine,
        continueToHere
      } = this.props;

      // ignore right clicks in the gutter
      if (ev.ctrlKey && ev.button === 0 || ev.button === 2 || selectedSourceWithContent && selectedSourceWithContent.source.isBlackBoxed || !selectedSourceWithContent) {
        return;
      }

      if (conditionalPanelLocation) {
        return closeConditionalPanel();
      }

      if (gutter === "CodeMirror-foldgutter") {
        return;
      }

      const sourceLine = (0, _editor2.toSourceLine)(selectedSourceWithContent.source.id, line);
      if (typeof sourceLine !== "number") {
        return;
      }

      if (ev.metaKey) {
        return continueToHere(cx, sourceLine);
      }

      return addBreakpointAtLine(cx, sourceLine, ev.altKey, ev.shiftKey);
    };

    this.onGutterContextMenu = event => {
      return this.openMenu(event);
    };

    this.toggleConditionalPanel = (line, log = false) => {
      const {
        conditionalPanelLocation,
        closeConditionalPanel,
        openConditionalPanel,
        selectedSourceWithContent
      } = this.props;

      if (conditionalPanelLocation) {
        return closeConditionalPanel();
      }

      if (!selectedSourceWithContent) {
        return;
      }

      return openConditionalPanel({
        line: line,
        sourceId: selectedSourceWithContent.source.id,
        sourceUrl: selectedSourceWithContent.source.url
      }, log);
    };

    this.state = {
      highlightedLineRange: null,
      editor: null,
      contextMenu: null
    };
  }

  componentWillReceiveProps(nextProps) {
    let editor = this.state.editor;

    if (!this.state.editor && nextProps.selectedSourceWithContent) {
      editor = this.setupEditor();
    }

    (0, _editor2.startOperation)();
    this.setText(nextProps, editor);
    this.setSize(nextProps, editor);
    this.scrollToLocation(nextProps, editor);
    (0, _editor2.endOperation)();

    if (this.props.selectedSourceWithContent != nextProps.selectedSourceWithContent) {
      this.props.updateViewport();
      (0, _ui.resizeBreakpointGutter)(editor.codeMirror);
      (0, _ui.resizeToggleButton)(editor.codeMirror);
    }
  }

  setupEditor() {
    const editor = (0, _editor2.getEditor)();

    // disables the default search shortcuts
    // $FlowIgnore
    editor._initShortcuts = () => {};

    const node = _reactDom2.default.findDOMNode(this);
    if (node instanceof HTMLElement) {
      editor.appendToLocalElement(node.querySelector(".editor-mount"));
    }

    const { codeMirror } = editor;
    const codeMirrorWrapper = codeMirror.getWrapperElement();

    codeMirror.on("gutterClick", this.onGutterClick);

    // Set code editor wrapper to be focusable
    codeMirrorWrapper.tabIndex = 0;
    codeMirrorWrapper.addEventListener("keydown", e => this.onKeyDown(e));
    codeMirrorWrapper.addEventListener("click", e => this.onClick(e));
    codeMirrorWrapper.addEventListener("mouseover", (0, _editor2.onMouseOver)(codeMirror));

    const toggleFoldMarkerVisibility = e => {
      if (node instanceof HTMLElement) {
        node.querySelectorAll(".CodeMirror-guttermarker-subtle").forEach(elem => {
          elem.classList.toggle("visible");
        });
      }
    };

    const codeMirrorGutter = codeMirror.getGutterElement();
    codeMirrorGutter.addEventListener("mouseleave", toggleFoldMarkerVisibility);
    codeMirrorGutter.addEventListener("mouseenter", toggleFoldMarkerVisibility);

    if (!(0, _devtoolsEnvironment.isFirefox)()) {
      codeMirror.on("gutterContextMenu", (cm, line, eventName, event) => this.onGutterContextMenu(event));
      codeMirror.on("contextmenu", (cm, event) => this.openMenu(event));
    } else {
      codeMirrorWrapper.addEventListener("contextmenu", event => this.openMenu(event));
    }

    codeMirror.on("scroll", this.onEditorScroll);
    this.onEditorScroll();
    this.setState({ editor });
    return editor;
  }

  componentDidMount() {
    const { shortcuts } = this.context;

    shortcuts.on(L10N.getStr("toggleBreakpoint.key"), this.onToggleBreakpoint);
    shortcuts.on(L10N.getStr("toggleCondPanel.breakpoint.key"), this.onToggleConditionalPanel);
    shortcuts.on(L10N.getStr("toggleCondPanel.logPoint.key"), this.onToggleConditionalPanel);
    shortcuts.on(L10N.getStr("sourceTabs.closeTab.key"), this.onClosePress);
    shortcuts.on("Esc", this.onEscape);
  }

  componentWillUnmount() {
    if (this.state.editor) {
      this.state.editor.destroy();
      this.state.editor.codeMirror.off("scroll", this.onEditorScroll);
      this.setState({ editor: null });
    }

    const shortcuts = this.context.shortcuts;
    shortcuts.off(L10N.getStr("sourceTabs.closeTab.key"));
    shortcuts.off(L10N.getStr("toggleBreakpoint.key"));
    shortcuts.off(L10N.getStr("toggleCondPanel.breakpoint.key"));
    shortcuts.off(L10N.getStr("toggleCondPanel.logPoint.key"));
  }

  getCurrentLine() {
    const { codeMirror } = this.state.editor;
    const { selectedSourceWithContent } = this.props;
    if (!selectedSourceWithContent) {
      return;
    }

    const line = (0, _editor2.getCursorLine)(codeMirror);
    return (0, _editor2.toSourceLine)(selectedSourceWithContent.source.id, line);
  }

  onKeyDown(e) {
    const { codeMirror } = this.state.editor;
    const { key, target } = e;
    const codeWrapper = codeMirror.getWrapperElement();
    const textArea = codeWrapper.querySelector("textArea");

    if (key === "Escape" && target == textArea) {
      e.stopPropagation();
      e.preventDefault();
      codeWrapper.focus();
    } else if (key === "Enter" && target == codeWrapper) {
      e.preventDefault();
      // Focus into editor's text area
      textArea.focus();
    }
  }

  /*
   * The default Esc command is overridden in the CodeMirror keymap to allow
   * the Esc keypress event to be catched by the toolbox and trigger the
   * split console. Restore it here, but preventDefault if and only if there
   * is a multiselection.
   */


  openMenu(event) {
    event.stopPropagation();
    event.preventDefault();

    const {
      cx,
      selectedSourceWithContent,
      breakpointActions,
      editorActions,
      isPaused
    } = this.props;
    const { editor } = this.state;
    if (!selectedSourceWithContent || !editor) {
      return;
    }

    const target = event.target;
    const { id: sourceId } = selectedSourceWithContent.source;
    const line = (0, _editor2.lineAtHeight)(editor, sourceId, event);

    if (typeof line != "number") {
      return;
    }

    const location = { line, column: undefined, sourceId };

    if (target.classList.contains("CodeMirror-linenumber")) {
      return (0, _devtoolsContextmenu.showMenu)(event, [...(0, _breakpoints.createBreakpointItems)(cx, location, breakpointActions), { type: "separator" }, (0, _editor.continueToHereItem)(cx, location, isPaused, editorActions)]);
    }

    if (target.getAttribute("id") === "columnmarker") {
      return;
    }

    this.setState({ contextMenu: event });
  }

  onClick(e) {
    const { cx, selectedSourceWithContent, jumpToMappedLocation } = this.props;

    if (selectedSourceWithContent && e.metaKey && e.altKey) {
      const sourceLocation = (0, _editor2.getSourceLocationFromMouseEvent)(this.state.editor, selectedSourceWithContent.source, e);
      jumpToMappedLocation(cx, sourceLocation);
    }
  }

  shouldScrollToLocation(nextProps, editor) {
    const { selectedLocation, selectedSourceWithContent } = this.props;
    if (!editor || !nextProps.selectedSourceWithContent || !nextProps.selectedLocation || !nextProps.selectedLocation.line || !nextProps.selectedSourceWithContent.content) {
      return false;
    }

    const isFirstLoad = (!selectedSourceWithContent || !selectedSourceWithContent.content) && nextProps.selectedSourceWithContent.content;
    const locationChanged = selectedLocation !== nextProps.selectedLocation;
    const symbolsChanged = nextProps.symbols != this.props.symbols;

    return isFirstLoad || locationChanged || symbolsChanged;
  }

  scrollToLocation(nextProps, editor) {
    const { selectedLocation, selectedSourceWithContent } = nextProps;

    if (selectedLocation && this.shouldScrollToLocation(nextProps, editor)) {
      let { line, column } = (0, _editor2.toEditorPosition)(selectedLocation);

      if (selectedSourceWithContent && (0, _editor2.hasDocument)(selectedSourceWithContent.source.id)) {
        const doc = (0, _editor2.getDocument)(selectedSourceWithContent.source.id);
        const lineText = doc.getLine(line);
        column = Math.max(column, (0, _indentation.getIndentation)(lineText));
      }

      (0, _editor2.scrollToColumn)(editor.codeMirror, line, column);
    }
  }

  setSize(nextProps, editor) {
    if (!editor) {
      return;
    }

    if (nextProps.startPanelSize !== this.props.startPanelSize || nextProps.endPanelSize !== this.props.endPanelSize) {
      editor.codeMirror.setSize();
    }
  }

  setText(props, editor) {
    const { selectedSourceWithContent, symbols } = props;

    if (!editor) {
      return;
    }

    // check if we previously had a selected source
    if (!selectedSourceWithContent) {
      return this.clearEditor();
    }

    if (!selectedSourceWithContent.content) {
      return (0, _editor2.showLoading)(editor);
    }

    if (selectedSourceWithContent.content.state === "rejected") {
      let { value } = selectedSourceWithContent.content;
      if (typeof value !== "string") {
        value = "Unexpected source error";
      }

      return this.showErrorMessage(value);
    }

    return (0, _editor2.showSourceText)(editor, selectedSourceWithContent.source, selectedSourceWithContent.content.value, symbols);
  }

  clearEditor() {
    const { editor } = this.state;
    if (!editor) {
      return;
    }

    (0, _editor2.clearEditor)(editor);
  }

  showErrorMessage(msg) {
    const { editor } = this.state;
    if (!editor) {
      return;
    }

    (0, _editor2.showErrorMessage)(editor, msg);
  }

  getInlineEditorStyles() {
    const { searchOn } = this.props;

    if (searchOn) {
      return {
        height: `calc(100% - ${cssVars.searchbarHeight})`
      };
    }

    return {
      height: "100%"
    };
  }

  renderItems() {
    const {
      cx,
      selectedSourceWithContent,
      conditionalPanelLocation
    } = this.props;
    const { editor, contextMenu } = this.state;

    if (!selectedSourceWithContent || !editor || !(0, _editor2.getDocument)(selectedSourceWithContent.source.id)) {
      return null;
    }

    return _react2.default.createElement(
      "div",
      null,
      _react2.default.createElement(_DebugLine2.default, { editor: editor }),
      _react2.default.createElement(_HighlightLine2.default, null),
      _react2.default.createElement(_EmptyLines2.default, { editor: editor }),
      _react2.default.createElement(_Breakpoints2.default, { editor: editor, cx: cx }),
      _react2.default.createElement(_Preview2.default, { editor: editor, editorRef: this.$editorWrapper }),
      _react2.default.createElement(_HighlightLines2.default, { editor: editor }),
      _react2.default.createElement(_EditorMenu2.default, {
        editor: editor,
        contextMenu: contextMenu,
        clearContextMenu: this.clearContextMenu,
        selectedSourceWithContent: selectedSourceWithContent
      }),
      conditionalPanelLocation ? _react2.default.createElement(_ConditionalPanel2.default, { editor: editor }) : null,
      _prefs.features.columnBreakpoints ? _react2.default.createElement(_ColumnBreakpoints2.default, { editor: editor }) : null
    );
  }

  renderSearchBar() {
    const { editor } = this.state;

    if (!this.props.selectedSourceWithContent) {
      return null;
    }

    return _react2.default.createElement(_SearchBar2.default, { editor: editor });
  }

  render() {
    const { selectedSourceWithContent, skipPausing } = this.props;
    return _react2.default.createElement(
      "div",
      {
        className: (0, _classnames2.default)("editor-wrapper", {
          blackboxed: selectedSourceWithContent && selectedSourceWithContent.source.isBlackBoxed,
          "skip-pausing": skipPausing
        }),
        ref: c => this.$editorWrapper = c
      },
      _react2.default.createElement("div", {
        className: "editor-mount devtools-monospace",
        style: this.getInlineEditorStyles()
      }),
      this.renderSearchBar(),
      this.renderItems()
    );
  }
}

Editor.contextTypes = {
  shortcuts: _propTypes2.default.object
};

const mapStateToProps = state => {
  const selectedSourceWithContent = (0, _selectors.getSelectedSourceWithContent)(state);

  return {
    cx: (0, _selectors.getThreadContext)(state),
    selectedLocation: (0, _selectors.getSelectedLocation)(state),
    selectedSourceWithContent,
    searchOn: (0, _selectors.getActiveSearch)(state) === "file",
    conditionalPanelLocation: (0, _selectors.getConditionalPanelLocation)(state),
    symbols: (0, _selectors.getSymbols)(state, selectedSourceWithContent ? selectedSourceWithContent.source : null),
    isPaused: (0, _selectors.getIsPaused)(state, (0, _selectors.getCurrentThread)(state)),
    skipPausing: (0, _selectors.getSkipPausing)(state)
  };
};

const mapDispatchToProps = dispatch => ({
  ...(0, _redux.bindActionCreators)({
    openConditionalPanel: _actions2.default.openConditionalPanel,
    closeConditionalPanel: _actions2.default.closeConditionalPanel,
    continueToHere: _actions2.default.continueToHere,
    toggleBreakpointAtLine: _actions2.default.toggleBreakpointAtLine,
    addBreakpointAtLine: _actions2.default.addBreakpointAtLine,
    jumpToMappedLocation: _actions2.default.jumpToMappedLocation,
    traverseResults: _actions2.default.traverseResults,
    updateViewport: _actions2.default.updateViewport,
    closeTab: _actions2.default.closeTab
  }, dispatch),
  breakpointActions: (0, _breakpoints.breakpointItemActions)(dispatch),
  editorActions: (0, _editor.editorItemActions)(dispatch)
});

exports.default = (0, _connect.connect)(mapStateToProps, mapDispatchToProps)(Editor);

/***/ }),
/* 716 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _connect = __webpack_require__(491);

var _Button = __webpack_require__(502);

var _AccessibleImage = __webpack_require__(495);

var _AccessibleImage2 = _interopRequireDefault(_AccessibleImage);

var _actions = __webpack_require__(493);

var _actions2 = _interopRequireDefault(_actions);

var _selectors = __webpack_require__(490);

var _editor = __webpack_require__(496);

var _resultList = __webpack_require__(603);

var _classnames = __webpack_require__(67);

var _classnames2 = _interopRequireDefault(_classnames);

var _SearchInput = __webpack_require__(553);

var _SearchInput2 = _interopRequireDefault(_SearchInput);

var _lodash = __webpack_require__(417);

__webpack_require__(717);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getShortcuts() {
  const searchAgainKey = L10N.getStr("sourceSearch.search.again.key2");
  const searchAgainPrevKey = L10N.getStr("sourceSearch.search.againPrev.key2");
  const searchKey = L10N.getStr("sourceSearch.search.key2");

  return {
    shiftSearchAgainShortcut: searchAgainPrevKey,
    searchAgainShortcut: searchAgainKey,
    searchShortcut: searchKey
  };
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

class SearchBar extends _react.Component {
  constructor(props) {
    super(props);

    this.onEscape = e => {
      this.closeSearch(e);
    };

    this.clearSearch = () => {
      const { editor: ed, query } = this.props;
      if (ed) {
        const ctx = { ed, cm: ed.codeMirror };
        (0, _editor.removeOverlay)(ctx, query);
      }
    };

    this.closeSearch = e => {
      const { cx, closeFileSearch, editor, searchOn } = this.props;
      if (editor && searchOn) {
        this.clearSearch();
        closeFileSearch(cx, editor);
        e.stopPropagation();
        e.preventDefault();
      }
      this.setState({ query: "" });
    };

    this.toggleSearch = e => {
      e.stopPropagation();
      e.preventDefault();
      const { editor, searchOn, setActiveSearch } = this.props;

      if (!searchOn) {
        setActiveSearch("file");
      }

      if (searchOn && editor) {
        const query = editor.codeMirror.getSelection() || this.state.query;

        if (query !== "") {
          this.setState({ query });
          this.doSearch(query);
        } else {
          this.setState({ query: "" });
        }
      }
    };

    this.doSearch = query => {
      const { cx, selectedSource, selectedContentLoaded } = this.props;
      if (!selectedSource || !selectedContentLoaded) {
        return;
      }

      this.props.doSearch(cx, query, this.props.editor);
    };

    this.traverseResults = (e, rev) => {
      e.stopPropagation();
      e.preventDefault();
      const editor = this.props.editor;

      if (!editor) {
        return;
      }
      this.props.traverseResults(this.props.cx, rev, editor);
    };

    this.onChange = e => {
      this.setState({ query: e.target.value });

      return this.doSearch(e.target.value);
    };

    this.onKeyDown = e => {
      if (e.key !== "Enter" && e.key !== "F3") {
        return;
      }

      this.traverseResults(e, e.shiftKey);
      e.preventDefault();
      return this.doSearch(e.target.value);
    };

    this.onHistoryScroll = query => {
      this.setState({ query });
      this.doSearch(query);
    };

    this.renderSearchModifiers = () => {
      const { cx, modifiers, toggleFileSearchModifier, query } = this.props;
      const { doSearch } = this;

      function SearchModBtn({ modVal, className, svgName, tooltip }) {
        const preppedClass = (0, _classnames2.default)(className, {
          active: modifiers && modifiers.get(modVal)
        });
        return _react2.default.createElement(
          "button",
          {
            className: preppedClass,
            onMouseDown: () => {
              toggleFileSearchModifier(cx, modVal);
              doSearch(query);
            },
            onKeyDown: e => {
              if (e.key === "Enter") {
                toggleFileSearchModifier(cx, modVal);
                doSearch(query);
              }
            },
            title: tooltip
          },
          _react2.default.createElement(_AccessibleImage2.default, { className: svgName })
        );
      }

      return _react2.default.createElement(
        "div",
        { className: "search-modifiers" },
        _react2.default.createElement("span", { className: "pipe-divider" }),
        _react2.default.createElement(
          "span",
          { className: "search-type-name" },
          L10N.getStr("symbolSearch.searchModifier.modifiersLabel")
        ),
        _react2.default.createElement(SearchModBtn, {
          modVal: "regexMatch",
          className: "regex-match-btn",
          svgName: "regex-match",
          tooltip: L10N.getStr("symbolSearch.searchModifier.regex")
        }),
        _react2.default.createElement(SearchModBtn, {
          modVal: "caseSensitive",
          className: "case-sensitive-btn",
          svgName: "case-match",
          tooltip: L10N.getStr("symbolSearch.searchModifier.caseSensitive")
        }),
        _react2.default.createElement(SearchModBtn, {
          modVal: "wholeWord",
          className: "whole-word-btn",
          svgName: "whole-word-match",
          tooltip: L10N.getStr("symbolSearch.searchModifier.wholeWord")
        })
      );
    };

    this.state = {
      query: props.query,
      selectedResultIndex: 0,
      count: 0,
      index: -1
    };
  }

  componentWillUnmount() {
    const shortcuts = this.context.shortcuts;
    const {
      searchShortcut,
      searchAgainShortcut,
      shiftSearchAgainShortcut
    } = getShortcuts();

    shortcuts.off(searchShortcut);
    shortcuts.off("Escape");
    shortcuts.off(searchAgainShortcut);
    shortcuts.off(shiftSearchAgainShortcut);
  }

  componentDidMount() {
    // overwrite this.doSearch with debounced version to
    // reduce frequency of queries
    this.doSearch = (0, _lodash.debounce)(this.doSearch, 100);
    const shortcuts = this.context.shortcuts;
    const {
      searchShortcut,
      searchAgainShortcut,
      shiftSearchAgainShortcut
    } = getShortcuts();

    shortcuts.on(searchShortcut, (_, e) => this.toggleSearch(e));
    shortcuts.on("Escape", (_, e) => this.onEscape(e));

    shortcuts.on(shiftSearchAgainShortcut, (_, e) => this.traverseResults(e, true));

    shortcuts.on(searchAgainShortcut, (_, e) => this.traverseResults(e, false));
  }

  componentDidUpdate(prevProps, prevState) {
    if (this.refs.resultList && this.refs.resultList.refs) {
      (0, _resultList.scrollList)(this.refs.resultList.refs, this.state.selectedResultIndex);
    }
  }

  // Handlers

  // Renderers
  buildSummaryMsg() {
    const {
      searchResults: { matchIndex, count, index },
      query
    } = this.props;

    if (query.trim() == "") {
      return "";
    }

    if (count == 0) {
      return L10N.getStr("editor.noResultsFound");
    }

    if (index == -1) {
      return L10N.getFormatStr("sourceSearch.resultsSummary1", count);
    }

    return L10N.getFormatStr("editor.searchResults", matchIndex + 1, count);
  }

  shouldShowErrorEmoji() {
    const {
      query,
      searchResults: { count }
    } = this.props;
    return !!query && !count;
  }

  render() {
    const {
      searchResults: { count },
      searchOn,
      showClose = true,
      size = "big"
    } = this.props;

    if (!searchOn) {
      return _react2.default.createElement("div", null);
    }

    return _react2.default.createElement(
      "div",
      { className: "search-bar" },
      _react2.default.createElement(_SearchInput2.default, {
        query: this.state.query,
        count: count,
        placeholder: L10N.getStr("sourceSearch.search.placeholder2"),
        summaryMsg: this.buildSummaryMsg(),
        isLoading: false,
        onChange: this.onChange,
        showErrorEmoji: this.shouldShowErrorEmoji(),
        onKeyDown: this.onKeyDown,
        onHistoryScroll: this.onHistoryScroll,
        handleNext: e => this.traverseResults(e, false),
        handlePrev: e => this.traverseResults(e, true),
        showClose: false
      }),
      _react2.default.createElement(
        "div",
        { className: "search-bottom-bar" },
        this.renderSearchModifiers(),
        showClose && _react2.default.createElement(
          _react2.default.Fragment,
          null,
          _react2.default.createElement("span", { className: "pipe-divider" }),
          _react2.default.createElement(_Button.CloseButton, { handleClick: this.closeSearch, buttonClass: size })
        )
      )
    );
  }
}

SearchBar.contextTypes = {
  shortcuts: _propTypes2.default.object
};

const mapStateToProps = state => {
  const selectedSource = (0, _selectors.getSelectedSource)(state);

  return {
    cx: (0, _selectors.getContext)(state),
    searchOn: (0, _selectors.getActiveSearch)(state) === "file",
    selectedSource,
    selectedContentLoaded: selectedSource ? !!(0, _selectors.getSourceContent)(state, selectedSource.id) : null,
    selectedLocation: (0, _selectors.getSelectedLocation)(state),
    query: (0, _selectors.getFileSearchQuery)(state),
    modifiers: (0, _selectors.getFileSearchModifiers)(state),
    highlightedLineRange: (0, _selectors.getHighlightedLineRange)(state),
    searchResults: (0, _selectors.getFileSearchResults)(state)
  };
};

exports.default = (0, _connect.connect)(mapStateToProps, {
  toggleFileSearchModifier: _actions2.default.toggleFileSearchModifier,
  setFileSearchQuery: _actions2.default.setFileSearchQuery,
  setActiveSearch: _actions2.default.setActiveSearch,
  closeFileSearch: _actions2.default.closeFileSearch,
  doSearch: _actions2.default.doSearch,
  traverseResults: _actions2.default.traverseResults
})(SearchBar);

/***/ }),
/* 717 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 718 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _lodash = __webpack_require__(417);

var _connect = __webpack_require__(491);

var _selectors = __webpack_require__(490);

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

class HighlightLines extends _react.Component {
  constructor(...args) {
    var _temp;

    return _temp = super(...args), this.highlightLineRange = () => {
      const { highlightedLineRange, editor } = this.props;

      const { codeMirror } = editor;

      if ((0, _lodash.isEmpty)(highlightedLineRange) || !codeMirror) {
        return;
      }

      const { start, end } = highlightedLineRange;

      codeMirror.operation(() => {
        editor.alignLine(start);

        (0, _lodash.range)(start - 1, end).forEach(line => {
          codeMirror.addLineClass(line, "line", "highlight-lines");
        });
      });
    }, _temp;
  }

  componentDidMount() {
    this.highlightLineRange();
  }

  componentWillUpdate() {
    this.clearHighlightRange();
  }

  componentDidUpdate() {
    this.highlightLineRange();
  }

  componentWillUnmount() {
    this.clearHighlightRange();
  }

  clearHighlightRange() {
    const { highlightedLineRange, editor } = this.props;

    const { codeMirror } = editor;

    if ((0, _lodash.isEmpty)(highlightedLineRange) || !codeMirror) {
      return;
    }

    const { start, end } = highlightedLineRange;
    codeMirror.operation(() => {
      (0, _lodash.range)(start - 1, end).forEach(line => {
        codeMirror.removeLineClass(line, "line", "highlight-lines");
      });
    });
  }

  render() {
    return null;
  }
}

exports.default = (0, _connect.connect)(state => ({
  highlightedLineRange: (0, _selectors.getHighlightedLineRange)(state)
}))(HighlightLines);

/***/ }),
/* 719 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _connect = __webpack_require__(491);

var _Popup = __webpack_require__(720);

var _Popup2 = _interopRequireDefault(_Popup);

var _selectors = __webpack_require__(490);

var _actions = __webpack_require__(493);

var _actions2 = _interopRequireDefault(_actions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function inPopup(e) {
  const { relatedTarget } = e;

  if (!relatedTarget) {
    return true;
  }

  const pop = relatedTarget.closest(".tooltip") || relatedTarget.closest(".popover");

  return pop;
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function getElementFromPos(pos) {
  // We need to use element*s*AtPoint because the tooltip overlays
  // the token and thus an undesirable element may be returned
  const elementsAtPoint = [
  // $FlowIgnore
  ...document.elementsFromPoint(pos.x + pos.width / 2, pos.y + pos.height / 2)];

  return elementsAtPoint.find(el => el.className.startsWith("cm-"));
}

class Preview extends _react.PureComponent {
  constructor(props) {
    super(props);
    this.target = null;

    this.onTokenEnter = ({ target, tokenPos }) => {
      const { cx, updatePreview, editor } = this.props;
      if (cx.isPaused) {
        updatePreview(cx, target, tokenPos, editor.codeMirror);
      }
    };

    this.onTokenLeave = e => {
      if (this.props.cx.isPaused && !inPopup(e)) {
        this.props.clearPreview(this.props.cx);
      }
    };

    this.onMouseUp = () => {
      if (this.props.cx.isPaused) {
        this.setState({ selecting: false });
        return true;
      }
    };

    this.onMouseDown = () => {
      if (this.props.cx.isPaused) {
        this.setState({ selecting: true });
        return true;
      }
    };

    this.onScroll = () => {
      if (this.props.cx.isPaused) {
        this.props.clearPreview(this.props.cx);
      }
    };

    this.onClose = e => {
      if (this.props.cx.isPaused) {
        this.props.clearPreview(this.props.cx);
      }
    };

    this.state = { selecting: false };
  }

  componentDidMount() {
    this.updateListeners();
  }

  componentWillUnmount() {
    const { codeMirror } = this.props.editor;
    const codeMirrorWrapper = codeMirror.getWrapperElement();

    codeMirror.off("scroll", this.onScroll);
    codeMirror.off("tokenenter", this.onTokenEnter);
    codeMirror.off("tokenleave", this.onTokenLeave);
    codeMirrorWrapper.removeEventListener("mouseup", this.onMouseUp);
    codeMirrorWrapper.removeEventListener("mousedown", this.onMouseDown);
  }

  componentDidUpdate(prevProps) {
    this.updateHighlight(prevProps);
  }

  updateListeners(prevProps) {
    const { codeMirror } = this.props.editor;
    const codeMirrorWrapper = codeMirror.getWrapperElement();
    codeMirror.on("scroll", this.onScroll);
    codeMirror.on("tokenenter", this.onTokenEnter);
    codeMirror.on("tokenleave", this.onTokenLeave);
    codeMirrorWrapper.addEventListener("mouseup", this.onMouseUp);
    codeMirrorWrapper.addEventListener("mousedown", this.onMouseDown);
  }

  updateHighlight(prevProps) {
    const { preview } = this.props;

    if (preview && !preview.updating) {
      const target = getElementFromPos(preview.cursorPos);
      target && target.classList.add("preview-selection");
    }

    if (prevProps.preview && !prevProps.preview.updating) {
      const target = getElementFromPos(prevProps.preview.cursorPos);
      target && target.classList.remove("preview-selection");
    }
  }

  render() {
    const { preview } = this.props;
    if (!preview || preview.updating || this.state.selecting) {
      return null;
    }

    return _react2.default.createElement(_Popup2.default, {
      preview: preview,
      editor: this.props.editor,
      editorRef: this.props.editorRef,
      onClose: this.onClose
    });
  }
}

const mapStateToProps = state => ({
  cx: (0, _selectors.getThreadContext)(state),
  preview: (0, _selectors.getPreview)(state)
});

exports.default = (0, _connect.connect)(mapStateToProps, {
  clearPreview: _actions2.default.clearPreview,
  addExpression: _actions2.default.addExpression,
  updatePreview: _actions2.default.updatePreview
})(Preview);

/***/ }),
/* 720 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Popup = undefined;

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _connect = __webpack_require__(491);

var _devtoolsReps = __webpack_require__(457);

var _devtoolsReps2 = _interopRequireDefault(_devtoolsReps);

var _actions = __webpack_require__(493);

var _actions2 = _interopRequireDefault(_actions);

var _selectors = __webpack_require__(490);

var _Popover = __webpack_require__(721);

var _Popover2 = _interopRequireDefault(_Popover);

var _PreviewFunction = __webpack_require__(602);

var _PreviewFunction2 = _interopRequireDefault(_PreviewFunction);

var _firefox = __webpack_require__(508);

__webpack_require__(725);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const {
  REPS: { Rep },
  MODE,
  objectInspector
} = _devtoolsReps2.default; /* This Source Code Form is subject to the terms of the Mozilla Public
                             * License, v. 2.0. If a copy of the MPL was not distributed with this
                             * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const { ObjectInspector, utils } = objectInspector;

const {
  node: { nodeIsPrimitive, nodeIsFunction, nodeIsObject }
} = utils;

function inPreview(event) {
  const relatedTarget = event.relatedTarget;

  if (!relatedTarget || relatedTarget.classList && relatedTarget.classList.contains("preview-expression")) {
    return true;
  }

  // $FlowIgnore
  const inPreviewSelection = document.elementsFromPoint(event.clientX, event.clientY).some(el => el.classList.contains("preview-selection"));

  return inPreviewSelection;
}

class Popup extends _react.Component {

  constructor(props) {
    super(props);

    this.onMouseLeave = e => {
      const relatedTarget = e.relatedTarget;

      if (!relatedTarget) {
        return this.props.onClose();
      }

      if (!inPreview(e)) {
        this.props.onClose();
      }
    };

    this.onKeyDown = e => {
      if (e.key === "Escape") {
        this.props.onClose();
      }
    };

    this.calculateMaxHeight = () => {
      const { editorRef } = this.props;
      if (!editorRef) {
        return "auto";
      }
      return editorRef.getBoundingClientRect().height - this.state.top;
    };

    this.onPopoverCoords = coords => {
      this.setState({ top: coords.top });
    };

    this.state = {
      top: 0
    };
  }

  renderFunctionPreview() {
    const {
      cx,
      selectSourceURL,
      preview: { result }
    } = this.props;

    return _react2.default.createElement(
      "div",
      {
        className: "preview-popup",
        onClick: () => selectSourceURL(cx, result.location.url, {
          line: result.location.line
        })
      },
      _react2.default.createElement(_PreviewFunction2.default, { func: result })
    );
  }

  renderObjectPreview() {
    const {
      preview: { properties },
      openLink,
      openElementInInspector,
      highlightDomElement,
      unHighlightDomElement
    } = this.props;

    return _react2.default.createElement(
      "div",
      {
        className: "preview-popup",
        style: { maxHeight: this.calculateMaxHeight() }
      },
      _react2.default.createElement(ObjectInspector, {
        roots: properties,
        autoExpandDepth: 0,
        disableWrap: true,
        focusable: false,
        openLink: openLink,
        createObjectClient: grip => (0, _firefox.createObjectClient)(grip),
        onDOMNodeClick: grip => openElementInInspector(grip),
        onInspectIconClick: grip => openElementInInspector(grip),
        onDOMNodeMouseOver: grip => highlightDomElement(grip),
        onDOMNodeMouseOut: grip => unHighlightDomElement(grip)
      })
    );
  }

  renderSimplePreview() {
    const {
      openLink,
      preview: { result }
    } = this.props;
    return _react2.default.createElement(
      "div",
      { className: "preview-popup" },
      Rep({
        object: result,
        mode: MODE.LONG,
        openLink
      })
    );
  }

  renderPreview() {
    // We don't have to check and
    // return on `false`, `""`, `0`, `undefined` etc,
    // these falsy simple typed value because we want to
    // do `renderSimplePreview` on these values below.
    const {
      preview: { root }
    } = this.props;

    if (nodeIsFunction(root)) {
      return this.renderFunctionPreview();
    }

    if (nodeIsObject(root)) {
      return _react2.default.createElement(
        "div",
        null,
        this.renderObjectPreview()
      );
    }

    return this.renderSimplePreview();
  }

  getPreviewType() {
    const {
      preview: { root }
    } = this.props;
    if (nodeIsPrimitive(root) || nodeIsFunction(root)) {
      return "tooltip";
    }

    return "popover";
  }

  render() {
    const {
      preview: { cursorPos, result },
      editorRef
    } = this.props;
    const type = this.getPreviewType();

    if (typeof result == "undefined" || result.optimizedOut) {
      return null;
    }

    return _react2.default.createElement(
      _Popover2.default,
      {
        targetPosition: cursorPos,
        onMouseLeave: this.onMouseLeave,
        onKeyDown: this.onKeyDown,
        type: type,
        onPopoverCoords: this.onPopoverCoords,
        editorRef: editorRef
      },
      this.renderPreview()
    );
  }
}

exports.Popup = Popup;
const mapStateToProps = state => ({
  cx: (0, _selectors.getThreadContext)(state)
});

const {
  addExpression,
  selectSourceURL,
  openLink,
  openElementInInspectorCommand,
  highlightDomElement,
  unHighlightDomElement
} = _actions2.default;

const mapDispatchToProps = {
  addExpression,
  selectSourceURL,
  openLink,
  openElementInInspector: openElementInInspectorCommand,
  highlightDomElement,
  unHighlightDomElement
};

exports.default = (0, _connect.connect)(mapStateToProps, mapDispatchToProps)(Popup);

/***/ }),
/* 721 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(67);

var _classnames2 = _interopRequireDefault(_classnames);

var _BracketArrow = __webpack_require__(722);

var _BracketArrow2 = _interopRequireDefault(_BracketArrow);

__webpack_require__(724);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

class Popover extends _react.Component {
  constructor(...args) {
    var _temp;

    return _temp = super(...args), this.state = {
      coords: {
        left: 0,
        top: 0,
        orientation: "down",
        targetMid: { x: 0, y: 0 }
      }
    }, this.calculateTopForRightOrientation = (target, editor, popover) => {
      if (popover.height < editor.height) {
        const rightOrientationTop = target.top - popover.height / 2;
        if (rightOrientationTop < editor.top) {
          return editor.top;
        }
        const rightOrientationBottom = rightOrientationTop + popover.height;
        if (rightOrientationBottom > editor.bottom) {
          return editor.bottom - popover.height;
        }
        return rightOrientationTop;
      }
      return 0;
    }, this.calculateTop = (target, editor, popover, orientation) => {
      if (orientation === "down") {
        return target.bottom;
      }
      if (orientation === "up") {
        return target.top - popover.height;
      }

      return this.calculateTopForRightOrientation(target, editor, popover);
    }, _temp;
  }

  componentDidMount() {
    const { type } = this.props;
    const coords = type == "popover" ? this.getPopoverCoords() : this.getTooltipCoords();

    if (coords) {
      this.setState({ coords });
    }

    this.props.onPopoverCoords(coords);
  }

  calculateLeft(target, editor, popover, orientation) {
    const estimatedLeft = target.left;
    const estimatedRight = estimatedLeft + popover.width;
    const isOverflowingRight = estimatedRight > editor.right;
    if (orientation === "right") {
      return target.left + target.width + 5;
    }
    if (isOverflowingRight) {
      const adjustedLeft = editor.right - popover.width - 8;
      return adjustedLeft;
    }
    return estimatedLeft;
  }

  calculateOrientation(target, editor, popover) {
    const estimatedBottom = target.bottom + popover.height;
    if (editor.bottom > estimatedBottom) {
      return "down";
    }
    const upOrientationTop = target.top - popover.height;
    if (upOrientationTop > editor.top) {
      return "up";
    }

    return "right";
  }

  getPopoverCoords() {
    if (!this.$popover || !this.props.editorRef) {
      return null;
    }

    const popover = this.$popover;
    const editor = this.props.editorRef;
    const popoverRect = popover.getBoundingClientRect();
    const editorRect = editor.getBoundingClientRect();
    const targetRect = this.props.targetPosition;
    const orientation = this.calculateOrientation(targetRect, editorRect, popoverRect);
    const top = this.calculateTop(targetRect, editorRect, popoverRect, orientation);
    const popoverLeft = this.calculateLeft(targetRect, editorRect, popoverRect, orientation);
    let targetMid;
    if (orientation === "right") {
      targetMid = {
        x: -14,
        y: targetRect.top - top - 2
      };
    } else {
      targetMid = {
        x: targetRect.left - popoverLeft + targetRect.width / 2 - 8,
        y: 0
      };
    }

    return {
      left: popoverLeft,
      top,
      orientation,
      targetMid
    };
  }

  getTooltipCoords() {
    if (!this.$tooltip || !this.props.editorRef) {
      return null;
    }
    const tooltip = this.$tooltip;
    const editor = this.props.editorRef;
    const tooltipRect = tooltip.getBoundingClientRect();
    const editorRect = editor.getBoundingClientRect();
    const targetRect = this.props.targetPosition;
    const left = this.calculateLeft(targetRect, editorRect, tooltipRect);
    const enoughRoomForTooltipAbove = targetRect.top - editorRect.top > tooltipRect.height;
    const top = enoughRoomForTooltipAbove ? targetRect.top - tooltipRect.height : targetRect.bottom;

    return {
      left,
      top,
      orientation: enoughRoomForTooltipAbove ? "up" : "down",
      targetMid: { x: 0, y: 0 }
    };
  }

  getChildren() {
    const { children } = this.props;
    const { orientation } = this.state.coords;
    const gap = _react2.default.createElement("div", { className: "gap", key: "gap" });
    return orientation === "up" ? [children, gap] : [gap, children];
  }

  getPopoverArrow(orientation, left, top) {
    const arrowProps = {};
    if (orientation === "up") {
      Object.assign(arrowProps, { orientation: "down", bottom: 5, left });
    } else if (orientation === "down") {
      Object.assign(arrowProps, { orientation: "up", top: -7, left });
    } else {
      Object.assign(arrowProps, { orientation: "left", top, left: -9 });
    }

    return _react2.default.createElement(_BracketArrow2.default, arrowProps);
  }

  renderPopover() {
    const { top, left, orientation, targetMid } = this.state.coords;
    const { onMouseLeave, onKeyDown } = this.props;
    const arrow = this.getPopoverArrow(orientation, targetMid.x, targetMid.y);

    return _react2.default.createElement(
      "div",
      {
        className: (0, _classnames2.default)("popover", `orientation-${orientation}`, {
          up: orientation === "up"
        }),
        onMouseLeave: onMouseLeave,
        onKeyDown: onKeyDown,
        style: { top, left },
        ref: c => this.$popover = c
      },
      arrow,
      this.getChildren()
    );
  }

  renderTooltip() {
    const { top, left } = this.state.coords;
    const { onMouseLeave, onKeyDown } = this.props;
    return _react2.default.createElement(
      "div",
      {
        className: "tooltip",
        onMouseLeave: onMouseLeave,
        onKeyDown: onKeyDown,
        style: { top, left },
        ref: c => this.$tooltip = c
      },
      this.getChildren()
    );
  }

  render() {
    const { type } = this.props;

    if (type === "tooltip") {
      return this.renderTooltip();
    }

    return this.renderPopover();
  }
}

Popover.defaultProps = {
  onMouseLeave: () => {},
  onPopoverCoords: () => {},
  onKeyDown: () => {},
  type: "popover"
};
exports.default = Popover;

/***/ }),
/* 722 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(67);

var _classnames2 = _interopRequireDefault(_classnames);

__webpack_require__(723);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const BracketArrow = ({
  orientation,
  left,
  top,
  bottom
}) => {
  return _react2.default.createElement("div", {
    className: (0, _classnames2.default)("bracket-arrow", orientation || "up"),
    style: { left, top, bottom }
  });
}; /* This Source Code Form is subject to the terms of the Mozilla Public
    * License, v. 2.0. If a copy of the MPL was not distributed with this
    * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

exports.default = BracketArrow;

/***/ }),
/* 723 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 724 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 725 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 726 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _Breakpoint = __webpack_require__(727);

var _Breakpoint2 = _interopRequireDefault(_Breakpoint);

var _selectors = __webpack_require__(490);

var _breakpoint = __webpack_require__(499);

var _connect = __webpack_require__(491);

var _breakpoints = __webpack_require__(523);

var _editor = __webpack_require__(557);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Breakpoints extends _react.Component {
  render() {
    const {
      cx,
      breakpoints,
      selectedSource,
      editor,
      breakpointActions,
      editorActions
    } = this.props;

    if (!breakpoints || selectedSource.isBlackBoxed) {
      return null;
    }

    return _react2.default.createElement(
      "div",
      null,
      breakpoints.map(bp => {
        return _react2.default.createElement(_Breakpoint2.default, {
          cx: cx,
          key: (0, _breakpoint.makeBreakpointId)(bp.location),
          breakpoint: bp,
          selectedSource: selectedSource,
          editor: editor,
          breakpointActions: breakpointActions,
          editorActions: editorActions
        });
      })
    );
  }
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

exports.default = (0, _connect.connect)(state => ({
  // Retrieves only the first breakpoint per line so that the
  // breakpoint marker represents only the first breakpoint
  breakpoints: (0, _selectors.getFirstVisibleBreakpoints)(state),
  selectedSource: (0, _selectors.getSelectedSource)(state)
}), dispatch => ({
  breakpointActions: (0, _breakpoints.breakpointItemActions)(dispatch),
  editorActions: (0, _editor.editorItemActions)(dispatch)
}))(Breakpoints);

/***/ }),
/* 727 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _classnames = __webpack_require__(67);

var _classnames2 = _interopRequireDefault(_classnames);

var _editor = __webpack_require__(496);

var _selectedLocation = __webpack_require__(501);

var _prefs = __webpack_require__(492);

var _devtoolsContextmenu = __webpack_require__(420);

var _breakpoints = __webpack_require__(523);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const breakpointSvg = document.createElement("div"); /* This Source Code Form is subject to the terms of the Mozilla Public
                                                      * License, v. 2.0. If a copy of the MPL was not distributed with this
                                                      * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

breakpointSvg.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 15" width="60" height="15"><path d="M53.07.5H1.5c-.54 0-1 .46-1 1v12c0 .54.46 1 1 1h51.57c.58 0 1.15-.26 1.53-.7l4.7-6.3-4.7-6.3c-.38-.44-.95-.7-1.53-.7z"/></svg>';

class Breakpoint extends _react.PureComponent {
  constructor(...args) {
    var _temp;

    return _temp = super(...args), this.onClick = event => {
      const {
        cx,
        breakpointActions,
        editorActions,
        breakpoint,
        selectedSource
      } = this.props;

      // ignore right clicks
      if (event.ctrlKey && event.button === 0 || event.button === 2) {
        return;
      }

      event.stopPropagation();
      event.preventDefault();

      const selectedLocation = (0, _selectedLocation.getSelectedLocation)(breakpoint, selectedSource);
      if (event.metaKey) {
        return editorActions.continueToHere(cx, selectedLocation.line);
      }

      if (event.shiftKey) {
        if (_prefs.features.columnBreakpoints) {
          return breakpointActions.toggleBreakpointsAtLine(cx, !breakpoint.disabled, selectedLocation.line);
        }

        return breakpointActions.toggleDisabledBreakpoint(cx, breakpoint);
      }

      return breakpointActions.removeBreakpointsAtLine(cx, selectedLocation.sourceId, selectedLocation.line);
    }, this.onContextMenu = event => {
      const { cx, breakpoint, breakpointActions } = this.props;
      event.stopPropagation();
      event.preventDefault();
      (0, _devtoolsContextmenu.showMenu)(event, (0, _breakpoints.breakpointItems)(cx, breakpoint, breakpointActions));
    }, _temp;
  }

  componentDidMount() {
    this.addBreakpoint(this.props);
  }

  componentDidUpdate(prevProps) {
    this.removeBreakpoint(prevProps);
    this.addBreakpoint(this.props);
  }

  componentWillUnmount() {
    this.removeBreakpoint(this.props);
  }

  makeMarker() {
    const { breakpoint } = this.props;
    const bp = breakpointSvg.cloneNode(true);

    bp.className = (0, _classnames2.default)("editor new-breakpoint", {
      "breakpoint-disabled": breakpoint.disabled,
      "folding-enabled": _prefs.features.codeFolding
    });

    bp.onmousedown = this.onClick;
    // NOTE: flow does not know about oncontextmenu
    bp.oncontextmenu = this.onContextMenu;

    return bp;
  }

  addBreakpoint(props) {
    const { breakpoint, editor, selectedSource } = props;
    const selectedLocation = (0, _selectedLocation.getSelectedLocation)(breakpoint, selectedSource);

    // Hidden Breakpoints are never rendered on the client
    if (breakpoint.options.hidden) {
      return;
    }

    if (!selectedSource) {
      return;
    }

    const sourceId = selectedSource.id;
    const line = (0, _editor.toEditorLine)(sourceId, selectedLocation.line);
    const doc = (0, _editor.getDocument)(sourceId);

    doc.setGutterMarker(line, "breakpoints", this.makeMarker());

    editor.codeMirror.addLineClass(line, "line", "new-breakpoint");
    editor.codeMirror.removeLineClass(line, "line", "has-condition");
    editor.codeMirror.removeLineClass(line, "line", "has-log");

    if (breakpoint.options.logValue) {
      editor.codeMirror.addLineClass(line, "line", "has-log");
    } else if (breakpoint.options.condition) {
      editor.codeMirror.addLineClass(line, "line", "has-condition");
    }
  }

  removeBreakpoint(props) {
    const { selectedSource, breakpoint } = props;
    if (!selectedSource) {
      return;
    }

    const sourceId = selectedSource.id;
    const doc = (0, _editor.getDocument)(sourceId);

    if (!doc) {
      return;
    }

    const selectedLocation = (0, _selectedLocation.getSelectedLocation)(breakpoint, selectedSource);
    const line = (0, _editor.toEditorLine)(sourceId, selectedLocation.line);

    doc.setGutterMarker(line, "breakpoints", null);
    doc.removeLineClass(line, "line", "new-breakpoint");
    doc.removeLineClass(line, "line", "has-condition");
    doc.removeLineClass(line, "line", "has-log");
  }

  render() {
    return null;
  }
}

exports.default = Breakpoint;

/***/ }),
/* 728 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _ColumnBreakpoint = __webpack_require__(729);

var _ColumnBreakpoint2 = _interopRequireDefault(_ColumnBreakpoint);

var _selectors = __webpack_require__(490);

var _connect = __webpack_require__(491);

var _breakpoint = __webpack_require__(499);

var _breakpoints = __webpack_require__(523);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line max-len
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

class ColumnBreakpoints extends _react.Component {

  render() {
    const {
      cx,
      editor,
      columnBreakpoints,
      selectedSource,
      breakpointActions
    } = this.props;

    if (!selectedSource || selectedSource.isBlackBoxed) {
      return null;
    }

    let breakpoints;
    editor.codeMirror.operation(() => {
      breakpoints = columnBreakpoints.map(breakpoint => _react2.default.createElement(_ColumnBreakpoint2.default, {
        cx: cx,
        key: (0, _breakpoint.makeBreakpointId)(breakpoint.location),
        columnBreakpoint: breakpoint,
        editor: editor,
        source: selectedSource,
        breakpointActions: breakpointActions
      }));
    });
    return _react2.default.createElement(
      "div",
      null,
      breakpoints
    );
  }
}

const mapStateToProps = state => {
  return {
    cx: (0, _selectors.getContext)(state),
    selectedSource: (0, _selectors.getSelectedSource)(state),
    columnBreakpoints: (0, _selectors.visibleColumnBreakpoints)(state)
  };
};

exports.default = (0, _connect.connect)(mapStateToProps, dispatch => ({ breakpointActions: (0, _breakpoints.breakpointItemActions)(dispatch) }))(ColumnBreakpoints);

/***/ }),
/* 729 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _classnames = __webpack_require__(67);

var _classnames2 = _interopRequireDefault(_classnames);

var _devtoolsContextmenu = __webpack_require__(420);

var _editor = __webpack_require__(496);

var _breakpoints = __webpack_require__(523);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line max-len
const breakpointButton = document.createElement("button"); /* This Source Code Form is subject to the terms of the Mozilla Public
                                                            * License, v. 2.0. If a copy of the MPL was not distributed with this
                                                            * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

breakpointButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 11 13" width="11" height="13"><path d="M5.07.5H1.5c-.54 0-1 .46-1 1v10c0 .54.46 1 1 1h3.57c.58 0 1.15-.26 1.53-.7l3.7-5.3-3.7-5.3C6.22.76 5.65.5 5.07.5z"/></svg>';

function makeBookmark({ breakpoint }, { onClick, onContextMenu }) {
  const bp = breakpointButton.cloneNode(true);

  const isActive = breakpoint && !breakpoint.disabled;
  const isDisabled = breakpoint && breakpoint.disabled;
  const condition = breakpoint && breakpoint.options.condition;
  const logValue = breakpoint && breakpoint.options.logValue;

  bp.className = (0, _classnames2.default)("column-breakpoint", {
    "has-condition": condition,
    "has-log": logValue,
    active: isActive,
    disabled: isDisabled
  });

  bp.setAttribute("title", logValue || condition || "");
  bp.onclick = onClick;

  // NOTE: flow does not know about oncontextmenu
  bp.oncontextmenu = onContextMenu;

  return bp;
}

class ColumnBreakpoint extends _react.PureComponent {
  constructor(...args) {
    var _temp;

    return _temp = super(...args), this.addColumnBreakpoint = nextProps => {
      const { columnBreakpoint, source } = nextProps || this.props;

      const sourceId = source.id;
      const doc = (0, _editor.getDocument)(sourceId);
      if (!doc) {
        return;
      }

      const { line, column } = columnBreakpoint.location;
      const widget = makeBookmark(columnBreakpoint, {
        onClick: this.onClick,
        onContextMenu: this.onContextMenu
      });

      this.bookmark = doc.setBookmark({ line: line - 1, ch: column }, { widget });
    }, this.clearColumnBreakpoint = () => {
      if (this.bookmark) {
        this.bookmark.clear();
        this.bookmark = null;
      }
    }, this.onClick = event => {
      event.stopPropagation();
      event.preventDefault();
      const { cx, columnBreakpoint, breakpointActions } = this.props;
      if (columnBreakpoint.breakpoint) {
        breakpointActions.removeBreakpoint(cx, columnBreakpoint.breakpoint);
      } else {
        breakpointActions.addBreakpoint(cx, columnBreakpoint.location);
      }
    }, this.onContextMenu = event => {
      event.stopPropagation();
      event.preventDefault();
      const {
        cx,
        columnBreakpoint: { breakpoint, location },
        breakpointActions
      } = this.props;

      const items = breakpoint ? (0, _breakpoints.breakpointItems)(cx, breakpoint, breakpointActions) : (0, _breakpoints.createBreakpointItems)(cx, location, breakpointActions);

      (0, _devtoolsContextmenu.showMenu)(event, items);
    }, _temp;
  }

  componentDidMount() {
    this.addColumnBreakpoint();
  }

  componentWillUnmount() {
    this.clearColumnBreakpoint();
  }

  componentDidUpdate() {
    this.clearColumnBreakpoint();
    this.addColumnBreakpoint();
  }

  render() {
    return null;
  }
}
exports.default = ColumnBreakpoint;

/***/ }),
/* 730 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DebugLine = undefined;

var _react = __webpack_require__(6);

var _editor = __webpack_require__(496);

var _pause = __webpack_require__(550);

var _indentation = __webpack_require__(536);

var _connect = __webpack_require__(491);

var _selectors = __webpack_require__(490);

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function isDocumentReady(source, frame) {
  return frame && source && source.content && (0, _editor.hasDocument)(frame.location.sourceId);
}

class DebugLine extends _react.PureComponent {

  componentDidMount() {
    const { why, frame, source } = this.props;
    this.setDebugLine(why, frame, source);
  }

  componentWillUnmount() {
    const { why, frame, source } = this.props;
    this.clearDebugLine(why, frame, source);
  }

  componentDidUpdate(prevProps) {
    const { why, frame, source } = this.props;

    (0, _editor.startOperation)();
    this.clearDebugLine(prevProps.why, prevProps.frame, prevProps.source);
    this.setDebugLine(why, frame, source);
    (0, _editor.endOperation)();
  }

  setDebugLine(why, frame, source) {
    if (!isDocumentReady(source, frame)) {
      return;
    }
    const sourceId = frame.location.sourceId;
    const doc = (0, _editor.getDocument)(sourceId);

    let { line, column } = (0, _editor.toEditorPosition)(frame.location);
    const { markTextClass, lineClass } = this.getTextClasses(why);
    doc.addLineClass(line, "line", lineClass);

    const lineText = doc.getLine(line);
    column = Math.max(column, (0, _indentation.getIndentation)(lineText));

    // If component updates because user clicks on
    // another source tab, codeMirror will be null.
    const columnEnd = doc.cm ? (0, _editor.getTokenEnd)(doc.cm, line, column) : null;

    this.debugExpression = doc.markText({ ch: column, line }, { ch: columnEnd, line }, { className: markTextClass });
  }

  clearDebugLine(why, frame, source) {
    if (!isDocumentReady(source, frame)) {
      return;
    }

    if (this.debugExpression) {
      this.debugExpression.clear();
    }

    const sourceId = frame.location.sourceId;
    const { line } = (0, _editor.toEditorPosition)(frame.location);
    const doc = (0, _editor.getDocument)(sourceId);
    const { lineClass } = this.getTextClasses(why);
    doc.removeLineClass(line, "line", lineClass);
  }

  getTextClasses(why) {
    if ((0, _pause.isException)(why)) {
      return {
        markTextClass: "debug-expression-error",
        lineClass: "new-debug-line-error"
      };
    }

    return { markTextClass: "debug-expression", lineClass: "new-debug-line" };
  }

  render() {
    return null;
  }
}

exports.DebugLine = DebugLine;
const mapStateToProps = state => {
  const frame = (0, _selectors.getVisibleSelectedFrame)(state);
  return {
    frame,
    source: frame && (0, _selectors.getSourceWithContent)(state, frame.location.sourceId),
    why: (0, _selectors.getPauseReason)(state, (0, _selectors.getCurrentThread)(state))
  };
};

exports.default = (0, _connect.connect)(mapStateToProps)(DebugLine);

/***/ }),
/* 731 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HighlightLine = undefined;

var _react = __webpack_require__(6);

var _editor = __webpack_require__(496);

var _sourceDocuments = __webpack_require__(540);

var _connect = __webpack_require__(491);

var _selectors = __webpack_require__(490);

function isDebugLine(selectedFrame, selectedLocation) {
  if (!selectedFrame) {
    return;
  }

  return selectedFrame.location.sourceId == selectedLocation.sourceId && selectedFrame.location.line == selectedLocation.line;
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function isDocumentReady(selectedSourceWithContent, selectedLocation) {
  return selectedLocation && selectedSourceWithContent && selectedSourceWithContent.content && (0, _sourceDocuments.hasDocument)(selectedLocation.sourceId);
}

class HighlightLine extends _react.Component {
  constructor(...args) {
    var _temp;

    return _temp = super(...args), this.isStepping = false, this.previousEditorLine = null, _temp;
  }

  shouldComponentUpdate(nextProps) {
    const { selectedLocation, selectedSourceWithContent } = nextProps;
    return this.shouldSetHighlightLine(selectedLocation, selectedSourceWithContent);
  }

  componentDidUpdate(prevProps) {
    this.completeHighlightLine(prevProps);
  }

  componentDidMount() {
    this.completeHighlightLine(null);
  }

  shouldSetHighlightLine(selectedLocation, selectedSourceWithContent) {
    const { sourceId, line } = selectedLocation;
    const editorLine = (0, _editor.toEditorLine)(sourceId, line);

    if (!isDocumentReady(selectedSourceWithContent, selectedLocation)) {
      return false;
    }

    if (this.isStepping && editorLine === this.previousEditorLine) {
      return false;
    }

    return true;
  }

  completeHighlightLine(prevProps) {
    const {
      pauseCommand,
      selectedLocation,
      selectedFrame,
      selectedSourceWithContent
    } = this.props;
    if (pauseCommand) {
      this.isStepping = true;
    }

    (0, _editor.startOperation)();
    if (prevProps) {
      this.clearHighlightLine(prevProps.selectedLocation, prevProps.selectedSourceWithContent);
    }
    this.setHighlightLine(selectedLocation, selectedFrame, selectedSourceWithContent);
    (0, _editor.endOperation)();
  }

  setHighlightLine(selectedLocation, selectedFrame, selectedSourceWithContent) {
    const { sourceId, line } = selectedLocation;
    if (!this.shouldSetHighlightLine(selectedLocation, selectedSourceWithContent)) {
      return;
    }

    this.isStepping = false;
    const editorLine = (0, _editor.toEditorLine)(sourceId, line);
    this.previousEditorLine = editorLine;

    if (!line || isDebugLine(selectedFrame, selectedLocation)) {
      return;
    }

    const doc = (0, _sourceDocuments.getDocument)(sourceId);
    doc.addLineClass(editorLine, "line", "highlight-line");
    this.resetHighlightLine(doc, editorLine);
  }

  resetHighlightLine(doc, editorLine) {
    const editorWrapper = document.querySelector(".editor-wrapper");

    if (editorWrapper === null) {
      return;
    }

    const style = getComputedStyle(editorWrapper);
    const durationString = style.getPropertyValue("--highlight-line-duration");

    let duration = durationString.match(/\d+/);
    duration = duration.length ? Number(duration[0]) : 0;

    setTimeout(() => doc && doc.removeLineClass(editorLine, "line", "highlight-line"), duration);
  }

  clearHighlightLine(selectedLocation, selectedSourceWithContent) {
    if (!isDocumentReady(selectedSourceWithContent, selectedLocation)) {
      return;
    }

    const { line, sourceId } = selectedLocation;
    const editorLine = (0, _editor.toEditorLine)(sourceId, line);
    const doc = (0, _sourceDocuments.getDocument)(sourceId);
    doc.removeLineClass(editorLine, "line", "highlight-line");
  }

  render() {
    return null;
  }
}

exports.HighlightLine = HighlightLine;
exports.default = (0, _connect.connect)(state => ({
  pauseCommand: (0, _selectors.getPauseCommand)(state, (0, _selectors.getCurrentThread)(state)),
  selectedFrame: (0, _selectors.getVisibleSelectedFrame)(state),
  selectedLocation: (0, _selectors.getSelectedLocation)(state),
  selectedSourceWithContent: (0, _selectors.getSelectedSourceWithContent)(state)
}))(HighlightLine);

/***/ }),
/* 732 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _connect = __webpack_require__(491);

var _react = __webpack_require__(6);

var _selectors = __webpack_require__(490);

var _editor = __webpack_require__(496);

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

class EmptyLines extends _react.Component {
  componentDidMount() {
    this.disableEmptyLines();
  }

  componentDidUpdate() {
    this.disableEmptyLines();
  }

  componentWillUnmount() {
    const { editor } = this.props;

    editor.codeMirror.operation(() => {
      editor.codeMirror.eachLine(lineHandle => {
        editor.codeMirror.removeLineClass(lineHandle, "line", "empty-line");
      });
    });
  }

  disableEmptyLines() {
    const { breakableLines, selectedSource, editor } = this.props;

    editor.codeMirror.operation(() => {
      editor.codeMirror.eachLine(lineHandle => {
        const line = (0, _editor.fromEditorLine)(selectedSource.id, editor.codeMirror.getLineNumber(lineHandle));

        if (breakableLines.has(line)) {
          editor.codeMirror.removeLineClass(lineHandle, "line", "empty-line");
        } else {
          editor.codeMirror.addLineClass(lineHandle, "line", "empty-line");
        }
      });
    });
  }

  render() {
    return null;
  }
}

const mapStateToProps = state => {
  const selectedSource = (0, _selectors.getSelectedSource)(state);
  if (!selectedSource) {
    throw new Error("no selectedSource");
  }
  const breakableLines = (0, _selectors.getSelectedBreakableLines)(state);

  return {
    selectedSource,
    breakableLines
  };
};

exports.default = (0, _connect.connect)(mapStateToProps)(EmptyLines);

/***/ }),
/* 733 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _connect = __webpack_require__(491);

var _devtoolsContextmenu = __webpack_require__(420);

var _editor = __webpack_require__(496);

var _selectors = __webpack_require__(490);

var _editor2 = __webpack_require__(557);

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

class EditorMenu extends _react.Component {

  componentWillUpdate(nextProps) {
    this.props.clearContextMenu();
    if (nextProps.contextMenu) {
      this.showMenu(nextProps);
    }
  }

  showMenu(props) {
    const {
      cx,
      editor,
      selectedSourceWithContent,
      editorActions,
      hasPrettySource,
      isPaused,
      contextMenu: event
    } = props;

    const location = (0, _editor.getSourceLocationFromMouseEvent)(editor, selectedSourceWithContent.source,
    // Use a coercion, as contextMenu is optional
    event);

    (0, _devtoolsContextmenu.showMenu)(event, (0, _editor2.editorMenuItems)({
      cx,
      editorActions,
      selectedSourceWithContent,
      hasPrettySource,
      location,
      isPaused,
      selectionText: editor.codeMirror.getSelection().trim(),
      isTextSelected: editor.codeMirror.somethingSelected()
    }));
  }

  render() {
    return null;
  }
}

const mapStateToProps = (state, props) => ({
  cx: (0, _selectors.getThreadContext)(state),
  isPaused: (0, _selectors.getIsPaused)(state, (0, _selectors.getCurrentThread)(state)),
  hasPrettySource: !!(0, _selectors.getPrettySource)(state, props.selectedSourceWithContent.source.id)
});

const mapDispatchToProps = dispatch => ({
  editorActions: (0, _editor2.editorItemActions)(dispatch)
});

exports.default = (0, _connect.connect)(mapStateToProps, mapDispatchToProps)(EditorMenu);

/***/ }),
/* 734 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConditionalPanel = undefined;

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(112);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _connect = __webpack_require__(491);

var _classnames = __webpack_require__(67);

var _classnames2 = _interopRequireDefault(_classnames);

__webpack_require__(735);

var _editor = __webpack_require__(496);

var _actions = __webpack_require__(493);

var _actions2 = _interopRequireDefault(_actions);

var _selectors = __webpack_require__(490);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function addNewLine(doc) {
  const cursor = doc.getCursor();
  const pos = { line: cursor.line, ch: cursor.ch };
  doc.replaceRange("\n", pos);
}

class ConditionalPanel extends _react.PureComponent {

  constructor() {
    super();

    this.saveAndClose = () => {
      if (this.input) {
        this.setBreakpoint(this.input.value.trim());
      }

      this.props.closeConditionalPanel();
    };

    this.onKey = e => {
      if (e.key === "Enter") {
        if (this.codeMirror && e.altKey) {
          addNewLine(this.codeMirror.doc);
        } else {
          this.saveAndClose();
        }
      } else if (e.key === "Escape") {
        this.props.closeConditionalPanel();
      }
    };

    this.repositionOnScroll = () => {
      if (this.panelNode && this.scrollParent) {
        const { scrollLeft } = this.scrollParent;
        this.panelNode.style.transform = `translateX(${scrollLeft}px)`;
      }
    };

    this.createEditor = input => {
      const { log, editor } = this.props;

      const codeMirror = editor.CodeMirror.fromTextArea(input, {
        mode: "javascript",
        theme: "mozilla",
        placeholder: L10N.getStr(log ? "editor.conditionalPanel.logPoint.placeholder2" : "editor.conditionalPanel.placeholder2")
      });

      codeMirror.on("keydown", (cm, e) => {
        if (e.key === "Enter") {
          e.codemirrorIgnore = true;
        }
      });

      const codeMirrorWrapper = codeMirror.getWrapperElement();

      codeMirrorWrapper.addEventListener("keydown", e => {
        codeMirror.save();
        this.onKey(e);
      });

      this.input = input;
      this.codeMirror = codeMirror;
      codeMirror.focus();
      codeMirror.setCursor(codeMirror.lineCount(), 0);
    };

    this.cbPanel = null;
  }

  keepFocusOnInput() {
    if (this.input) {
      this.input.focus();
    }
  }

  setBreakpoint(value) {
    const { cx, location, log, breakpoint } = this.props;
    const options = breakpoint ? breakpoint.options : {};
    const type = log ? "logValue" : "condition";
    return this.props.setBreakpointOptions(cx, location, {
      ...options,
      [type]: value
    });
  }

  clearConditionalPanel() {
    if (this.cbPanel) {
      this.cbPanel.clear();
      this.cbPanel = null;
    }
    if (this.scrollParent) {
      this.scrollParent.removeEventListener("scroll", this.repositionOnScroll);
    }
  }

  componentWillMount() {
    return this.renderToWidget(this.props);
  }

  componentWillUpdate() {
    return this.clearConditionalPanel();
  }

  componentDidUpdate(prevProps) {
    this.keepFocusOnInput();
  }

  componentWillUnmount() {
    // This is called if CodeMirror is re-initializing itself before the
    // user closes the conditional panel. Clear the widget, and re-render it
    // as soon as this component gets remounted
    return this.clearConditionalPanel();
  }

  renderToWidget(props) {
    if (this.cbPanel) {
      this.clearConditionalPanel();
    }

    const { location, editor } = props;

    const editorLine = (0, _editor.toEditorLine)(location.sourceId, location.line || 0);
    this.cbPanel = editor.codeMirror.addLineWidget(editorLine, this.renderConditionalPanel(props), {
      coverGutter: true,
      noHScroll: true
    });
    if (this.input) {
      let parent = this.input.parentNode;
      while (parent) {
        if (parent instanceof HTMLElement && parent.classList.contains("CodeMirror-scroll")) {
          this.scrollParent = parent;
          break;
        }
        parent = parent.parentNode;
      }

      if (this.scrollParent) {
        this.scrollParent.addEventListener("scroll", this.repositionOnScroll);
        this.repositionOnScroll();
      }
    }
  }

  getDefaultValue() {
    const { breakpoint, log } = this.props;
    const options = breakpoint && breakpoint.options || {};
    return log ? options.logValue : options.condition;
  }

  renderConditionalPanel(props) {
    const { log } = props;
    const defaultValue = this.getDefaultValue();

    const panel = document.createElement("div");
    _reactDom2.default.render(_react2.default.createElement(
      "div",
      {
        className: (0, _classnames2.default)("conditional-breakpoint-panel", {
          "log-point": log
        }),
        onClick: () => this.keepFocusOnInput(),
        onBlur: this.props.closeConditionalPanel,
        ref: node => this.panelNode = node
      },
      _react2.default.createElement(
        "div",
        { className: "prompt" },
        "\xBB"
      ),
      _react2.default.createElement("textarea", {
        defaultValue: defaultValue,
        ref: input => this.createEditor(input)
      })
    ), panel);
    return panel;
  }

  render() {
    return null;
  }
}

exports.ConditionalPanel = ConditionalPanel;
const mapStateToProps = state => {
  const location = (0, _selectors.getConditionalPanelLocation)(state);
  const log = (0, _selectors.getLogPointStatus)(state);
  return {
    cx: (0, _selectors.getContext)(state),
    breakpoint: (0, _selectors.getBreakpointForLocation)(state, location),
    location,
    log
  };
};

const {
  setBreakpointOptions,
  openConditionalPanel,
  closeConditionalPanel
} = _actions2.default;

const mapDispatchToProps = {
  setBreakpointOptions,
  openConditionalPanel,
  closeConditionalPanel
};

exports.default = (0, _connect.connect)(mapStateToProps, mapDispatchToProps)(ConditionalPanel);

/***/ }),
/* 735 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 736 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 737 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 738 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 739 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _devtoolsSourceMap = __webpack_require__(182);

var _connect = __webpack_require__(491);

var _immutable = __webpack_require__(543);

var _actions = __webpack_require__(493);

var _actions2 = _interopRequireDefault(_actions);

var _selectors = __webpack_require__(490);

var _AccessibleImage = __webpack_require__(495);

var _AccessibleImage2 = _interopRequireDefault(_AccessibleImage);

var _prefs = __webpack_require__(492);

var _Breakpoints = __webpack_require__(740);

var _Breakpoints2 = _interopRequireDefault(_Breakpoints);

var _Expressions = __webpack_require__(746);

var _Expressions2 = _interopRequireDefault(_Expressions);

var _devtoolsSplitter = __webpack_require__(445);

var _devtoolsSplitter2 = _interopRequireDefault(_devtoolsSplitter);

var _Frames = __webpack_require__(748);

var _Frames2 = _interopRequireDefault(_Frames);

var _Workers = __webpack_require__(754);

var _Workers2 = _interopRequireDefault(_Workers);

var _Accordion = __webpack_require__(757);

var _Accordion2 = _interopRequireDefault(_Accordion);

var _CommandBar = __webpack_require__(608);

var _CommandBar2 = _interopRequireDefault(_CommandBar);

var _UtilsBar = __webpack_require__(759);

var _UtilsBar2 = _interopRequireDefault(_UtilsBar);

var _XHRBreakpoints = __webpack_require__(760);

var _XHRBreakpoints2 = _interopRequireDefault(_XHRBreakpoints);

var _EventListeners = __webpack_require__(762);

var _EventListeners2 = _interopRequireDefault(_EventListeners);

var _WhyPaused = __webpack_require__(610);

var _WhyPaused2 = _interopRequireDefault(_WhyPaused);

var _Scopes = __webpack_require__(765);

var _Scopes2 = _interopRequireDefault(_Scopes);

__webpack_require__(771);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function debugBtn(onClick, type, className, tooltip) {
  return _react2.default.createElement(
    "button",
    {
      onClick: onClick,
      className: `${type} ${className}`,
      key: type,
      title: tooltip
    },
    _react2.default.createElement(_AccessibleImage2.default, { className: type, title: tooltip, "aria-label": tooltip })
  );
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const mdnLink = "https://developer.mozilla.org/docs/Tools/Debugger/Using_the_Debugger_map_scopes_feature?utm_source=devtools&utm_medium=debugger-map-scopes";

class SecondaryPanes extends _react.Component {
  constructor(props) {
    super(props);

    this.onExpressionAdded = () => {
      this.setState({ showExpressionsInput: false });
    };

    this.onXHRAdded = () => {
      this.setState({ showXHRInput: false });
    };

    this.state = {
      showExpressionsInput: false,
      showXHRInput: false
    };
  }

  renderBreakpointsToggle() {
    const {
      cx,
      toggleAllBreakpoints,
      breakpoints,
      breakpointsDisabled
    } = this.props;
    const isIndeterminate = !breakpointsDisabled && breakpoints.some(x => x.disabled);

    if (_prefs.features.skipPausing || breakpoints.length === 0) {
      return null;
    }

    const inputProps = {
      type: "checkbox",
      "aria-label": breakpointsDisabled ? L10N.getStr("breakpoints.enable") : L10N.getStr("breakpoints.disable"),
      className: "breakpoints-toggle",
      disabled: false,
      key: "breakpoints-toggle",
      onChange: e => {
        e.stopPropagation();
        toggleAllBreakpoints(cx, !breakpointsDisabled);
      },
      onClick: e => e.stopPropagation(),
      checked: !breakpointsDisabled && !isIndeterminate,
      ref: input => {
        if (input) {
          input.indeterminate = isIndeterminate;
        }
      },
      title: breakpointsDisabled ? L10N.getStr("breakpoints.enable") : L10N.getStr("breakpoints.disable")
    };

    return _react2.default.createElement("input", inputProps);
  }

  watchExpressionHeaderButtons() {
    const { expressions } = this.props;

    const buttons = [];

    if (expressions.size) {
      buttons.push(debugBtn(evt => {
        evt.stopPropagation();
        this.props.evaluateExpressions(this.props.cx);
      }, "refresh", "refresh", L10N.getStr("watchExpressions.refreshButton")));
    }

    buttons.push(debugBtn(evt => {
      if (_prefs.prefs.expressionsVisible) {
        evt.stopPropagation();
      }
      this.setState({ showExpressionsInput: true });
    }, "plus", "plus", L10N.getStr("expressions.placeholder")));

    return buttons;
  }

  xhrBreakpointsHeaderButtons() {
    const buttons = [];

    buttons.push(debugBtn(evt => {
      if (_prefs.prefs.xhrBreakpointsVisible) {
        evt.stopPropagation();
      }
      this.setState({ showXHRInput: true });
    }, "plus", "plus", L10N.getStr("xhrBreakpoints.label")));

    return buttons;
  }

  getScopeItem() {
    return {
      header: L10N.getStr("scopes.header"),
      className: "scopes-pane",
      component: _react2.default.createElement(_Scopes2.default, null),
      opened: _prefs.prefs.scopesVisible,
      buttons: this.getScopesButtons(),
      onToggle: opened => {
        _prefs.prefs.scopesVisible = opened;
      }
    };
  }

  getScopesButtons() {
    const { selectedFrame, mapScopesEnabled } = this.props;

    if (!selectedFrame || (0, _devtoolsSourceMap.isGeneratedId)(selectedFrame.location.sourceId)) {
      return null;
    }

    return [_react2.default.createElement(
      "div",
      { key: "scopes-buttons" },
      _react2.default.createElement(
        "label",
        {
          className: "map-scopes-header",
          title: L10N.getStr("scopes.mapping.label"),
          onClick: e => e.stopPropagation()
        },
        _react2.default.createElement("input", {
          type: "checkbox",
          checked: mapScopesEnabled ? "checked" : "",
          onChange: e => this.props.toggleMapScopes()
        }),
        L10N.getStr("scopes.map.label")
      ),
      _react2.default.createElement(
        "a",
        {
          className: "mdn",
          target: "_blank",
          href: mdnLink,
          onClick: e => e.stopPropagation(),
          title: L10N.getStr("scopes.helpTooltip.label")
        },
        _react2.default.createElement(_AccessibleImage2.default, { className: "shortcuts" })
      )
    )];
  }

  getWatchItem() {
    return {
      header: L10N.getStr("watchExpressions.header"),
      className: "watch-expressions-pane",
      buttons: this.watchExpressionHeaderButtons(),
      component: _react2.default.createElement(_Expressions2.default, {
        showInput: this.state.showExpressionsInput,
        onExpressionAdded: this.onExpressionAdded
      }),
      opened: _prefs.prefs.expressionsVisible,
      onToggle: opened => {
        _prefs.prefs.expressionsVisible = opened;
      }
    };
  }

  getXHRItem() {
    return {
      header: L10N.getStr("xhrBreakpoints.header"),
      className: "xhr-breakpoints-pane",
      buttons: this.xhrBreakpointsHeaderButtons(),
      component: _react2.default.createElement(_XHRBreakpoints2.default, {
        showInput: this.state.showXHRInput,
        onXHRAdded: this.onXHRAdded
      }),
      opened: _prefs.prefs.xhrBreakpointsVisible,
      onToggle: opened => {
        _prefs.prefs.xhrBreakpointsVisible = opened;
      }
    };
  }

  getCallStackItem() {
    return {
      header: L10N.getStr("callStack.header"),
      className: "call-stack-pane",
      component: _react2.default.createElement(_Frames2.default, null),
      opened: _prefs.prefs.callStackVisible,
      onToggle: opened => {
        _prefs.prefs.callStackVisible = opened;
      }
    };
  }

  getWorkersItem() {
    return {
      header: _prefs.features.windowlessWorkers ? L10N.getStr("threadsHeader") : L10N.getStr("workersHeader"),
      className: "workers-pane",
      component: _react2.default.createElement(_Workers2.default, null),
      opened: _prefs.prefs.workersVisible,
      onToggle: opened => {
        _prefs.prefs.workersVisible = opened;
      }
    };
  }

  getBreakpointsItem() {
    const {
      shouldPauseOnExceptions,
      shouldPauseOnCaughtExceptions,
      pauseOnExceptions
    } = this.props;

    return {
      header: L10N.getStr("breakpoints.header"),
      className: "breakpoints-pane",
      buttons: [this.renderBreakpointsToggle()],
      component: _react2.default.createElement(_Breakpoints2.default, {
        shouldPauseOnExceptions: shouldPauseOnExceptions,
        shouldPauseOnCaughtExceptions: shouldPauseOnCaughtExceptions,
        pauseOnExceptions: pauseOnExceptions
      }),
      opened: _prefs.prefs.breakpointsVisible,
      onToggle: opened => {
        _prefs.prefs.breakpointsVisible = opened;
      }
    };
  }

  getEventListenersItem() {
    return {
      header: L10N.getStr("eventListenersHeader"),
      className: "event-listeners-pane",
      buttons: [],
      component: _react2.default.createElement(_EventListeners2.default, null),
      opened: _prefs.prefs.eventListenersVisible,
      onToggle: opened => {
        _prefs.prefs.eventListenersVisible = opened;
      }
    };
  }

  getStartItems() {
    const items = [];
    const { horizontal, hasFrames } = this.props;

    if (horizontal) {
      if (_prefs.features.workers && this.props.workers.length > 0) {
        items.push(this.getWorkersItem());
      }

      items.push(this.getWatchItem());
    }

    items.push(this.getBreakpointsItem());

    if (hasFrames) {
      items.push(this.getCallStackItem());
      if (horizontal) {
        items.push(this.getScopeItem());
      }
    }

    if (_prefs.features.xhrBreakpoints) {
      items.push(this.getXHRItem());
    }

    if (_prefs.features.eventListenersBreakpoints) {
      items.push(this.getEventListenersItem());
    }

    return items;
  }

  getEndItems() {
    if (this.props.horizontal) {
      return [];
    }

    const items = [];
    if (_prefs.features.workers && this.props.workers.length > 0) {
      items.push(this.getWorkersItem());
    }

    items.push(this.getWatchItem());

    if (this.props.hasFrames) {
      items.push(this.getScopeItem());
    }

    return items;
  }

  getItems() {
    return [...this.getStartItems(), ...this.getEndItems()];
  }

  renderHorizontalLayout() {
    const { renderWhyPauseDelay } = this.props;

    return _react2.default.createElement(
      "div",
      null,
      _react2.default.createElement(_WhyPaused2.default, { delay: renderWhyPauseDelay }),
      _react2.default.createElement(_Accordion2.default, { items: this.getItems() })
    );
  }

  renderVerticalLayout() {
    return _react2.default.createElement(_devtoolsSplitter2.default, {
      initialSize: "300px",
      minSize: 10,
      maxSize: "50%",
      splitterSize: 1,
      startPanel: _react2.default.createElement(
        "div",
        { style: { width: "inherit" } },
        _react2.default.createElement(_WhyPaused2.default, { delay: this.props.renderWhyPauseDelay }),
        _react2.default.createElement(_Accordion2.default, { items: this.getStartItems() })
      ),
      endPanel: _react2.default.createElement(_Accordion2.default, { items: this.getEndItems() })
    });
  }

  renderUtilsBar() {
    if (!_prefs.features.shortcuts) {
      return;
    }

    return _react2.default.createElement(_UtilsBar2.default, {
      horizontal: this.props.horizontal,
      toggleShortcutsModal: this.props.toggleShortcutsModal
    });
  }

  render() {
    return _react2.default.createElement(
      "div",
      { className: "secondary-panes-wrapper" },
      _react2.default.createElement(_CommandBar2.default, { horizontal: this.props.horizontal }),
      _react2.default.createElement(
        "div",
        { className: "secondary-panes" },
        this.props.horizontal ? this.renderHorizontalLayout() : this.renderVerticalLayout()
      ),
      this.renderUtilsBar()
    );
  }
}

// Checks if user is in debugging mode and adds a delay preventing
// excessive vertical 'jumpiness'
function getRenderWhyPauseDelay(state, thread) {
  const inPauseCommand = !!(0, _selectors.getPauseCommand)(state, thread);

  if (!inPauseCommand) {
    return 100;
  }

  return 0;
}

const mapStateToProps = state => {
  const thread = (0, _selectors.getCurrentThread)(state);

  return {
    cx: (0, _selectors.getThreadContext)(state),
    expressions: (0, _selectors.getExpressions)(state),
    hasFrames: !!(0, _selectors.getTopFrame)(state, thread),
    breakpoints: (0, _selectors.getBreakpointsList)(state),
    breakpointsDisabled: (0, _selectors.getBreakpointsDisabled)(state),
    isWaitingOnBreak: (0, _selectors.getIsWaitingOnBreak)(state, thread),
    renderWhyPauseDelay: getRenderWhyPauseDelay(state, thread),
    selectedFrame: (0, _selectors.getSelectedFrame)(state, thread),
    mapScopesEnabled: (0, _selectors.isMapScopesEnabled)(state),
    shouldPauseOnExceptions: (0, _selectors.getShouldPauseOnExceptions)(state),
    shouldPauseOnCaughtExceptions: (0, _selectors.getShouldPauseOnCaughtExceptions)(state),
    workers: (0, _selectors.getWorkers)(state)
  };
};

exports.default = (0, _connect.connect)(mapStateToProps, {
  toggleAllBreakpoints: _actions2.default.toggleAllBreakpoints,
  evaluateExpressions: _actions2.default.evaluateExpressions,
  pauseOnExceptions: _actions2.default.pauseOnExceptions,
  toggleMapScopes: _actions2.default.toggleMapScopes,
  breakOnNext: _actions2.default.breakOnNext
})(SecondaryPanes);

/***/ }),
/* 740 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(67);

var _classnames2 = _interopRequireDefault(_classnames);

var _connect = __webpack_require__(491);

var _ExceptionOption = __webpack_require__(604);

var _ExceptionOption2 = _interopRequireDefault(_ExceptionOption);

var _Breakpoint = __webpack_require__(741);

var _Breakpoint2 = _interopRequireDefault(_Breakpoint);

var _BreakpointHeading = __webpack_require__(743);

var _BreakpointHeading2 = _interopRequireDefault(_BreakpointHeading);

var _actions = __webpack_require__(493);

var _actions2 = _interopRequireDefault(_actions);

var _source = __webpack_require__(494);

var _selectedLocation = __webpack_require__(501);

var _createEditor = __webpack_require__(561);

var _breakpoint = __webpack_require__(499);

var _selectors = __webpack_require__(490);

__webpack_require__(745);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Breakpoints extends _react.Component {

  componentWillUnmount() {
    this.removeEditor();
  }

  getEditor() {
    if (!this.headlessEditor) {
      this.headlessEditor = (0, _createEditor.createHeadlessEditor)();
    }
    return this.headlessEditor;
  }

  removeEditor() {
    if (!this.headlessEditor) {
      return;
    }
    this.headlessEditor.destroy();
    this.headlessEditor = null;
  }

  renderExceptionsOptions() {
    const {
      breakpointSources,
      shouldPauseOnExceptions,
      shouldPauseOnCaughtExceptions,
      pauseOnExceptions
    } = this.props;

    const isEmpty = breakpointSources.length == 0;

    return _react2.default.createElement(
      "div",
      {
        className: (0, _classnames2.default)("breakpoints-exceptions-options", {
          empty: isEmpty
        })
      },
      _react2.default.createElement(_ExceptionOption2.default, {
        className: "breakpoints-exceptions",
        label: L10N.getStr("pauseOnExceptionsItem2"),
        isChecked: shouldPauseOnExceptions,
        onChange: () => pauseOnExceptions(!shouldPauseOnExceptions, false)
      }),
      shouldPauseOnExceptions && _react2.default.createElement(_ExceptionOption2.default, {
        className: "breakpoints-exceptions-caught",
        label: L10N.getStr("pauseOnCaughtExceptionsItem"),
        isChecked: shouldPauseOnCaughtExceptions,
        onChange: () => pauseOnExceptions(true, !shouldPauseOnCaughtExceptions)
      })
    );
  }

  renderBreakpoints() {
    const { breakpointSources, selectedSource } = this.props;
    if (!breakpointSources.length) {
      return null;
    }

    const sources = [...breakpointSources.map(({ source, breakpoints }) => source)];

    return _react2.default.createElement(
      "div",
      { className: "pane breakpoints-list" },
      breakpointSources.map(({ source, breakpoints, i }) => {
        const path = (0, _source.getDisplayPath)(source, sources);
        const sortedBreakpoints = (0, _breakpoint.sortSelectedBreakpoints)(breakpoints, selectedSource);

        return [_react2.default.createElement(_BreakpointHeading2.default, {
          source: source,
          sources: sources,
          path: path,
          key: source.url
        }), ...sortedBreakpoints.map(breakpoint => _react2.default.createElement(_Breakpoint2.default, {
          breakpoint: breakpoint,
          source: source,
          selectedSource: selectedSource,
          editor: this.getEditor(),
          key: (0, _breakpoint.makeBreakpointId)((0, _selectedLocation.getSelectedLocation)(breakpoint, selectedSource))
        }))];
      })
    );
  }

  render() {
    const { skipPausing } = this.props;
    return _react2.default.createElement(
      "div",
      { className: (0, _classnames2.default)("pane", skipPausing && "skip-pausing") },
      this.renderExceptionsOptions(),
      this.renderBreakpoints()
    );
  }
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const mapStateToProps = state => ({
  breakpointSources: (0, _selectors.getBreakpointSources)(state),
  selectedSource: (0, _selectors.getSelectedSource)(state),
  skipPausing: (0, _selectors.getSkipPausing)(state)
});

exports.default = (0, _connect.connect)(mapStateToProps, {
  pauseOnExceptions: _actions2.default.pauseOnExceptions
})(Breakpoints);

/***/ }),
/* 741 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _connect = __webpack_require__(491);

var _reselect = __webpack_require__(444);

var _classnames = __webpack_require__(67);

var _classnames2 = _interopRequireDefault(_classnames);

var _actions = __webpack_require__(493);

var _actions2 = _interopRequireDefault(_actions);

var _lodash = __webpack_require__(417);

var _BreakpointsContextMenu = __webpack_require__(742);

var _BreakpointsContextMenu2 = _interopRequireDefault(_BreakpointsContextMenu);

var _Button = __webpack_require__(502);

var _breakpoint = __webpack_require__(499);

var _selectedLocation = __webpack_require__(501);

var _prefs = __webpack_require__(492);

var _selectors = __webpack_require__(490);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

class Breakpoint extends _react.PureComponent {
  constructor(...args) {
    var _temp;

    return _temp = super(...args), this.onContextMenu = e => {
      (0, _BreakpointsContextMenu2.default)({ ...this.props, contextMenuEvent: e });
    }, this.onDoubleClick = () => {
      const { breakpoint, openConditionalPanel } = this.props;
      if (breakpoint.options.condition) {
        openConditionalPanel(this.selectedLocation);
      } else if (breakpoint.options.logValue) {
        openConditionalPanel(this.selectedLocation, true);
      }
    }, this.selectBreakpoint = event => {
      event.preventDefault();
      const { cx, selectSpecificLocation } = this.props;
      selectSpecificLocation(cx, this.selectedLocation);
    }, this.removeBreakpoint = event => {
      const { cx, removeBreakpoint, breakpoint } = this.props;
      event.stopPropagation();
      removeBreakpoint(cx, breakpoint);
    }, this.handleBreakpointCheckbox = () => {
      const { cx, breakpoint, enableBreakpoint, disableBreakpoint } = this.props;
      if (breakpoint.disabled) {
        enableBreakpoint(cx, breakpoint);
      } else {
        disableBreakpoint(cx, breakpoint);
      }
    }, this.highlightText = (0, _lodash.memoize)((text = "", editor) => {
      const node = document.createElement("div");
      editor.CodeMirror.runMode(text, "application/javascript", node);
      return { __html: node.innerHTML };
    }, text => text), _temp;
  }

  get selectedLocation() {
    const { breakpoint, selectedSource } = this.props;
    return (0, _selectedLocation.getSelectedLocation)(breakpoint, selectedSource);
  }

  isCurrentlyPausedAtBreakpoint() {
    const { frame } = this.props;
    if (!frame) {
      return false;
    }

    const bpId = _prefs.features.columnBreakpoints ? (0, _breakpoint.makeBreakpointId)(this.selectedLocation) : (0, _breakpoint.getLocationWithoutColumn)(this.selectedLocation);
    const frameId = _prefs.features.columnBreakpoints ? (0, _breakpoint.makeBreakpointId)(frame.selectedLocation) : (0, _breakpoint.getLocationWithoutColumn)(frame.selectedLocation);
    return bpId == frameId;
  }

  getBreakpointLocation() {
    const { source } = this.props;
    const { column, line } = this.selectedLocation;

    const isWasm = source && source.isWasm;
    const columnVal = _prefs.features.columnBreakpoints && column ? `:${column}` : "";
    const bpLocation = isWasm ? `0x${line.toString(16).toUpperCase()}` : `${line}${columnVal}`;

    return bpLocation;
  }

  getBreakpointText() {
    const { breakpoint, selectedSource } = this.props;
    const { condition, logValue } = breakpoint.options;
    return logValue || condition || (0, _breakpoint.getSelectedText)(breakpoint, selectedSource);
  }

  render() {
    const { breakpoint, editor } = this.props;
    const text = this.getBreakpointText();
    const labelId = `${breakpoint.id}-label`;

    return _react2.default.createElement(
      "div",
      {
        className: (0, _classnames2.default)({
          breakpoint,
          paused: this.isCurrentlyPausedAtBreakpoint(),
          disabled: breakpoint.disabled,
          "is-conditional": !!breakpoint.options.condition,
          "is-log": !!breakpoint.options.logValue
        }),
        onClick: this.selectBreakpoint,
        onDoubleClick: this.onDoubleClick,
        onContextMenu: this.onContextMenu
      },
      _react2.default.createElement("input", {
        id: breakpoint.id,
        type: "checkbox",
        className: "breakpoint-checkbox",
        checked: !breakpoint.disabled,
        onChange: this.handleBreakpointCheckbox,
        onClick: ev => ev.stopPropagation(),
        "aria-labelledby": labelId
      }),
      _react2.default.createElement(
        "span",
        {
          id: labelId,
          className: "breakpoint-label cm-s-mozilla devtools-monospace",
          onClick: this.selectBreakpoint,
          title: text
        },
        _react2.default.createElement("span", { dangerouslySetInnerHTML: this.highlightText(text, editor) })
      ),
      _react2.default.createElement(
        "div",
        { className: "breakpoint-line-close" },
        _react2.default.createElement(
          "div",
          { className: "breakpoint-line devtools-monospace" },
          this.getBreakpointLocation()
        ),
        _react2.default.createElement(_Button.CloseButton, {
          handleClick: e => this.removeBreakpoint(e),
          tooltip: L10N.getStr("breakpoints.removeBreakpointTooltip")
        })
      )
    );
  }
}

const getFormattedFrame = (0, _reselect.createSelector)(_selectors.getSelectedSource, _selectors.getSelectedFrame, (selectedSource, frame) => {
  if (!frame) {
    return null;
  }

  return {
    ...frame,
    selectedLocation: (0, _selectedLocation.getSelectedLocation)(frame, selectedSource)
  };
});

const mapStateToProps = state => ({
  cx: (0, _selectors.getContext)(state),
  breakpoints: (0, _selectors.getBreakpointsList)(state),
  frame: getFormattedFrame(state, (0, _selectors.getCurrentThread)(state))
});

exports.default = (0, _connect.connect)(mapStateToProps, {
  enableBreakpoint: _actions2.default.enableBreakpoint,
  removeBreakpoint: _actions2.default.removeBreakpoint,
  removeBreakpoints: _actions2.default.removeBreakpoints,
  removeAllBreakpoints: _actions2.default.removeAllBreakpoints,
  disableBreakpoint: _actions2.default.disableBreakpoint,
  selectSpecificLocation: _actions2.default.selectSpecificLocation,
  setBreakpointOptions: _actions2.default.setBreakpointOptions,
  toggleAllBreakpoints: _actions2.default.toggleAllBreakpoints,
  toggleBreakpoints: _actions2.default.toggleBreakpoints,
  toggleDisabledBreakpoint: _actions2.default.toggleDisabledBreakpoint,
  openConditionalPanel: _actions2.default.openConditionalPanel
})(Breakpoint);

/***/ }),
/* 742 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = showContextMenu;

var _devtoolsContextmenu = __webpack_require__(420);

var _selectedLocation = __webpack_require__(501);

var _actions = __webpack_require__(493);

var _actions2 = _interopRequireDefault(_actions);

var _prefs = __webpack_require__(492);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function showContextMenu(props) {
  const {
    cx,
    breakpoint,
    breakpoints,
    selectedSource,
    removeBreakpoint,
    removeBreakpoints,
    removeAllBreakpoints,
    toggleBreakpoints,
    toggleAllBreakpoints,
    toggleDisabledBreakpoint,
    selectSpecificLocation,
    setBreakpointOptions,
    openConditionalPanel,
    contextMenuEvent
  } = props;

  contextMenuEvent.preventDefault();

  const deleteSelfLabel = L10N.getStr("breakpointMenuItem.deleteSelf2.label");
  const deleteAllLabel = L10N.getStr("breakpointMenuItem.deleteAll2.label");
  const deleteOthersLabel = L10N.getStr("breakpointMenuItem.deleteOthers2.label");
  const enableSelfLabel = L10N.getStr("breakpointMenuItem.enableSelf2.label");
  const enableAllLabel = L10N.getStr("breakpointMenuItem.enableAll2.label");
  const enableOthersLabel = L10N.getStr("breakpointMenuItem.enableOthers2.label");
  const disableSelfLabel = L10N.getStr("breakpointMenuItem.disableSelf2.label");
  const disableAllLabel = L10N.getStr("breakpointMenuItem.disableAll2.label");
  const disableOthersLabel = L10N.getStr("breakpointMenuItem.disableOthers2.label");
  const removeConditionLabel = L10N.getStr("breakpointMenuItem.removeCondition2.label");
  const addConditionLabel = L10N.getStr("breakpointMenuItem.addCondition2.label");
  const editConditionLabel = L10N.getStr("breakpointMenuItem.editCondition2.label");

  const deleteSelfKey = L10N.getStr("breakpointMenuItem.deleteSelf2.accesskey");
  const deleteAllKey = L10N.getStr("breakpointMenuItem.deleteAll2.accesskey");
  const deleteOthersKey = L10N.getStr("breakpointMenuItem.deleteOthers2.accesskey");
  const enableSelfKey = L10N.getStr("breakpointMenuItem.enableSelf2.accesskey");
  const enableAllKey = L10N.getStr("breakpointMenuItem.enableAll2.accesskey");
  const enableOthersKey = L10N.getStr("breakpointMenuItem.enableOthers2.accesskey");
  const disableSelfKey = L10N.getStr("breakpointMenuItem.disableSelf2.accesskey");
  const disableAllKey = L10N.getStr("breakpointMenuItem.disableAll2.accesskey");
  const disableOthersKey = L10N.getStr("breakpointMenuItem.disableOthers2.accesskey");
  const removeConditionKey = L10N.getStr("breakpointMenuItem.removeCondition2.accesskey");
  const editConditionKey = L10N.getStr("breakpointMenuItem.editCondition2.accesskey");
  const addConditionKey = L10N.getStr("breakpointMenuItem.addCondition2.accesskey");

  const selectedLocation = (0, _selectedLocation.getSelectedLocation)(breakpoint, selectedSource);
  const otherBreakpoints = breakpoints.filter(b => b.id !== breakpoint.id);
  const enabledBreakpoints = breakpoints.filter(b => !b.disabled);
  const disabledBreakpoints = breakpoints.filter(b => b.disabled);
  const otherEnabledBreakpoints = breakpoints.filter(b => !b.disabled && b.id !== breakpoint.id);
  const otherDisabledBreakpoints = breakpoints.filter(b => b.disabled && b.id !== breakpoint.id);

  const deleteSelfItem = {
    id: "node-menu-delete-self",
    label: deleteSelfLabel,
    accesskey: deleteSelfKey,
    disabled: false,
    click: () => {
      removeBreakpoint(cx, breakpoint);
    }
  };

  const deleteAllItem = {
    id: "node-menu-delete-all",
    label: deleteAllLabel,
    accesskey: deleteAllKey,
    disabled: false,
    click: () => removeAllBreakpoints(cx)
  };

  const deleteOthersItem = {
    id: "node-menu-delete-other",
    label: deleteOthersLabel,
    accesskey: deleteOthersKey,
    disabled: false,
    click: () => removeBreakpoints(cx, otherBreakpoints)
  };

  const enableSelfItem = {
    id: "node-menu-enable-self",
    label: enableSelfLabel,
    accesskey: enableSelfKey,
    disabled: false,
    click: () => {
      toggleDisabledBreakpoint(cx, breakpoint);
    }
  };

  const enableAllItem = {
    id: "node-menu-enable-all",
    label: enableAllLabel,
    accesskey: enableAllKey,
    disabled: false,
    click: () => toggleAllBreakpoints(cx, false)
  };

  const enableOthersItem = {
    id: "node-menu-enable-others",
    label: enableOthersLabel,
    accesskey: enableOthersKey,
    disabled: false,
    click: () => toggleBreakpoints(cx, false, otherDisabledBreakpoints)
  };

  const disableSelfItem = {
    id: "node-menu-disable-self",
    label: disableSelfLabel,
    accesskey: disableSelfKey,
    disabled: false,
    click: () => {
      toggleDisabledBreakpoint(cx, breakpoint);
    }
  };

  const disableAllItem = {
    id: "node-menu-disable-all",
    label: disableAllLabel,
    accesskey: disableAllKey,
    disabled: false,
    click: () => toggleAllBreakpoints(cx, true)
  };

  const disableOthersItem = {
    id: "node-menu-disable-others",
    label: disableOthersLabel,
    accesskey: disableOthersKey,
    click: () => toggleBreakpoints(cx, true, otherEnabledBreakpoints)
  };

  const removeConditionItem = {
    id: "node-menu-remove-condition",
    label: removeConditionLabel,
    accesskey: removeConditionKey,
    disabled: false,
    click: () => setBreakpointOptions(cx, selectedLocation, {
      ...breakpoint.options,
      condition: null
    })
  };

  const addConditionItem = {
    id: "node-menu-add-condition",
    label: addConditionLabel,
    accesskey: addConditionKey,
    click: () => {
      selectSpecificLocation(cx, selectedLocation);
      openConditionalPanel(selectedLocation);
    },
    accelerator: L10N.getStr("toggleCondPanel.breakpoint.key")
  };

  const editConditionItem = {
    id: "node-menu-edit-condition",
    label: editConditionLabel,
    accesskey: editConditionKey,
    click: () => {
      selectSpecificLocation(cx, selectedLocation);
      openConditionalPanel(selectedLocation);
    },
    accelerator: L10N.getStr("toggleCondPanel.breakpoint.key")
  };

  const addLogPointItem = {
    id: "node-menu-add-log-point",
    label: L10N.getStr("editor.addLogPoint"),
    accesskey: L10N.getStr("editor.addLogPoint.accesskey"),
    disabled: false,
    click: () => openConditionalPanel(selectedLocation, true),
    accelerator: L10N.getStr("toggleCondPanel.logPoint.key")
  };

  const editLogPointItem = {
    id: "node-menu-edit-log-point",
    label: L10N.getStr("editor.editLogPoint"),
    accesskey: L10N.getStr("editor.editLogPoint.accesskey"),
    disabled: false,
    click: () => openConditionalPanel(selectedLocation, true),
    accelerator: L10N.getStr("toggleCondPanel.logPoint.key")
  };

  const removeLogPointItem = {
    id: "node-menu-remove-log",
    label: L10N.getStr("editor.removeLogPoint.label"),
    accesskey: L10N.getStr("editor.removeLogPoint.accesskey"),
    disabled: false,
    click: () => setBreakpointOptions(cx, selectedLocation, {
      ...breakpoint.options,
      logValue: null
    })
  };

  const logPointItem = breakpoint.options.logValue ? editLogPointItem : addLogPointItem;

  const hideEnableSelfItem = !breakpoint.disabled;
  const hideEnableAllItem = disabledBreakpoints.length === 0;
  const hideEnableOthersItem = otherDisabledBreakpoints.length === 0;
  const hideDisableAllItem = enabledBreakpoints.length === 0;
  const hideDisableOthersItem = otherEnabledBreakpoints.length === 0;
  const hideDisableSelfItem = breakpoint.disabled;

  const items = [{ item: enableSelfItem, hidden: () => hideEnableSelfItem }, { item: enableAllItem, hidden: () => hideEnableAllItem }, { item: enableOthersItem, hidden: () => hideEnableOthersItem }, {
    item: { type: "separator" },
    hidden: () => hideEnableSelfItem && hideEnableAllItem && hideEnableOthersItem
  }, { item: deleteSelfItem }, { item: deleteAllItem }, { item: deleteOthersItem, hidden: () => breakpoints.length === 1 }, {
    item: { type: "separator" },
    hidden: () => hideDisableSelfItem && hideDisableAllItem && hideDisableOthersItem
  }, { item: disableSelfItem, hidden: () => hideDisableSelfItem }, { item: disableAllItem, hidden: () => hideDisableAllItem }, { item: disableOthersItem, hidden: () => hideDisableOthersItem }, {
    item: { type: "separator" }
  }, {
    item: addConditionItem,
    hidden: () => breakpoint.options.condition
  }, {
    item: editConditionItem,
    hidden: () => !breakpoint.options.condition
  }, {
    item: removeConditionItem,
    hidden: () => !breakpoint.options.condition
  }, {
    item: logPointItem,
    hidden: () => !_prefs.features.logPoints
  }, {
    item: removeLogPointItem,
    hidden: () => !_prefs.features.logPoints || !breakpoint.options.logValue
  }];

  (0, _devtoolsContextmenu.showMenu)(contextMenuEvent, (0, _devtoolsContextmenu.buildMenu)(items));
  return null;
}

/***/ }),
/* 743 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _connect = __webpack_require__(491);

var _actions = __webpack_require__(493);

var _actions2 = _interopRequireDefault(_actions);

var _source = __webpack_require__(494);

var _selectors = __webpack_require__(490);

var _SourceIcon = __webpack_require__(555);

var _SourceIcon2 = _interopRequireDefault(_SourceIcon);

var _BreakpointHeadingsContextMenu = __webpack_require__(744);

var _BreakpointHeadingsContextMenu2 = _interopRequireDefault(_BreakpointHeadingsContextMenu);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class BreakpointHeading extends _react.PureComponent {
  constructor(...args) {
    var _temp;

    return _temp = super(...args), this.onContextMenu = e => {
      (0, _BreakpointHeadingsContextMenu2.default)({ ...this.props, contextMenuEvent: e });
    }, _temp;
  }

  render() {
    const {
      cx,
      sources,
      source,
      hasSiblingOfSameName,
      selectSource
    } = this.props;

    const path = (0, _source.getDisplayPath)(source, sources);
    const query = hasSiblingOfSameName ? (0, _source.getSourceQueryString)(source) : "";

    return _react2.default.createElement(
      "div",
      {
        className: "breakpoint-heading",
        title: (0, _source.getFileURL)(source, false),
        onClick: () => selectSource(cx, source.id),
        onContextMenu: this.onContextMenu
      },
      _react2.default.createElement(_SourceIcon2.default, {
        source: source,
        shouldHide: icon => ["file", "javascript"].includes(icon)
      }),
      _react2.default.createElement(
        "div",
        { className: "filename" },
        (0, _source.getTruncatedFileName)(source, query),
        path && _react2.default.createElement(
          "span",
          null,
          `../${path}/..`
        )
      )
    );
  }
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const mapStateToProps = (state, { source }) => ({
  cx: (0, _selectors.getContext)(state),
  hasSiblingOfSameName: (0, _selectors.getHasSiblingOfSameName)(state, source),
  breakpointsForSource: (0, _selectors.getBreakpointsForSource)(state, source.id)
});

exports.default = (0, _connect.connect)(mapStateToProps, {
  selectSource: _actions2.default.selectSource,
  enableBreakpointsInSource: _actions2.default.enableBreakpointsInSource,
  disableBreakpointsInSource: _actions2.default.disableBreakpointsInSource,
  removeBreakpointsInSource: _actions2.default.removeBreakpointsInSource
})(BreakpointHeading);

/***/ }),
/* 744 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = showContextMenu;

var _devtoolsContextmenu = __webpack_require__(420);

var _actions = __webpack_require__(493);

var _actions2 = _interopRequireDefault(_actions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function showContextMenu(props) {
  const {
    cx,
    source,
    breakpointsForSource,
    disableBreakpointsInSource,
    enableBreakpointsInSource,
    removeBreakpointsInSource,
    contextMenuEvent
  } = props;

  contextMenuEvent.preventDefault();

  const enableInSourceLabel = L10N.getStr("breakpointHeadingsMenuItem.enableInSource.label");
  const disableInSourceLabel = L10N.getStr("breakpointHeadingsMenuItem.disableInSource.label");
  const removeInSourceLabel = L10N.getStr("breakpointHeadingsMenuItem.removeInSource.label");
  const enableInSourceKey = L10N.getStr("breakpointHeadingsMenuItem.enableInSource.accesskey");
  const disableInSourceKey = L10N.getStr("breakpointHeadingsMenuItem.disableInSource.accesskey");
  const removeInSourceKey = L10N.getStr("breakpointHeadingsMenuItem.removeInSource.accesskey");

  const disableInSourceItem = {
    id: "node-menu-disable-in-source",
    label: disableInSourceLabel,
    accesskey: disableInSourceKey,
    disabled: false,
    click: () => disableBreakpointsInSource(cx, source)
  };

  const enableInSourceItem = {
    id: "node-menu-enable-in-source",
    label: enableInSourceLabel,
    accesskey: enableInSourceKey,
    disabled: false,
    click: () => enableBreakpointsInSource(cx, source)
  };

  const removeInSourceItem = {
    id: "node-menu-enable-in-source",
    label: removeInSourceLabel,
    accesskey: removeInSourceKey,
    disabled: false,
    click: () => removeBreakpointsInSource(cx, source)
  };

  const hideDisableInSourceItem = breakpointsForSource.every(breakpoint => breakpoint.disabled);
  const hideEnableInSourceItem = breakpointsForSource.every(breakpoint => !breakpoint.disabled);

  const items = [{ item: disableInSourceItem, hidden: () => hideDisableInSourceItem }, { item: enableInSourceItem, hidden: () => hideEnableInSourceItem }, { item: removeInSourceItem, hidden: () => false }];

  (0, _devtoolsContextmenu.showMenu)(contextMenuEvent, (0, _devtoolsContextmenu.buildMenu)(items));
}

/***/ }),
/* 745 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 746 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /* This Source Code Form is subject to the terms of the Mozilla Public
                                                                                                                                                                                                                                                                   * License, v. 2.0. If a copy of the MPL was not distributed with this
                                                                                                                                                                                                                                                                   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// eslint-disable-next-line import/named


var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _connect = __webpack_require__(491);

var _classnames = __webpack_require__(67);

var _classnames2 = _interopRequireDefault(_classnames);

var _prefs = __webpack_require__(492);

var _devtoolsReps = __webpack_require__(457);

var _actions = __webpack_require__(493);

var _actions2 = _interopRequireDefault(_actions);

var _selectors = __webpack_require__(490);

var _expressions = __webpack_require__(592);

var _firefox = __webpack_require__(508);

var _Button = __webpack_require__(502);

var _lodash = __webpack_require__(417);

__webpack_require__(747);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const { ObjectInspector } = _devtoolsReps.objectInspector;

class Expressions extends _react.Component {

  constructor(props) {
    super(props);

    this.clear = () => {
      this.setState(() => {
        this.props.clearExpressionError();
        return { editing: false, editIndex: -1, inputValue: "" };
      });
    };

    this.handleChange = e => {
      const target = e.target;
      if (_prefs.features.autocompleteExpression) {
        this.findAutocompleteMatches(target.value, target.selectionStart);
      }
      this.setState({ inputValue: target.value });
    };

    this.findAutocompleteMatches = (0, _lodash.debounce)((value, selectionStart) => {
      const { autocomplete } = this.props;
      autocomplete(this.props.cx, value, selectionStart);
    }, 250);

    this.handleKeyDown = e => {
      if (e.key === "Escape") {
        this.clear();
      }
    };

    this.hideInput = () => {
      this.setState({ focused: false });
      this.props.onExpressionAdded();
      this.props.clearExpressionError();
    };

    this.onFocus = () => {
      this.setState({ focused: true });
    };

    this.handleExistingSubmit = async (e, expression) => {
      e.preventDefault();
      e.stopPropagation();

      this.props.updateExpression(this.props.cx, this.state.inputValue, expression);
      this.hideInput();
    };

    this.handleNewSubmit = async e => {
      const { inputValue } = this.state;
      e.preventDefault();
      e.stopPropagation();

      this.props.clearExpressionError();
      await this.props.addExpression(this.props.cx, this.state.inputValue);
      this.setState({
        editing: false,
        editIndex: -1,
        inputValue: this.props.expressionError ? inputValue : ""
      });

      if (!this.props.expressionError) {
        this.hideInput();
      }

      this.props.clearAutocomplete();
    };

    this.renderExpression = (expression, index) => {
      const {
        expressionError,
        openLink,
        openElementInInspector,
        highlightDomElement,
        unHighlightDomElement
      } = this.props;

      const { editing, editIndex } = this.state;
      const { input, updating } = expression;
      const isEditingExpr = editing && editIndex === index;
      if (isEditingExpr || isEditingExpr && expressionError) {
        return this.renderExpressionEditInput(expression);
      }

      if (updating) {
        return;
      }

      const { value } = (0, _expressions.getValue)(expression);

      const root = {
        name: expression.input,
        path: input,
        contents: { value }
      };

      return _react2.default.createElement(
        "li",
        {
          className: "expression-container",
          key: input,
          title: expression.input,
          onDoubleClick: (items, options) => this.editExpression(expression, index)
        },
        _react2.default.createElement(
          "div",
          { className: "expression-content" },
          _react2.default.createElement(ObjectInspector, {
            roots: [root],
            autoExpandDepth: 0,
            disableWrap: true,
            openLink: openLink,
            createObjectClient: grip => (0, _firefox.createObjectClient)(grip),
            onDOMNodeClick: grip => openElementInInspector(grip),
            onInspectIconClick: grip => openElementInInspector(grip),
            onDOMNodeMouseOver: grip => highlightDomElement(grip),
            onDOMNodeMouseOut: grip => unHighlightDomElement(grip)
          }),
          _react2.default.createElement(
            "div",
            { className: "expression-container__close-btn" },
            _react2.default.createElement(_Button.CloseButton, {
              handleClick: e => this.deleteExpression(e, expression),
              tooltip: L10N.getStr("expressions.remove.tooltip")
            })
          )
        )
      );
    };

    this.state = {
      editing: false,
      editIndex: -1,
      inputValue: "",
      focused: false
    };
  }

  componentDidMount() {
    const { cx, expressions, evaluateExpressions, showInput } = this.props;

    if (expressions.size > 0) {
      evaluateExpressions(cx);
    }

    // Ensures that the input is focused when the "+"
    // is clicked while the panel is collapsed
    if (showInput && this._input) {
      this._input.focus();
    }
  }

  componentWillReceiveProps(nextProps) {
    if (this.state.editing && !nextProps.expressionError) {
      this.clear();
    }
  }

  shouldComponentUpdate(nextProps, nextState) {
    const { editing, inputValue, focused } = this.state;
    const {
      expressions,
      expressionError,
      showInput,
      autocompleteMatches
    } = this.props;

    return autocompleteMatches !== nextProps.autocompleteMatches || expressions !== nextProps.expressions || expressionError !== nextProps.expressionError || editing !== nextState.editing || inputValue !== nextState.inputValue || nextProps.showInput !== showInput || focused !== nextState.focused;
  }

  componentDidUpdate(prevProps, prevState) {
    const input = this._input;

    if (!input) {
      return;
    }

    if (!prevState.editing && this.state.editing) {
      input.setSelectionRange(0, input.value.length);
      input.focus();
    } else if (this.props.showInput && !this.state.focused) {
      input.focus();
    }
  }

  editExpression(expression, index) {
    this.setState({
      inputValue: expression.input,
      editing: true,
      editIndex: index
    });
  }

  deleteExpression(e, expression) {
    e.stopPropagation();
    const { deleteExpression } = this.props;
    deleteExpression(expression);
  }

  onBlur() {
    this.clear();
    this.hideInput();
  }

  renderAutoCompleteMatches() {
    if (!_prefs.features.autocompleteExpression) {
      return null;
    }
    const { autocompleteMatches } = this.props;
    if (autocompleteMatches) {
      return _react2.default.createElement(
        "datalist",
        { id: "autocomplete-matches" },
        autocompleteMatches.map((match, index) => {
          return _react2.default.createElement("option", { key: index, value: match });
        })
      );
    }
    return _react2.default.createElement("datalist", { id: "autocomplete-matches" });
  }

  renderNewExpressionInput() {
    const { expressionError } = this.props;
    const { editing, inputValue, focused } = this.state;
    const error = editing === false && expressionError === true;
    const placeholder = error ? L10N.getStr("expressions.errorMsg") : L10N.getStr("expressions.placeholder");

    return _react2.default.createElement(
      "li",
      {
        className: (0, _classnames2.default)("expression-input-container", { focused, error })
      },
      _react2.default.createElement(
        "form",
        { className: "expression-input-form", onSubmit: this.handleNewSubmit },
        _react2.default.createElement("input", _extends({
          className: "input-expression",
          type: "text",
          placeholder: placeholder,
          onChange: this.handleChange,
          onBlur: this.hideInput,
          onKeyDown: this.handleKeyDown,
          onFocus: this.onFocus,
          value: !editing ? inputValue : "",
          ref: c => this._input = c
        }, _prefs.features.autocompleteExpression && {
          list: "autocomplete-matches"
        })),
        this.renderAutoCompleteMatches(),
        _react2.default.createElement("input", { type: "submit", style: { display: "none" } })
      )
    );
  }

  renderExpressionEditInput(expression) {
    const { expressionError } = this.props;
    const { inputValue, editing, focused } = this.state;
    const error = editing === true && expressionError === true;

    return _react2.default.createElement(
      "span",
      {
        className: (0, _classnames2.default)("expression-input-container", { focused, error }),
        key: expression.input
      },
      _react2.default.createElement(
        "form",
        {
          className: "expression-input-form",
          onSubmit: e => this.handleExistingSubmit(e, expression)
        },
        _react2.default.createElement("input", _extends({
          className: (0, _classnames2.default)("input-expression", { error }),
          type: "text",
          onChange: this.handleChange,
          onBlur: this.clear,
          onKeyDown: this.handleKeyDown,
          onFocus: this.onFocus,
          value: editing ? inputValue : expression.input,
          ref: c => this._input = c
        }, _prefs.features.autocompleteExpression && {
          list: "autocomplete-matches"
        })),
        this.renderAutoCompleteMatches(),
        _react2.default.createElement("input", { type: "submit", style: { display: "none" } })
      )
    );
  }

  render() {
    const { expressions, showInput } = this.props;

    return _react2.default.createElement(
      "ul",
      { className: "pane expressions-list" },
      expressions.map(this.renderExpression),
      (showInput || !expressions.size) && this.renderNewExpressionInput()
    );
  }
}

const mapStateToProps = state => {
  return {
    cx: (0, _selectors.getThreadContext)(state),
    autocompleteMatches: (0, _selectors.getAutocompleteMatchset)(state),
    expressions: (0, _selectors.getExpressions)(state),
    expressionError: (0, _selectors.getExpressionError)(state)
  };
};

exports.default = (0, _connect.connect)(mapStateToProps, {
  autocomplete: _actions2.default.autocomplete,
  clearAutocomplete: _actions2.default.clearAutocomplete,
  addExpression: _actions2.default.addExpression,
  clearExpressionError: _actions2.default.clearExpressionError,
  evaluateExpressions: _actions2.default.evaluateExpressions,
  updateExpression: _actions2.default.updateExpression,
  deleteExpression: _actions2.default.deleteExpression,
  openLink: _actions2.default.openLink,
  openElementInInspector: _actions2.default.openElementInInspectorCommand,
  highlightDomElement: _actions2.default.highlightDomElement,
  unHighlightDomElement: _actions2.default.unHighlightDomElement
})(Expressions);

/***/ }),
/* 747 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 748 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Frames = undefined;

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _connect = __webpack_require__(491);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _Frame = __webpack_require__(605);

var _Frame2 = _interopRequireDefault(_Frame);

var _Group = __webpack_require__(749);

var _Group2 = _interopRequireDefault(_Group);

var _actions = __webpack_require__(493);

var _actions2 = _interopRequireDefault(_actions);

var _frames = __webpack_require__(510);

var _clipboard = __webpack_require__(512);

var _selectors = __webpack_require__(490);

__webpack_require__(753);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const NUM_FRAMES_SHOWN = 7;

class Frames extends _react.Component {

  constructor(props) {
    super(props);

    this.toggleFramesDisplay = () => {
      this.setState(prevState => ({
        showAllFrames: !prevState.showAllFrames
      }));
    };

    this.copyStackTrace = () => {
      const { frames } = this.props;
      const { l10n } = this.context;
      const framesToCopy = frames.map(f => (0, _frames.formatCopyName)(f, l10n)).join("\n");
      (0, _clipboard.copyToTheClipboard)(framesToCopy);
    };

    this.toggleFrameworkGrouping = () => {
      const { toggleFrameworkGrouping, frameworkGroupingOn } = this.props;
      toggleFrameworkGrouping(!frameworkGroupingOn);
    };

    this.state = {
      showAllFrames: !!props.disableFrameTruncate
    };
  }

  shouldComponentUpdate(nextProps, nextState) {
    const { frames, selectedFrame, frameworkGroupingOn } = this.props;
    const { showAllFrames } = this.state;
    return frames !== nextProps.frames || selectedFrame !== nextProps.selectedFrame || showAllFrames !== nextState.showAllFrames || frameworkGroupingOn !== nextProps.frameworkGroupingOn;
  }

  collapseFrames(frames) {
    const { frameworkGroupingOn } = this.props;
    if (!frameworkGroupingOn) {
      return frames;
    }

    return (0, _frames.collapseFrames)(frames);
  }

  truncateFrames(frames) {
    const numFramesToShow = this.state.showAllFrames ? frames.length : NUM_FRAMES_SHOWN;

    return frames.slice(0, numFramesToShow);
  }

  renderFrames(frames) {
    const {
      cx,
      selectFrame,
      selectedFrame,
      toggleBlackBox,
      frameworkGroupingOn,
      displayFullUrl,
      getFrameTitle,
      disableContextMenu,
      selectable = false
    } = this.props;

    const framesOrGroups = this.truncateFrames(this.collapseFrames(frames));


    // We're not using a <ul> because it adds new lines before and after when
    // the user copies the trace. Needed for the console which has several
    // places where we don't want to have those new lines.
    return _react2.default.createElement(
      "div",
      { role: "list" },
      framesOrGroups.map(frameOrGroup => frameOrGroup.id ? _react2.default.createElement(_Frame2.default, {
        cx: cx,
        frame: frameOrGroup,
        toggleFrameworkGrouping: this.toggleFrameworkGrouping,
        copyStackTrace: this.copyStackTrace,
        frameworkGroupingOn: frameworkGroupingOn,
        selectFrame: selectFrame,
        selectedFrame: selectedFrame,
        toggleBlackBox: toggleBlackBox,
        key: String(frameOrGroup.id),
        displayFullUrl: displayFullUrl,
        getFrameTitle: getFrameTitle,
        disableContextMenu: disableContextMenu,
        selectable: selectable
      }) : _react2.default.createElement(_Group2.default, {
        cx: cx,
        group: frameOrGroup,
        toggleFrameworkGrouping: this.toggleFrameworkGrouping,
        copyStackTrace: this.copyStackTrace,
        frameworkGroupingOn: frameworkGroupingOn,
        selectFrame: selectFrame,
        selectedFrame: selectedFrame,
        toggleBlackBox: toggleBlackBox,
        key: frameOrGroup[0].id,
        displayFullUrl: displayFullUrl,
        getFrameTitle: getFrameTitle,
        disableContextMenu: disableContextMenu,
        selectable: selectable
      }))
    );
  }

  renderToggleButton(frames) {
    const { l10n } = this.context;
    const buttonMessage = this.state.showAllFrames ? l10n.getStr("callStack.collapse") : l10n.getStr("callStack.expand");

    frames = this.collapseFrames(frames);
    if (frames.length <= NUM_FRAMES_SHOWN) {
      return null;
    }

    return _react2.default.createElement(
      "div",
      { className: "show-more-container" },
      _react2.default.createElement(
        "button",
        { className: "show-more", onClick: this.toggleFramesDisplay },
        buttonMessage
      )
    );
  }

  render() {
    const { frames, disableFrameTruncate } = this.props;

    if (!frames) {
      return _react2.default.createElement(
        "div",
        { className: "pane frames" },
        _react2.default.createElement(
          "div",
          { className: "pane-info empty" },
          L10N.getStr("callStack.notPaused")
        )
      );
    }

    return _react2.default.createElement(
      "div",
      { className: "pane frames" },
      this.renderFrames(frames),
      disableFrameTruncate ? null : this.renderToggleButton(frames)
    );
  }
}

Frames.contextTypes = { l10n: _propTypes2.default.object };

const mapStateToProps = state => ({
  cx: (0, _selectors.getThreadContext)(state),
  frames: (0, _selectors.getCallStackFrames)(state),
  frameworkGroupingOn: (0, _selectors.getFrameworkGroupingState)(state),
  selectedFrame: (0, _selectors.getSelectedFrame)(state, (0, _selectors.getCurrentThread)(state))
});

exports.default = (0, _connect.connect)(mapStateToProps, {
  selectFrame: _actions2.default.selectFrame,
  toggleBlackBox: _actions2.default.toggleBlackBox,
  toggleFrameworkGrouping: _actions2.default.toggleFrameworkGrouping,
  disableFrameTruncate: false,
  disableContextMenu: false,
  displayFullUrl: false
})(Frames);

// Export the non-connected component in order to use it outside of the debugger
// panel (e.g. console, netmonitor, …).

exports.Frames = Frames;

/***/ }),
/* 749 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(0);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = __webpack_require__(67);

var _classnames2 = _interopRequireDefault(_classnames);

var _frames = __webpack_require__(510);

var _FrameMenu = __webpack_require__(606);

var _FrameMenu2 = _interopRequireDefault(_FrameMenu);

var _AccessibleImage = __webpack_require__(495);

var _AccessibleImage2 = _interopRequireDefault(_AccessibleImage);

var _Frame = __webpack_require__(605);

var _Frame2 = _interopRequireDefault(_Frame);

__webpack_require__(750);

var _actions = __webpack_require__(493);

var _actions2 = _interopRequireDefault(_actions);

var _Badge = __webpack_require__(751);

var _Badge2 = _interopRequireDefault(_Badge);

var _FrameIndent = __webpack_require__(607);

var _FrameIndent2 = _interopRequireDefault(_FrameIndent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function FrameLocation({ frame, expanded }) {
  const library = frame.library || (0, _frames.getLibraryFromUrl)(frame);
  if (!library) {
    return null;
  }

  const arrowClassName = (0, _classnames2.default)("arrow", { expanded });
  return _react2.default.createElement(
    "span",
    { className: "group-description" },
    _react2.default.createElement(_AccessibleImage2.default, { className: arrowClassName }),
    _react2.default.createElement(_AccessibleImage2.default, { className: `annotation-logo ${library.toLowerCase()}` }),
    _react2.default.createElement(
      "span",
      { className: "group-description-name" },
      library
    )
  );
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

FrameLocation.displayName = "FrameLocation";

class Group extends _react.Component {

  constructor(...args) {
    super(...args);

    this.toggleFrames = event => {
      event.stopPropagation();
      this.setState(prevState => ({ expanded: !prevState.expanded }));
    };

    this.state = { expanded: false };
  }

  onContextMenu(event) {
    const {
      group,
      copyStackTrace,
      toggleFrameworkGrouping,
      toggleBlackBox,
      frameworkGroupingOn
    } = this.props;
    const frame = group[0];
    (0, _FrameMenu2.default)(frame, frameworkGroupingOn, { copyStackTrace, toggleFrameworkGrouping, toggleBlackBox }, event);
  }

  renderFrames() {
    const {
      cx,
      group,
      selectFrame,
      selectedFrame,
      toggleFrameworkGrouping,
      frameworkGroupingOn,
      toggleBlackBox,
      copyStackTrace,
      displayFullUrl,
      getFrameTitle,
      disableContextMenu,
      selectable
    } = this.props;

    const { expanded } = this.state;
    if (!expanded) {
      return null;
    }

    return _react2.default.createElement(
      "div",
      { className: "frames-list" },
      group.reduce((acc, frame, i) => {
        if (selectable) {
          acc.push(_react2.default.createElement(_FrameIndent2.default, { key: `frame-indent-${i}` }));
        }
        return acc.concat(_react2.default.createElement(_Frame2.default, {
          cx: cx,
          copyStackTrace: copyStackTrace,
          frame: frame,
          frameworkGroupingOn: frameworkGroupingOn,
          hideLocation: true,
          key: frame.id,
          selectedFrame: selectedFrame,
          selectFrame: selectFrame,
          shouldMapDisplayName: false,
          toggleBlackBox: toggleBlackBox,
          toggleFrameworkGrouping: toggleFrameworkGrouping,
          displayFullUrl: displayFullUrl,
          getFrameTitle: getFrameTitle,
          disableContextMenu: disableContextMenu,
          selectable: selectable
        }));
      }, [])
    );
  }

  renderDescription() {
    const { l10n } = this.context;
    const { selectable, group } = this.props;

    const frame = group[0];
    const expanded = this.state.expanded;
    const l10NEntry = this.state.expanded ? "callStack.group.collapseTooltip" : "callStack.group.expandTooltip";
    const title = l10n.getFormatStr(l10NEntry, frame.library);

    return _react2.default.createElement(
      "div",
      {
        role: "listitem",
        key: frame.id,
        className: (0, _classnames2.default)("group"),
        onClick: this.toggleFrames,
        tabIndex: 0,
        title: title
      },
      selectable && _react2.default.createElement(_FrameIndent2.default, null),
      _react2.default.createElement(FrameLocation, { frame: frame, expanded: expanded }),
      selectable && _react2.default.createElement(
        "span",
        { className: "clipboard-only" },
        " "
      ),
      _react2.default.createElement(
        _Badge2.default,
        null,
        this.props.group.length
      ),
      selectable && _react2.default.createElement("br", { className: "clipboard-only" })
    );
  }

  render() {
    const { expanded } = this.state;
    const { disableContextMenu } = this.props;
    return _react2.default.createElement(
      "div",
      {
        className: (0, _classnames2.default)("frames-group", { expanded }),
        onContextMenu: disableContextMenu ? null : e => this.onContextMenu(e)
      },
      this.renderDescription(),
      this.renderFrames()
    );
  }
}

exports.default = Group;
Group.displayName = "Group";
Group.contextTypes = { l10n: _propTypes2.default.object };

/***/ }),
/* 750 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 751 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

__webpack_require__(752);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const Badge = ({ children }) => _react2.default.createElement(
  "span",
  { className: "badge text-white text-center" },
  children
);

exports.default = Badge;

/***/ }),
/* 752 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 753 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 754 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Workers = undefined;

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _connect = __webpack_require__(491);

var _actions = __webpack_require__(493);

var _actions2 = _interopRequireDefault(_actions);

var _selectors = __webpack_require__(490);

var _workers = __webpack_require__(531);

var _prefs = __webpack_require__(492);

var _Worker = __webpack_require__(755);

var _Worker2 = _interopRequireDefault(_Worker);

var _AccessibleImage = __webpack_require__(495);

var _AccessibleImage2 = _interopRequireDefault(_AccessibleImage);

__webpack_require__(756);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Workers extends _react.Component {
  renderWorker(thread) {
    const { openWorkerToolbox } = this.props;

    return _react2.default.createElement(
      "div",
      {
        className: "worker",
        key: thread.actor,
        onClick: () => openWorkerToolbox(thread)
      },
      _react2.default.createElement(
        "div",
        { className: "icon" },
        _react2.default.createElement(_AccessibleImage2.default, { className: "worker" })
      ),
      _react2.default.createElement(
        "div",
        { className: "label" },
        (0, _workers.getDisplayName)(thread)
      )
    );
  }

  render() {
    const { threads } = this.props;

    const workerList = _prefs.features.windowlessWorkers ? threads.map(thread => _react2.default.createElement(_Worker2.default, { thread: thread, key: thread.actor })) : threads.filter(thread => thread.actorID).map(worker => this.renderWorker(worker));

    return _react2.default.createElement(
      "div",
      { className: "pane workers-list" },
      workerList
    );
  }
}

exports.Workers = Workers; /* This Source Code Form is subject to the terms of the Mozilla Public
                            * License, v. 2.0. If a copy of the MPL was not distributed with this
                            * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const mapStateToProps = state => ({
  threads: (0, _selectors.getThreads)(state)
});

exports.default = (0, _connect.connect)(mapStateToProps, {
  openWorkerToolbox: _actions2.default.openWorkerToolbox
})(Workers);

/***/ }),
/* 755 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Worker = undefined;

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _connect = __webpack_require__(491);

var _classnames = __webpack_require__(67);

var _classnames2 = _interopRequireDefault(_classnames);

var _actions = __webpack_require__(493);

var _actions2 = _interopRequireDefault(_actions);

var _selectors = __webpack_require__(490);

var _workers = __webpack_require__(531);

var _AccessibleImage = __webpack_require__(495);

var _AccessibleImage2 = _interopRequireDefault(_AccessibleImage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Worker extends _react.Component {
  constructor(...args) {
    var _temp;

    return _temp = super(...args), this.onSelectThread = () => {
      const { thread } = this.props;
      this.props.selectThread(this.props.cx, thread.actor);
    }, _temp;
  }

  render() {
    const { currentThread, isPaused, thread } = this.props;

    const worker = (0, _workers.isWorker)(thread);
    const label = worker ? (0, _workers.getDisplayName)(thread) : L10N.getStr("mainThread");

    return _react2.default.createElement(
      "div",
      {
        className: (0, _classnames2.default)("worker", {
          selected: thread.actor == currentThread
        }),
        key: thread.actor,
        onClick: this.onSelectThread
      },
      _react2.default.createElement(
        "div",
        { className: "icon" },
        _react2.default.createElement(_AccessibleImage2.default, { className: worker ? "worker" : "window" })
      ),
      _react2.default.createElement(
        "div",
        { className: "label" },
        label
      ),
      isPaused ? _react2.default.createElement(
        "div",
        { className: "pause-badge" },
        _react2.default.createElement(_AccessibleImage2.default, { className: "pause" })
      ) : null
    );
  }
}

exports.Worker = Worker; /* This Source Code Form is subject to the terms of the Mozilla Public
                          * License, v. 2.0. If a copy of the MPL was not distributed with this
                          * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const mapStateToProps = (state, props) => ({
  cx: (0, _selectors.getContext)(state),
  currentThread: (0, _selectors.getCurrentThread)(state),
  isPaused: (0, _selectors.getIsPaused)(state, props.thread.actor)
});

exports.default = (0, _connect.connect)(mapStateToProps, {
  selectThread: _actions2.default.selectThread
})(Worker);

/***/ }),
/* 756 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 757 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _AccessibleImage = __webpack_require__(495);

var _AccessibleImage2 = _interopRequireDefault(_AccessibleImage);

__webpack_require__(758);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Accordion extends _react.Component {
  constructor(props) {
    super(props);

    this.renderContainer = (item, i) => {
      const { opened } = item;

      return _react2.default.createElement(
        "li",
        { className: item.className, key: i },
        _react2.default.createElement(
          "h2",
          {
            className: "_header",
            tabIndex: "0",
            onKeyDown: e => this.onHandleHeaderKeyDown(e, i),
            onClick: () => this.handleHeaderClick(i)
          },
          _react2.default.createElement(_AccessibleImage2.default, { className: `arrow ${opened ? "expanded" : ""}` }),
          _react2.default.createElement(
            "span",
            { className: "header-label" },
            item.header
          ),
          item.buttons ? _react2.default.createElement(
            "div",
            { className: "header-buttons", tabIndex: "-1" },
            item.buttons
          ) : null
        ),
        opened && _react2.default.createElement(
          "div",
          { className: "_content" },
          (0, _react.cloneElement)(item.component, item.componentProps || {})
        )
      );
    };

    this.state = {
      opened: props.items.map(item => item.opened),
      created: []
    };
  }

  handleHeaderClick(i) {
    const item = this.props.items[i];
    const opened = !item.opened;
    item.opened = opened;

    if (item.onToggle) {
      item.onToggle(opened);
    }

    // We force an update because otherwise the accordion
    // would not re-render
    this.forceUpdate();
  }

  onHandleHeaderKeyDown(e, i) {
    if (e && (e.key === " " || e.key === "Enter")) {
      this.handleHeaderClick(i);
    }
  }

  render() {
    return _react2.default.createElement(
      "ul",
      { className: "accordion" },
      this.props.items.map(this.renderContainer)
    );
  }
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

exports.default = Accordion;

/***/ }),
/* 758 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 759 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(67);

var _classnames2 = _interopRequireDefault(_classnames);

var _CommandBarButton = __webpack_require__(554);

__webpack_require__(609);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

class UtilsBar extends _react.Component {
  renderUtilButtons() {
    return [(0, _CommandBarButton.debugBtn)(this.props.toggleShortcutsModal, "shortcuts", "active", L10N.getStr("shortcuts.buttonName"), false)];
  }

  render() {
    return _react2.default.createElement(
      "div",
      {
        className: (0, _classnames2.default)("command-bar bottom", {
          vertical: !this.props.horizontal
        })
      },
      this.renderUtilButtons()
    );
  }
}

exports.default = UtilsBar;

/***/ }),
/* 760 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _connect = __webpack_require__(491);

var _classnames = __webpack_require__(67);

var _classnames2 = _interopRequireDefault(_classnames);

var _actions = __webpack_require__(493);

var _actions2 = _interopRequireDefault(_actions);

var _Button = __webpack_require__(502);

__webpack_require__(761);

var _selectors = __webpack_require__(490);

var _ExceptionOption = __webpack_require__(604);

var _ExceptionOption2 = _interopRequireDefault(_ExceptionOption);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// At present, the "Pause on any URL" checkbox creates an xhrBreakpoint
// of "ANY" with no path, so we can remove that before creating the list
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function getExplicitXHRBreakpoints(xhrBreakpoints) {
  return xhrBreakpoints.filter(bp => bp.path !== "");
}

const xhrMethods = ["ANY", "GET", "POST", "PUT", "HEAD", "DELETE", "PATCH", "OPTIONS"];

class XHRBreakpoints extends _react.Component {

  constructor(props) {
    super(props);

    this.handleNewSubmit = e => {
      e.preventDefault();
      e.stopPropagation();

      const setXHRBreakpoint = function () {
        this.props.setXHRBreakpoint(this.state.inputValue, this.state.inputMethod);
        this.hideInput();
      };

      // force update inputMethod in state for mochitest purposes
      // before setting XHR breakpoint
      this.setState(
      // $FlowIgnore
      { inputMethod: e.target.children[1].value }, setXHRBreakpoint);
    };

    this.handleExistingSubmit = e => {
      e.preventDefault();
      e.stopPropagation();

      const { editIndex, inputValue, inputMethod } = this.state;
      const { xhrBreakpoints } = this.props;
      const { path, method } = xhrBreakpoints[editIndex];

      if (path !== inputValue || method != inputMethod) {
        this.props.updateXHRBreakpoint(editIndex, inputValue, inputMethod);
      }

      this.hideInput();
    };

    this.handleChange = e => {
      const target = e.target;
      this.setState({ inputValue: target.value });
    };

    this.handleMethodChange = e => {
      const target = e.target;
      this.setState({
        focused: true,
        editing: true,
        inputMethod: target.value
      });
    };

    this.hideInput = () => {
      if (this.state.clickedOnFormElement) {
        this.setState({
          focused: true,
          clickedOnFormElement: false
        });
      } else {
        this.setState({
          focused: false,
          editing: false,
          editIndex: -1,
          inputValue: "",
          inputMethod: "ANY"
        });
        this.props.onXHRAdded();
      }
    };

    this.onFocus = () => {
      this.setState({ focused: true, editing: true });
    };

    this.onMouseDown = e => {
      this.setState({ editing: false, clickedOnFormElement: true });
    };

    this.handleTab = e => {
      if (e.key !== "Tab") {
        return;
      }

      if (e.target.nodeName === "INPUT") {
        this.setState({
          clickedOnFormElement: true,
          editing: false
        });
      } else if (e.target.nodeName === "SELECT" && !e.shiftKey) {
        // The user has tabbed off the select and we should
        // cancel the edit
        this.hideInput();
      }
    };

    this.editExpression = index => {
      const { xhrBreakpoints } = this.props;
      const { path, method } = xhrBreakpoints[index];
      this.setState({
        inputValue: path,
        inputMethod: method,
        editing: true,
        editIndex: index
      });
    };

    this.handleCheckbox = index => {
      const {
        xhrBreakpoints,
        enableXHRBreakpoint,
        disableXHRBreakpoint
      } = this.props;
      const breakpoint = xhrBreakpoints[index];
      if (breakpoint.disabled) {
        enableXHRBreakpoint(index);
      } else {
        disableXHRBreakpoint(index);
      }
    };

    this.renderBreakpoint = breakpoint => {
      const { path, disabled, method } = breakpoint;
      const { editIndex } = this.state;
      const { removeXHRBreakpoint, xhrBreakpoints } = this.props;

      // The "pause on any" checkbox
      if (!path) {
        return;
      }

      // Finds the xhrbreakpoint so as to not make assumptions about position
      const index = xhrBreakpoints.findIndex(bp => bp.path === path && bp.method === method);

      if (index === editIndex) {
        return this.renderXHRInput(this.handleExistingSubmit);
      }

      return _react2.default.createElement(
        "li",
        {
          className: "xhr-container",
          key: `${path}-${method}`,
          title: path,
          onDoubleClick: (items, options) => this.editExpression(index)
        },
        _react2.default.createElement(
          "label",
          null,
          _react2.default.createElement("input", {
            type: "checkbox",
            className: "xhr-checkbox",
            checked: !disabled,
            onChange: () => this.handleCheckbox(index),
            onClick: ev => ev.stopPropagation()
          }),
          _react2.default.createElement(
            "div",
            { className: "xhr-label-method" },
            method
          ),
          _react2.default.createElement(
            "div",
            { className: "xhr-label-url" },
            path
          ),
          _react2.default.createElement(
            "div",
            { className: "xhr-container__close-btn" },
            _react2.default.createElement(_Button.CloseButton, { handleClick: e => removeXHRBreakpoint(index) })
          )
        )
      );
    };

    this.renderBreakpoints = () => {
      const { showInput, xhrBreakpoints } = this.props;
      const explicitXhrBreakpoints = getExplicitXHRBreakpoints(xhrBreakpoints);

      return _react2.default.createElement(
        "ul",
        { className: "pane expressions-list" },
        explicitXhrBreakpoints.map(this.renderBreakpoint),
        (showInput || explicitXhrBreakpoints.length === 0) && this.renderXHRInput(this.handleNewSubmit)
      );
    };

    this.renderCheckbox = () => {
      const { shouldPauseOnAny, togglePauseOnAny, xhrBreakpoints } = this.props;
      const explicitXhrBreakpoints = getExplicitXHRBreakpoints(xhrBreakpoints);

      return _react2.default.createElement(
        "div",
        {
          className: (0, _classnames2.default)("breakpoints-exceptions-options", {
            empty: explicitXhrBreakpoints.length === 0
          })
        },
        _react2.default.createElement(_ExceptionOption2.default, {
          className: "breakpoints-exceptions",
          label: L10N.getStr("pauseOnAnyXHR"),
          isChecked: shouldPauseOnAny,
          onChange: () => togglePauseOnAny()
        })
      );
    };

    this.renderMethodOption = method => {
      return _react2.default.createElement(
        "option",
        {
          key: method,
          value: method
          // e.stopPropagation() required here since otherwise Firefox triggers 2x
          // onMouseDown events on <select> upon clicking on an <option>
          , onMouseDown: e => e.stopPropagation()
        },
        method
      );
    };

    this.renderMethodSelectElement = () => {
      return _react2.default.createElement(
        "select",
        {
          value: this.state.inputMethod,
          className: "xhr-input-method",
          onChange: this.handleMethodChange,
          onMouseDown: this.onMouseDown,
          onKeyDown: this.handleTab
        },
        xhrMethods.map(this.renderMethodOption)
      );
    };

    this.state = {
      editing: false,
      inputValue: "",
      inputMethod: "ANY",
      focused: false,
      editIndex: -1,
      clickedOnFormElement: false
    };
  }

  componentDidMount() {
    const { showInput } = this.props;

    // Ensures that the input is focused when the "+"
    // is clicked while the panel is collapsed
    if (this._input && showInput) {
      this._input.focus();
    }
  }

  componentDidUpdate(prevProps, prevState) {
    const input = this._input;

    if (!input) {
      return;
    }

    if (!prevState.editing && this.state.editing) {
      input.setSelectionRange(0, input.value.length);
      input.focus();
    } else if (this.props.showInput && !this.state.focused) {
      input.focus();
    }
  }

  renderXHRInput(onSubmit) {
    const { focused, inputValue } = this.state;
    const placeholder = L10N.getStr("xhrBreakpoints.placeholder");

    return _react2.default.createElement(
      "li",
      {
        className: (0, _classnames2.default)("xhr-input-container", { focused }),
        key: "xhr-input-container"
      },
      _react2.default.createElement(
        "form",
        { className: "xhr-input-form", onSubmit: onSubmit },
        _react2.default.createElement("input", {
          className: "xhr-input-url",
          type: "text",
          placeholder: placeholder,
          onChange: this.handleChange,
          onBlur: this.hideInput,
          onFocus: this.onFocus,
          value: inputValue,
          onKeyDown: this.handleTab,
          ref: c => this._input = c
        }),
        this.renderMethodSelectElement(),
        _react2.default.createElement("input", { type: "submit", style: { display: "none" } })
      )
    );
  }

  render() {
    return _react2.default.createElement(
      "div",
      null,
      this.renderCheckbox(),
      this.renderBreakpoints()
    );
  }
}

const mapStateToProps = state => {
  return {
    xhrBreakpoints: (0, _selectors.getXHRBreakpoints)(state),
    shouldPauseOnAny: (0, _selectors.shouldPauseOnAnyXHR)(state)
  };
};

exports.default = (0, _connect.connect)(mapStateToProps, {
  setXHRBreakpoint: _actions2.default.setXHRBreakpoint,
  removeXHRBreakpoint: _actions2.default.removeXHRBreakpoint,
  enableXHRBreakpoint: _actions2.default.enableXHRBreakpoint,
  disableXHRBreakpoint: _actions2.default.disableXHRBreakpoint,
  updateXHRBreakpoint: _actions2.default.updateXHRBreakpoint,
  togglePauseOnAny: _actions2.default.togglePauseOnAny
})(XHRBreakpoints);

/***/ }),
/* 761 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 762 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(67);

var _classnames2 = _interopRequireDefault(_classnames);

var _connect = __webpack_require__(491);

var _actions = __webpack_require__(493);

var _actions2 = _interopRequireDefault(_actions);

var _selectors = __webpack_require__(490);

var _AccessibleImage = __webpack_require__(495);

var _AccessibleImage2 = _interopRequireDefault(_AccessibleImage);

__webpack_require__(763);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const CATEGORIES = {
  Mouse: ["click", "mouseover", "dblclick"],
  Keyboard: ["keyup", "keydown"]
}; /* This Source Code Form is subject to the terms of the Mozilla Public
    * License, v. 2.0. If a copy of the MPL was not distributed with this
    * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function getKey(category, eventType) {
  return `${category}:${eventType}`;
}

class EventListeners extends _react.Component {
  constructor(props) {
    super(props);

    this.state = {
      expandedCategories: []
    };
  }

  onCategoryToggle(category, event) {
    const { expandedCategories } = this.state;

    if (expandedCategories.includes(category)) {
      this.setState({
        expandedCategories: expandedCategories.filter(eventCategory => eventCategory !== category)
      });
    } else {
      this.setState({
        expandedCategories: [...expandedCategories, category]
      });
    }
  }

  onCategoryClick(category, isChecked) {
    const { addEventListeners, removeEventListeners } = this.props;
    const events = CATEGORIES[category].map(eventType => getKey(category, eventType));

    if (isChecked) {
      addEventListeners(events);
    } else {
      removeEventListeners(events);
    }
  }

  onEventTypeClick(eventType, isChecked) {
    const { addEventListeners, removeEventListeners } = this.props;
    if (isChecked) {
      addEventListeners([eventType]);
    } else {
      removeEventListeners([eventType]);
    }
  }

  renderCategoryHeading(category) {
    const { expandedCategories } = this.state;
    const { activeEventListeners } = this.props;

    const eventTypes = CATEGORIES[category];

    const expanded = expandedCategories.includes(category);
    const checked = eventTypes.every(eventType => activeEventListeners.includes(getKey(category, eventType)));
    const indeterminate = !checked && eventTypes.some(eventType => activeEventListeners.includes(getKey(category, eventType)));

    return _react2.default.createElement(
      "div",
      { className: "event-listener-header" },
      _react2.default.createElement(
        "button",
        {
          className: "event-listener-expand",
          onClick: e => this.onCategoryToggle(category, e)
        },
        _react2.default.createElement(_AccessibleImage2.default, { className: (0, _classnames2.default)("arrow", { expanded }) })
      ),
      _react2.default.createElement(
        "label",
        { className: "event-listener-label" },
        _react2.default.createElement("input", {
          type: "checkbox",
          value: category,
          onChange: e => this.onCategoryClick(category, e.target.checked),
          checked: checked,
          ref: el => el && (el.indeterminate = indeterminate)
        }),
        _react2.default.createElement(
          "span",
          { className: "event-listener-category" },
          category
        )
      )
    );
  }

  renderCategoryListing(category) {
    const { activeEventListeners } = this.props;
    const { expandedCategories } = this.state;

    const expanded = expandedCategories.includes(category);
    if (!expanded) {
      return null;
    }

    return _react2.default.createElement(
      "ul",
      null,
      CATEGORIES[category].map(eventType => {
        const key = getKey(category, eventType);
        return _react2.default.createElement(
          "li",
          { className: "event-listener-event", key: key },
          _react2.default.createElement(
            "label",
            { className: "event-listener-label" },
            _react2.default.createElement("input", {
              type: "checkbox",
              value: key,
              onChange: e => this.onEventTypeClick(key, e.target.checked),
              checked: activeEventListeners.includes(key)
            }),
            _react2.default.createElement(
              "span",
              { className: "event-listener-name" },
              eventType
            )
          )
        );
      })
    );
  }

  render() {
    return _react2.default.createElement(
      "div",
      { className: "event-listeners-content" },
      _react2.default.createElement(
        "ul",
        { className: "event-listeners-list" },
        Object.keys(CATEGORIES).map(category => {
          return _react2.default.createElement(
            "li",
            { className: "event-listener-group", key: category },
            this.renderCategoryHeading(category),
            this.renderCategoryListing(category)
          );
        })
      )
    );
  }
}

const mapStateToProps = state => ({
  activeEventListeners: (0, _selectors.getActiveEventListeners)(state)
});

exports.default = (0, _connect.connect)(mapStateToProps, {
  addEventListeners: _actions2.default.addEventListeners,
  removeEventListeners: _actions2.default.removeEventListeners
})(EventListeners);

/***/ }),
/* 763 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 764 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 765 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _connect = __webpack_require__(491);

var _actions = __webpack_require__(493);

var _actions2 = _interopRequireDefault(_actions);

var _firefox = __webpack_require__(508);

var _selectors = __webpack_require__(490);

var _scopes = __webpack_require__(766);

var _devtoolsReps = __webpack_require__(457);

__webpack_require__(770);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line import/named
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const { ObjectInspector } = _devtoolsReps.objectInspector;

class Scopes extends _react.PureComponent {
  constructor(props, ...args) {
    const {
      why,
      selectedFrame,
      originalFrameScopes,
      generatedFrameScopes
    } = props;

    super(props, ...args);

    this.onToggleMapScopes = () => {
      this.props.toggleMapScopes();
    };

    this.state = {
      originalScopes: (0, _scopes.getScopes)(why, selectedFrame, originalFrameScopes),
      generatedScopes: (0, _scopes.getScopes)(why, selectedFrame, generatedFrameScopes),
      showOriginal: true
    };
  }

  componentWillReceiveProps(nextProps) {
    const {
      isPaused,
      selectedFrame,
      originalFrameScopes,
      generatedFrameScopes
    } = this.props;
    const isPausedChanged = isPaused !== nextProps.isPaused;
    const selectedFrameChanged = selectedFrame !== nextProps.selectedFrame;
    const originalFrameScopesChanged = originalFrameScopes !== nextProps.originalFrameScopes;
    const generatedFrameScopesChanged = generatedFrameScopes !== nextProps.generatedFrameScopes;

    if (isPausedChanged || selectedFrameChanged || originalFrameScopesChanged || generatedFrameScopesChanged) {
      this.setState({
        originalScopes: (0, _scopes.getScopes)(nextProps.why, nextProps.selectedFrame, nextProps.originalFrameScopes),
        generatedScopes: (0, _scopes.getScopes)(nextProps.why, nextProps.selectedFrame, nextProps.generatedFrameScopes)
      });
    }
  }

  renderScopesList() {
    const {
      isPaused,
      isLoading,
      openLink,
      openElementInInspector,
      highlightDomElement,
      unHighlightDomElement,
      mapScopesEnabled
    } = this.props;
    const { originalScopes, generatedScopes, showOriginal } = this.state;

    const scopes = showOriginal && mapScopesEnabled && originalScopes || generatedScopes;

    if (scopes && scopes.length > 0 && !isLoading) {
      return _react2.default.createElement(
        "div",
        { className: "pane scopes-list" },
        _react2.default.createElement(ObjectInspector, {
          roots: scopes,
          autoExpandAll: false,
          autoExpandDepth: 1,
          disableWrap: true,
          dimTopLevelWindow: true,
          openLink: openLink,
          createObjectClient: grip => (0, _firefox.createObjectClient)(grip),
          onDOMNodeClick: grip => openElementInInspector(grip),
          onInspectIconClick: grip => openElementInInspector(grip),
          onDOMNodeMouseOver: grip => highlightDomElement(grip),
          onDOMNodeMouseOut: grip => unHighlightDomElement(grip)
        })
      );
    }

    let stateText = L10N.getStr("scopes.notPaused");
    if (isPaused) {
      if (isLoading) {
        stateText = L10N.getStr("loadingText");
      } else {
        stateText = L10N.getStr("scopes.notAvailable");
      }
    }

    return _react2.default.createElement(
      "div",
      { className: "pane scopes-list" },
      _react2.default.createElement(
        "div",
        { className: "pane-info" },
        stateText
      )
    );
  }

  render() {
    return _react2.default.createElement(
      "div",
      { className: "scopes-content" },
      this.renderScopesList()
    );
  }
}

const mapStateToProps = state => {
  const thread = (0, _selectors.getCurrentThread)(state);
  const selectedFrame = (0, _selectors.getSelectedFrame)(state, thread);
  const selectedSource = (0, _selectors.getSelectedSource)(state);

  const {
    scope: originalFrameScopes,
    pending: originalPending
  } = (0, _selectors.getOriginalFrameScope)(state, thread, selectedSource && selectedSource.id, selectedFrame && selectedFrame.id) || { scope: null, pending: false };

  const {
    scope: generatedFrameScopes,
    pending: generatedPending
  } = (0, _selectors.getGeneratedFrameScope)(state, thread, selectedFrame && selectedFrame.id) || {
    scope: null,
    pending: false
  };

  return {
    selectedFrame,
    mapScopesEnabled: (0, _selectors.isMapScopesEnabled)(state),
    isPaused: (0, _selectors.getIsPaused)(state, thread),
    isLoading: generatedPending || originalPending,
    why: (0, _selectors.getPauseReason)(state, thread),
    originalFrameScopes,
    generatedFrameScopes
  };
};

exports.default = (0, _connect.connect)(mapStateToProps, {
  openLink: _actions2.default.openLink,
  openElementInInspector: _actions2.default.openElementInInspectorCommand,
  highlightDomElement: _actions2.default.highlightDomElement,
  unHighlightDomElement: _actions2.default.unHighlightDomElement,
  toggleMapScopes: _actions2.default.toggleMapScopes
})(Scopes);

/***/ }),
/* 766 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getScopes = getScopes;

var _getScope = __webpack_require__(767);

function getScopes(why, selectedFrame, frameScopes) {
  if (!why || !selectedFrame) {
    return null;
  }

  if (!frameScopes) {
    return null;
  }

  const scopes = [];

  let scope = frameScopes;
  let scopeIndex = 1;

  while (scope) {
    const scopeItem = (0, _getScope.getScope)(scope, selectedFrame, frameScopes, why, scopeIndex);

    if (scopeItem) {
      scopes.push(scopeItem);
    }
    scopeIndex++;
    scope = scope.parent;
  }

  return scopes;
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/***/ }),
/* 767 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getScope = getScope;

var _devtoolsReps = __webpack_require__(457);

var _getVariables = __webpack_require__(768);

var _utils = __webpack_require__(769);

var _frames = __webpack_require__(510);

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

// eslint-disable-next-line import/named
const {
  utils: {
    node: { NODE_TYPES }
  }
} = _devtoolsReps.objectInspector;

function getScopeTitle(type, scope) {
  if (type === "block" && scope.block && scope.block.displayName) {
    return scope.block.displayName;
  }

  if (type === "function" && scope.function) {
    return scope.function.displayName ? (0, _frames.simplifyDisplayName)(scope.function.displayName) : L10N.getStr("anonymousFunction");
  }
  return L10N.getStr("scopes.block");
}

function getScope(scope, selectedFrame, frameScopes, why, scopeIndex) {
  const { type, actor } = scope;

  const isLocalScope = scope.actor === frameScopes.actor;

  const key = `${actor}-${scopeIndex}`;
  if (type === "function" || type === "block") {
    const bindings = scope.bindings;

    let vars = (0, _getVariables.getBindingVariables)(bindings, key);

    // show exception, return, and this variables in innermost scope
    if (isLocalScope) {
      vars = vars.concat((0, _utils.getFramePopVariables)(why, key));

      let thisDesc_ = selectedFrame.this;

      if (bindings && "this" in bindings) {
        // The presence of "this" means we're rendering a "this" binding
        // generated from mapScopes and this can override the binding
        // provided by the current frame.
        thisDesc_ = bindings.this ? bindings.this.value : null;
      }

      const this_ = (0, _utils.getThisVariable)(thisDesc_, key);

      if (this_) {
        vars.push(this_);
      }
    }

    if (vars && vars.length) {
      const title = getScopeTitle(type, scope) || "";
      vars.sort((a, b) => a.name.localeCompare(b.name));
      return {
        name: title,
        path: key,
        contents: vars,
        type: NODE_TYPES.BLOCK
      };
    }
  } else if (type === "object" && scope.object) {
    let value = scope.object;
    // If this is the global window scope, mark it as such so that it will
    // preview Window: Global instead of Window: Window
    if (value.class === "Window") {
      value = { ...scope.object, displayClass: "Global" };
    }
    return {
      name: scope.object.class,
      path: key,
      contents: { value }
    };
  }

  return null;
}

/***/ }),
/* 768 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getBindingVariables = getBindingVariables;

var _lodash = __webpack_require__(417);

// Create the tree nodes representing all the variables and arguments
// for the bindings from a scope.


// VarAndBindingsPair actually is [name: string, contents: BindingContents]


// Scope's bindings field which holds variables and arguments
function getBindingVariables(bindings, parentName) {
  if (!bindings) {
    return [];
  }

  const args = bindings.arguments.map(arg => (0, _lodash.toPairs)(arg)[0]);

  const variables = (0, _lodash.toPairs)(bindings.variables);

  return args.concat(variables).map(binding => {
    const name = binding[0];
    const contents = binding[1];
    return {
      name,
      path: `${parentName}/${name}`,
      contents
    };
  });
} /* eslint max-nested-callbacks: ["error", 4] */

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

/***/ }),
/* 769 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFramePopVariables = getFramePopVariables;
exports.getThisVariable = getThisVariable;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

function getFramePopVariables(why, path) {
  const vars = [];

  if (why && why.frameFinished) {
    const frameFinished = why.frameFinished;

    // Always display a `throw` property if present, even if it is falsy.
    if (Object.prototype.hasOwnProperty.call(frameFinished, "throw")) {
      vars.push({
        name: "<exception>",
        path: `${path}/<exception>`,
        contents: { value: frameFinished.throw }
      });
    }

    if (Object.prototype.hasOwnProperty.call(frameFinished, "return")) {
      const returned = frameFinished.return;

      // Do not display undefined. Do display falsy values like 0 and false. The
      // protocol grip for undefined is a JSON object: { type: "undefined" }.
      if (typeof returned !== "object" || returned.type !== "undefined") {
        vars.push({
          name: "<return>",
          path: `${path}/<return>`,
          contents: { value: returned }
        });
      }
    }
  }

  return vars;
}

function getThisVariable(this_, path) {
  if (!this_) {
    return null;
  }

  return {
    name: "<this>",
    path: `${path}/<this>`,
    contents: { value: this_ }
  };
}

/***/ }),
/* 770 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 771 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 772 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WelcomeBox = undefined;

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _connect = __webpack_require__(491);

var _actions = __webpack_require__(493);

var _actions2 = _interopRequireDefault(_actions);

var _selectors = __webpack_require__(490);

var _text = __webpack_require__(514);

__webpack_require__(773);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

class WelcomeBox extends _react.Component {
  render() {
    const searchSourcesShortcut = (0, _text.formatKeyShortcut)(L10N.getStr("sources.search.key2"));

    const searchProjectShortcut = (0, _text.formatKeyShortcut)(L10N.getStr("projectTextSearch.key"));

    const allShortcutsShortcut = (0, _text.formatKeyShortcut)(L10N.getStr("allShortcut.key"));

    const allShortcutsLabel = L10N.getStr("welcome.allShortcuts");
    const searchSourcesLabel = L10N.getStr("welcome.search2").substring(2);
    const searchProjectLabel = L10N.getStr("welcome.findInFiles2").substring(2);
    const { setActiveSearch, openQuickOpen, toggleShortcutsModal } = this.props;

    return _react2.default.createElement(
      "div",
      { className: "welcomebox" },
      _react2.default.createElement(
        "div",
        { className: "alignlabel" },
        _react2.default.createElement(
          "div",
          { className: "shortcutFunction" },
          _react2.default.createElement(
            "p",
            {
              className: "welcomebox__searchSources",
              role: "button",
              tabIndex: "0",
              onClick: () => openQuickOpen()
            },
            _react2.default.createElement(
              "span",
              { className: "shortcutKey" },
              searchSourcesShortcut
            ),
            _react2.default.createElement(
              "span",
              { className: "shortcutLabel" },
              searchSourcesLabel
            )
          ),
          _react2.default.createElement(
            "p",
            {
              className: "welcomebox__searchProject",
              role: "button",
              tabIndex: "0",
              onClick: setActiveSearch.bind(null, "project")
            },
            _react2.default.createElement(
              "span",
              { className: "shortcutKey" },
              searchProjectShortcut
            ),
            _react2.default.createElement(
              "span",
              { className: "shortcutLabel" },
              searchProjectLabel
            )
          ),
          _react2.default.createElement(
            "p",
            {
              className: "welcomebox__allShortcuts",
              role: "button",
              tabIndex: "0",
              onClick: () => toggleShortcutsModal()
            },
            _react2.default.createElement(
              "span",
              { className: "shortcutKey" },
              allShortcutsShortcut
            ),
            _react2.default.createElement(
              "span",
              { className: "shortcutLabel" },
              allShortcutsLabel
            )
          )
        )
      )
    );
  }
}

exports.WelcomeBox = WelcomeBox;
const mapStateToProps = state => ({
  endPanelCollapsed: (0, _selectors.getPaneCollapse)(state, "end")
});

exports.default = (0, _connect.connect)(mapStateToProps, {
  togglePaneCollapse: _actions2.default.togglePaneCollapse,
  setActiveSearch: _actions2.default.setActiveSearch,
  openQuickOpen: _actions2.default.openQuickOpen
})(WelcomeBox);

/***/ }),
/* 773 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 774 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _connect = __webpack_require__(491);

var _selectors = __webpack_require__(490);

var _ui = __webpack_require__(525);

var _tabs = __webpack_require__(556);

var _source = __webpack_require__(494);

var _actions = __webpack_require__(493);

var _actions2 = _interopRequireDefault(_actions);

var _lodash = __webpack_require__(417);

__webpack_require__(775);

var _Tab = __webpack_require__(776);

var _Tab2 = _interopRequireDefault(_Tab);

var _Button = __webpack_require__(502);

var _Dropdown = __webpack_require__(777);

var _Dropdown2 = _interopRequireDefault(_Dropdown);

var _AccessibleImage = __webpack_require__(495);

var _AccessibleImage2 = _interopRequireDefault(_AccessibleImage);

var _CommandBar = __webpack_require__(608);

var _CommandBar2 = _interopRequireDefault(_CommandBar);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

class Tabs extends _react.PureComponent {

  constructor(props) {
    super(props);

    this.updateHiddenTabs = () => {
      if (!this.refs.sourceTabs) {
        return;
      }
      const { selectedSource, tabSources, moveTab } = this.props;
      const sourceTabEls = this.refs.sourceTabs.children;
      const hiddenTabs = (0, _tabs.getHiddenTabs)(tabSources, sourceTabEls);

      if (selectedSource && (0, _ui.isVisible)() && hiddenTabs.find(tab => tab.id == selectedSource.id)) {
        return moveTab(selectedSource.url, 0);
      }

      this.setState({ hiddenTabs });
    };

    this.renderDropdownSource = source => {
      const { cx, selectSource } = this.props;
      const filename = (0, _source.getFilename)(source);

      const onClick = () => selectSource(cx, source.id);
      return _react2.default.createElement(
        "li",
        { key: source.id, onClick: onClick },
        _react2.default.createElement(_AccessibleImage2.default, {
          className: `dropdown-icon ${this.getIconClass(source)}`
        }),
        _react2.default.createElement(
          "span",
          { className: "dropdown-label" },
          filename
        )
      );
    };

    this.state = {
      dropdownShown: false,
      hiddenTabs: []
    };

    this.onResize = (0, _lodash.debounce)(() => {
      this.updateHiddenTabs();
    });
  }

  componentDidUpdate(prevProps) {
    if (!(prevProps === this.props)) {
      this.updateHiddenTabs();
    }
  }

  componentDidMount() {
    window.requestIdleCallback(this.updateHiddenTabs);
    window.addEventListener("resize", this.onResize);
    window.document.querySelector(".editor-pane").addEventListener("resizeend", this.onResize);
  }

  componentWillUnmount() {
    window.removeEventListener("resize", this.onResize);
    window.document.querySelector(".editor-pane").removeEventListener("resizeend", this.onResize);
  }

  /*
   * Updates the hiddenSourceTabs state, by
   * finding the source tabs which are wrapped and are not on the top row.
   */


  toggleSourcesDropdown(e) {
    this.setState(prevState => ({
      dropdownShown: !prevState.dropdownShown
    }));
  }

  getIconClass(source) {
    if ((0, _source.isPretty)(source)) {
      return "prettyPrint";
    }
    if (source.isBlackBoxed) {
      return "blackBox";
    }
    return "file";
  }

  renderTabs() {
    const { tabSources } = this.props;
    if (!tabSources) {
      return;
    }

    return _react2.default.createElement(
      "div",
      { className: "source-tabs", ref: "sourceTabs" },
      tabSources.map((source, index) => _react2.default.createElement(_Tab2.default, { key: index, source: source }))
    );
  }

  renderDropdown() {
    const hiddenTabs = this.state.hiddenTabs;
    if (!hiddenTabs || hiddenTabs.length == 0) {
      return null;
    }

    const Panel = _react2.default.createElement(
      "ul",
      null,
      hiddenTabs.map(this.renderDropdownSource)
    );
    const icon = _react2.default.createElement(_AccessibleImage2.default, { className: "more-tabs" });

    return _react2.default.createElement(_Dropdown2.default, { panel: Panel, icon: icon });
  }

  renderCommandBar() {
    const { horizontal, endPanelCollapsed, isPaused } = this.props;
    if (!endPanelCollapsed || !isPaused) {
      return;
    }

    return _react2.default.createElement(_CommandBar2.default, { horizontal: horizontal });
  }

  renderStartPanelToggleButton() {
    return _react2.default.createElement(_Button.PaneToggleButton, {
      position: "start",
      collapsed: this.props.startPanelCollapsed,
      handleClick: this.props.togglePaneCollapse
    });
  }

  renderEndPanelToggleButton() {
    const { horizontal, endPanelCollapsed, togglePaneCollapse } = this.props;
    if (!horizontal) {
      return;
    }

    return _react2.default.createElement(_Button.PaneToggleButton, {
      position: "end",
      collapsed: endPanelCollapsed,
      handleClick: togglePaneCollapse,
      horizontal: horizontal
    });
  }

  render() {
    return _react2.default.createElement(
      "div",
      { className: "source-header" },
      this.renderStartPanelToggleButton(),
      this.renderTabs(),
      this.renderDropdown(),
      this.renderEndPanelToggleButton(),
      this.renderCommandBar()
    );
  }
}

const mapStateToProps = state => ({
  cx: (0, _selectors.getContext)(state),
  selectedSource: (0, _selectors.getSelectedSource)(state),
  tabSources: (0, _selectors.getSourcesForTabs)(state),
  isPaused: (0, _selectors.getIsPaused)(state, (0, _selectors.getCurrentThread)(state))
});

exports.default = (0, _connect.connect)(mapStateToProps, {
  selectSource: _actions2.default.selectSource,
  moveTab: _actions2.default.moveTab,
  closeTab: _actions2.default.closeTab,
  togglePaneCollapse: _actions2.default.togglePaneCollapse,
  showSource: _actions2.default.showSource
})(Tabs);

/***/ }),
/* 775 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 776 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _connect = __webpack_require__(491);

var _devtoolsContextmenu = __webpack_require__(420);

var _SourceIcon = __webpack_require__(555);

var _SourceIcon2 = _interopRequireDefault(_SourceIcon);

var _Button = __webpack_require__(502);

var _actions = __webpack_require__(493);

var _actions2 = _interopRequireDefault(_actions);

var _source = __webpack_require__(494);

var _clipboard = __webpack_require__(512);

var _tabs = __webpack_require__(556);

var _selectors = __webpack_require__(490);

var _classnames = __webpack_require__(67);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Tab extends _react.PureComponent {
  constructor(...args) {
    var _temp;

    return _temp = super(...args), this.onTabContextMenu = (event, tab) => {
      event.preventDefault();
      this.showContextMenu(event, tab);
    }, _temp;
  }

  showContextMenu(e, tab) {
    const {
      cx,
      closeTab,
      closeTabs,
      tabSources,
      showSource,
      toggleBlackBox,
      togglePrettyPrint,
      selectedSource,
      source
    } = this.props;

    const tabCount = tabSources.length;
    const otherTabs = tabSources.filter(t => t.id !== tab);
    const sourceTab = tabSources.find(t => t.id == tab);
    const tabURLs = tabSources.map(t => t.url);
    const otherTabURLs = otherTabs.map(t => t.url);

    if (!sourceTab) {
      return;
    }

    const tabMenuItems = (0, _tabs.getTabMenuItems)();
    const items = [{
      item: {
        ...tabMenuItems.closeTab,
        click: () => closeTab(cx, sourceTab)
      }
    }, {
      item: {
        ...tabMenuItems.closeOtherTabs,
        click: () => closeTabs(cx, otherTabURLs),
        disabled: otherTabURLs.length === 0
      }
    }, {
      item: {
        ...tabMenuItems.closeTabsToEnd,
        click: () => {
          const tabIndex = tabSources.findIndex(t => t.id == tab);
          closeTabs(cx, tabURLs.filter((t, i) => i > tabIndex));
        },
        disabled: tabCount === 1 || tabSources.some((t, i) => t === tab && tabCount - 1 === i)
      }
    }, {
      item: {
        ...tabMenuItems.closeAllTabs,
        click: () => closeTabs(cx, tabURLs)
      }
    }, { item: { type: "separator" } }, {
      item: {
        ...tabMenuItems.copyToClipboard,
        disabled: selectedSource.id !== tab,
        click: () => (0, _clipboard.copyToTheClipboard)(sourceTab.text)
      }
    }, {
      item: {
        ...tabMenuItems.copySourceUri2,
        disabled: !selectedSource.url,
        click: () => (0, _clipboard.copyToTheClipboard)((0, _source.getRawSourceURL)(sourceTab.url))
      }
    }, {
      item: {
        ...tabMenuItems.showSource,
        disabled: !selectedSource.url,
        click: () => showSource(cx, tab)
      }
    }, {
      item: {
        ...tabMenuItems.toggleBlackBox,
        label: source.isBlackBoxed ? L10N.getStr("sourceFooter.unblackbox") : L10N.getStr("sourceFooter.blackbox"),
        disabled: !(0, _source.shouldBlackbox)(source),
        click: () => toggleBlackBox(cx, source)
      }
    }, {
      item: {
        ...tabMenuItems.prettyPrint,
        click: () => togglePrettyPrint(cx, tab),
        disabled: (0, _source.isPretty)(sourceTab)
      }
    }];

    (0, _devtoolsContextmenu.showMenu)(e, (0, _devtoolsContextmenu.buildMenu)(items));
  }

  isProjectSearchEnabled() {
    return this.props.activeSearch === "project";
  }

  isSourceSearchEnabled() {
    return this.props.activeSearch === "source";
  }

  render() {
    const {
      cx,
      selectedSource,
      selectSource,
      closeTab,
      source,
      tabSources,
      hasSiblingOfSameName
    } = this.props;
    const sourceId = source.id;
    const active = selectedSource && sourceId == selectedSource.id && !this.isProjectSearchEnabled() && !this.isSourceSearchEnabled();
    const isPrettyCode = (0, _source.isPretty)(source);

    function onClickClose(e) {
      e.stopPropagation();
      closeTab(cx, source);
    }

    function handleTabClick(e) {
      e.preventDefault();
      e.stopPropagation();
      return selectSource(cx, sourceId);
    }

    const className = (0, _classnames2.default)("source-tab", {
      active,
      pretty: isPrettyCode
    });

    const path = (0, _source.getDisplayPath)(source, tabSources);
    const query = hasSiblingOfSameName ? (0, _source.getSourceQueryString)(source) : "";

    return _react2.default.createElement(
      "div",
      {
        className: className,
        key: sourceId,
        onClick: handleTabClick
        // Accommodate middle click to close tab
        , onMouseUp: e => e.button === 1 && closeTab(cx, source),
        onContextMenu: e => this.onTabContextMenu(e, sourceId),
        title: (0, _source.getFileURL)(source, false)
      },
      _react2.default.createElement(_SourceIcon2.default, {
        source: source,
        shouldHide: icon => ["file", "javascript"].includes(icon)
      }),
      _react2.default.createElement(
        "div",
        { className: "filename" },
        (0, _source.getTruncatedFileName)(source, query),
        path && _react2.default.createElement(
          "span",
          null,
          `../${path}/..`
        )
      ),
      _react2.default.createElement(_Button.CloseButton, {
        handleClick: onClickClose,
        tooltip: L10N.getStr("sourceTabs.closeTabButtonTooltip")
      })
    );
  }
} /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

const mapStateToProps = (state, { source }) => {
  const selectedSource = (0, _selectors.getSelectedSource)(state);

  return {
    cx: (0, _selectors.getContext)(state),
    tabSources: (0, _selectors.getSourcesForTabs)(state),
    selectedSource: selectedSource,
    activeSearch: (0, _selectors.getActiveSearch)(state),
    hasSiblingOfSameName: (0, _selectors.getHasSiblingOfSameName)(state, source)
  };
};

exports.default = (0, _connect.connect)(mapStateToProps, {
  selectSource: _actions2.default.selectSource,
  closeTab: _actions2.default.closeTab,
  closeTabs: _actions2.default.closeTabs,
  togglePrettyPrint: _actions2.default.togglePrettyPrint,
  showSource: _actions2.default.showSource,
  toggleBlackBox: _actions2.default.toggleBlackBox
})(Tab);

/***/ }),
/* 777 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Dropdown = undefined;

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

__webpack_require__(778);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

class Dropdown extends _react.Component {
  constructor(props) {
    super(props);

    this.toggleDropdown = e => {
      this.setState(prevState => ({
        dropdownShown: !prevState.dropdownShown
      }));
    };

    this.state = {
      dropdownShown: false
    };
  }

  renderPanel() {
    return _react2.default.createElement(
      "div",
      {
        className: "dropdown",
        onClick: this.toggleDropdown,
        style: { display: this.state.dropdownShown ? "block" : "none" }
      },
      this.props.panel
    );
  }

  renderButton() {
    return (
      // eslint-disable-next-line prettier/prettier
      _react2.default.createElement(
        "button",
        { className: "dropdown-button", onClick: this.toggleDropdown },
        this.props.icon
      )
    );
  }

  renderMask() {
    return _react2.default.createElement("div", {
      className: "dropdown-mask",
      onClick: this.toggleDropdown,
      style: { display: this.state.dropdownShown ? "block" : "none" }
    });
  }

  render() {
    return _react2.default.createElement(
      "div",
      { className: "dropdown-block" },
      this.renderPanel(),
      this.renderButton(),
      this.renderMask()
    );
  }
}

exports.Dropdown = Dropdown;
exports.default = Dropdown;

/***/ }),
/* 778 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 779 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _connect = __webpack_require__(491);

var _classnames = __webpack_require__(67);

var _classnames2 = _interopRequireDefault(_classnames);

var _actions = __webpack_require__(493);

var _actions2 = _interopRequireDefault(_actions);

var _selectors = __webpack_require__(490);

var _asyncValue = __webpack_require__(497);

var _source = __webpack_require__(494);

var _sources = __webpack_require__(498);

var _editor = __webpack_require__(496);

var _Button = __webpack_require__(502);

var _AccessibleImage = __webpack_require__(495);

var _AccessibleImage2 = _interopRequireDefault(_AccessibleImage);

__webpack_require__(780);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

class SourceFooter extends _react.PureComponent {
  constructor() {
    super();

    this.onCursorChange = event => {
      const { line, ch } = event.doc.getCursor();
      this.setState({ cursorPosition: { line, column: ch } });
    };

    this.state = { cursorPosition: { line: 0, column: 0 } };
  }

  componentDidUpdate() {
    const eventDoc = document.querySelector(".editor-mount .CodeMirror");
    // querySelector can return null
    if (eventDoc) {
      this.toggleCodeMirror(eventDoc, true);
    }
  }

  componentWillUnmount() {
    const eventDoc = document.querySelector(".editor-mount .CodeMirror");

    if (eventDoc) {
      this.toggleCodeMirror(eventDoc, false);
    }
  }

  toggleCodeMirror(eventDoc, toggle) {
    if (toggle === true) {
      eventDoc.CodeMirror.on("cursorActivity", this.onCursorChange);
    } else {
      eventDoc.CodeMirror.off("cursorActivity", this.onCursorChange);
    }
  }

  prettyPrintButton() {
    const { cx, selectedSourceWithContent, togglePrettyPrint } = this.props;

    if (!selectedSourceWithContent) {
      return;
    }

    if (!selectedSourceWithContent.content && selectedSourceWithContent.source.isPrettyPrinted) {
      return _react2.default.createElement(
        "div",
        { className: "loader", key: "pretty-loader" },
        _react2.default.createElement(_AccessibleImage2.default, { className: "loader" })
      );
    }

    const sourceContent = selectedSourceWithContent.content && (0, _asyncValue.isFulfilled)(selectedSourceWithContent.content) ? selectedSourceWithContent.content.value : null;
    if (!(0, _editor.shouldShowPrettyPrint)(selectedSourceWithContent.source, sourceContent || { type: "text", value: "", contentType: undefined })) {
      return;
    }

    const tooltip = L10N.getStr("sourceTabs.prettyPrint");
    const sourceLoaded = !!selectedSourceWithContent.content;

    const type = "prettyPrint";
    return _react2.default.createElement(
      "button",
      {
        onClick: () => togglePrettyPrint(cx, selectedSourceWithContent.source.id),
        className: (0, _classnames2.default)("action", type, {
          active: sourceLoaded,
          pretty: (0, _source.isPretty)(selectedSourceWithContent.source)
        }),
        key: type,
        title: tooltip,
        "aria-label": tooltip
      },
      _react2.default.createElement(_AccessibleImage2.default, { className: type })
    );
  }

  blackBoxButton() {
    const { cx, selectedSourceWithContent, toggleBlackBox } = this.props;
    const sourceLoaded = selectedSourceWithContent && selectedSourceWithContent.content;

    if (!selectedSourceWithContent) {
      return;
    }

    if (!(0, _source.shouldBlackbox)(selectedSourceWithContent.source)) {
      return;
    }

    const blackboxed = selectedSourceWithContent.source.isBlackBoxed;

    const tooltip = blackboxed ? L10N.getStr("sourceFooter.unblackbox") : L10N.getStr("sourceFooter.blackbox");

    const type = "black-box";

    return _react2.default.createElement(
      "button",
      {
        onClick: () => toggleBlackBox(cx, selectedSourceWithContent.source),
        className: (0, _classnames2.default)("action", type, {
          active: sourceLoaded,
          blackboxed: blackboxed
        }),
        key: type,
        title: tooltip,
        "aria-label": tooltip
      },
      _react2.default.createElement(_AccessibleImage2.default, { className: "blackBox" })
    );
  }

  renderToggleButton() {
    if (this.props.horizontal) {
      return;
    }

    return _react2.default.createElement(_Button.PaneToggleButton, {
      key: "toggle",
      collapsed: this.props.endPanelCollapsed,
      horizontal: this.props.horizontal,
      handleClick: this.props.togglePaneCollapse,
      position: "end"
    });
  }

  renderCommands() {
    const commands = [this.blackBoxButton(), this.prettyPrintButton()].filter(Boolean);

    return commands.length ? _react2.default.createElement(
      "div",
      { className: "commands" },
      commands
    ) : null;
  }

  renderSourceSummary() {
    const {
      cx,
      mappedSource,
      jumpToMappedLocation,
      selectedSourceWithContent
    } = this.props;

    if (!mappedSource || !selectedSourceWithContent || !(0, _source.isOriginal)(selectedSourceWithContent.source)) {
      return null;
    }

    const filename = (0, _source.getFilename)(mappedSource);
    const tooltip = L10N.getFormatStr("sourceFooter.mappedSourceTooltip", filename);
    const title = L10N.getFormatStr("sourceFooter.mappedSource", filename);
    const mappedSourceLocation = {
      sourceId: selectedSourceWithContent.source.id,
      line: 1,
      column: 1
    };
    return _react2.default.createElement(
      "button",
      {
        className: "mapped-source",
        onClick: () => jumpToMappedLocation(cx, mappedSourceLocation),
        title: tooltip
      },
      _react2.default.createElement(
        "span",
        null,
        title
      )
    );
  }

  renderCursorPosition() {
    if (!this.props.selectedSourceWithContent) {
      return null;
    }

    const { line, column } = this.state.cursorPosition;

    const text = L10N.getFormatStr("sourceFooter.currentCursorPosition", line + 1, column + 1);
    const title = L10N.getFormatStr("sourceFooter.currentCursorPosition.tooltip", line + 1, column + 1);
    return _react2.default.createElement(
      "div",
      { className: "cursor-position", title: title },
      text
    );
  }

  render() {
    return _react2.default.createElement(
      "div",
      { className: "source-footer" },
      _react2.default.createElement(
        "div",
        { className: "source-footer-start" },
        this.renderCommands()
      ),
      _react2.default.createElement(
        "div",
        { className: "source-footer-end" },
        this.renderSourceSummary(),
        this.renderCursorPosition(),
        this.renderToggleButton()
      )
    );
  }
}

const mapStateToProps = state => {
  const selectedSourceWithContent = (0, _selectors.getSelectedSourceWithContent)(state);

  return {
    cx: (0, _selectors.getContext)(state),
    selectedSourceWithContent,
    mappedSource: (0, _sources.getGeneratedSource)(state, selectedSourceWithContent && selectedSourceWithContent.source),
    prettySource: (0, _selectors.getPrettySource)(state, selectedSourceWithContent ? selectedSourceWithContent.source.id : null),
    endPanelCollapsed: (0, _selectors.getPaneCollapse)(state, "end")
  };
};

exports.default = (0, _connect.connect)(mapStateToProps, {
  togglePrettyPrint: _actions2.default.togglePrettyPrint,
  toggleBlackBox: _actions2.default.toggleBlackBox,
  jumpToMappedLocation: _actions2.default.jumpToMappedLocation,
  togglePaneCollapse: _actions2.default.togglePaneCollapse
})(SourceFooter);

/***/ }),
/* 780 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 781 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QuickOpenModal = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /* This Source Code Form is subject to the terms of the Mozilla Public
                                                                                                                                                                                                                                                                   * License, v. 2.0. If a copy of the MPL was not distributed with this
                                                                                                                                                                                                                                                                   * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _connect = __webpack_require__(491);

var _fuzzaldrinPlus = __webpack_require__(432);

var _fuzzaldrinPlus2 = _interopRequireDefault(_fuzzaldrinPlus);

var _path = __webpack_require__(578);

var _lodash = __webpack_require__(417);

var _actions = __webpack_require__(493);

var _actions2 = _interopRequireDefault(_actions);

var _selectors = __webpack_require__(490);

var _resultList = __webpack_require__(603);

var _quickOpen = __webpack_require__(586);

var _Modal = __webpack_require__(600);

var _Modal2 = _interopRequireDefault(_Modal);

var _SearchInput = __webpack_require__(553);

var _SearchInput2 = _interopRequireDefault(_SearchInput);

var _ResultList = __webpack_require__(782);

var _ResultList2 = _interopRequireDefault(_ResultList);

__webpack_require__(784);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const updateResultsThrottle = 100;
const maxResults = 100;

function filter(values, query) {
  const preparedQuery = _fuzzaldrinPlus2.default.prepareQuery(query);

  return _fuzzaldrinPlus2.default.filter(values, query, {
    key: "value",
    maxResults: maxResults,
    preparedQuery
  });
}

class QuickOpenModal extends _react.Component {
  constructor(props) {
    super(props);

    this.closeModal = () => {
      this.props.closeQuickOpen();
    };

    this.dropGoto = query => {
      return query.split(":")[0];
    };

    this.searchSources = query => {
      const { displayedSources, tabs } = this.props;
      const tabUrls = new Set(tabs.map(tab => tab.url));
      const sources = (0, _quickOpen.formatSources)(displayedSources, tabUrls);

      const results = query == "" ? sources : filter(sources, this.dropGoto(query));
      return this.setResults(results);
    };

    this.searchSymbols = query => {
      const {
        symbols: { functions }
      } = this.props;

      let results = functions;
      results = results.filter(result => result.title !== "anonymous");

      if (query === "@" || query === "#") {
        return this.setResults(results);
      }
      results = filter(results, query.slice(1));
      return this.setResults(results);
    };

    this.searchShortcuts = query => {
      const results = (0, _quickOpen.formatShortcutResults)();
      if (query == "?") {
        this.setResults(results);
      } else {
        this.setResults(filter(results, query.slice(1)));
      }
    };

    this.showTopSources = () => {
      const { displayedSources, tabs } = this.props;
      const tabUrls = new Set(tabs.map(tab => tab.url));

      if (tabs.length > 0) {
        this.setResults((0, _quickOpen.formatSources)(displayedSources.filter(source => !!source.url && tabUrls.has(source.url)), tabUrls));
      } else {
        this.setResults((0, _quickOpen.formatSources)(displayedSources, tabUrls));
      }
    };

    this.updateResults = (0, _lodash.throttle)(query => {
      if (this.isGotoQuery()) {
        return;
      }

      if (query == "" && !this.isShortcutQuery()) {
        return this.showTopSources();
      }

      if (this.isSymbolSearch()) {
        return this.searchSymbols(query);
      }

      if (this.isShortcutQuery()) {
        return this.searchShortcuts(query);
      }

      return this.searchSources(query);
    }, updateResultsThrottle);

    this.setModifier = item => {
      if (["@", "#", ":"].includes(item.id)) {
        this.props.setQuickOpenQuery(item.id);
      }
    };

    this.selectResultItem = (e, item) => {
      if (item == null) {
        return;
      }

      if (this.isShortcutQuery()) {
        return this.setModifier(item);
      }

      if (this.isGotoSourceQuery()) {
        const location = (0, _quickOpen.parseLineColumn)(this.props.query);
        return this.gotoLocation({ ...location, sourceId: item.id });
      }

      if (this.isSymbolSearch()) {
        return this.gotoLocation({
          line: item.location && item.location.start ? item.location.start.line : 0
        });
      }

      this.gotoLocation({ sourceId: item.id, line: 0 });
    };

    this.onSelectResultItem = item => {
      const { selectedSource, highlightLineRange } = this.props;
      if (!this.isSymbolSearch() || selectedSource == null) {
        return;
      }

      if (this.isFunctionQuery()) {
        return highlightLineRange({
          ...(item.location != null ? { start: item.location.start.line, end: item.location.end.line } : {}),
          sourceId: selectedSource.id
        });
      }
    };

    this.traverseResults = e => {
      const direction = e.key === "ArrowUp" ? -1 : 1;
      const { selectedIndex, results } = this.state;
      const resultCount = this.getResultCount();
      const index = selectedIndex + direction;
      const nextIndex = (index + resultCount) % resultCount || 0;

      this.setState({ selectedIndex: nextIndex });

      if (results != null) {
        this.onSelectResultItem(results[nextIndex]);
      }
    };

    this.gotoLocation = location => {
      const { cx, selectSpecificLocation, selectedSource } = this.props;
      const selectedSourceId = selectedSource ? selectedSource.id : "";
      if (location != null) {
        const sourceId = location.sourceId ? location.sourceId : selectedSourceId;
        selectSpecificLocation(cx, {
          sourceId,
          line: location.line,
          column: location.column
        });
        this.closeModal();
      }
    };

    this.onChange = e => {
      const {
        selectedSource,
        selectedContentLoaded,
        setQuickOpenQuery
      } = this.props;
      setQuickOpenQuery(e.target.value);
      const noSource = !selectedSource || !selectedContentLoaded;
      if (this.isSymbolSearch() && noSource || this.isGotoQuery()) {
        return;
      }

      this.updateResults(e.target.value);
    };

    this.onKeyDown = e => {
      const { enabled, query } = this.props;
      const { results, selectedIndex } = this.state;

      if (!this.isGotoQuery() && (!enabled || !results)) {
        return;
      }

      if (e.key === "Enter") {
        if (this.isGotoQuery()) {
          const location = (0, _quickOpen.parseLineColumn)(query);
          return this.gotoLocation(location);
        }

        if (results) {
          return this.selectResultItem(e, results[selectedIndex]);
        }
      }

      if (e.key === "Tab") {
        return this.closeModal();
      }

      if (["ArrowUp", "ArrowDown"].includes(e.key)) {
        e.preventDefault();
        return this.traverseResults(e);
      }
    };

    this.getResultCount = () => {
      const results = this.state.results;
      return results && results.length ? results.length : 0;
    };

    this.isFunctionQuery = () => this.props.searchType === "functions";

    this.isSymbolSearch = () => this.isFunctionQuery();

    this.isGotoQuery = () => this.props.searchType === "goto";

    this.isGotoSourceQuery = () => this.props.searchType === "gotoSource";

    this.isShortcutQuery = () => this.props.searchType === "shortcuts";

    this.isSourcesQuery = () => this.props.searchType === "sources";

    this.isSourceSearch = () => this.isSourcesQuery() || this.isGotoSourceQuery();

    this.highlightMatching = (query, results) => {
      let newQuery = query;
      if (newQuery === "") {
        return results;
      }
      newQuery = query.replace(/[@:#?]/gi, " ");

      return results.map(result => {
        if (typeof result.title == "string") {
          return {
            ...result,
            title: this.renderHighlight(result.title, (0, _path.basename)(newQuery), "title")
          };
        }
        return result;
      });
    };

    this.state = { results: null, selectedIndex: 0 };
  }

  setResults(results) {
    if (results) {
      results = results.slice(0, maxResults);
    }
    this.setState({ results });
  }

  componentDidMount() {
    const { query, shortcutsModalEnabled, toggleShortcutsModal } = this.props;

    this.updateResults(query);

    if (shortcutsModalEnabled) {
      toggleShortcutsModal();
    }
  }

  componentDidUpdate(prevProps) {
    const nowEnabled = !prevProps.enabled && this.props.enabled;
    const queryChanged = prevProps.query !== this.props.query;

    if (this.refs.resultList && this.refs.resultList.refs) {
      (0, _resultList.scrollList)(this.refs.resultList.refs, this.state.selectedIndex);
    }

    if (nowEnabled || queryChanged) {
      this.updateResults(this.props.query);
    }
  }

  // Query helpers


  /* eslint-disable react/no-danger */
  renderHighlight(candidateString, query, name) {
    const options = {
      wrap: {
        tagOpen: '<mark class="highlight">',
        tagClose: "</mark>"
      }
    };
    const html = _fuzzaldrinPlus2.default.wrap(candidateString, query, options);
    return _react2.default.createElement("div", { dangerouslySetInnerHTML: { __html: html } });
  }

  shouldShowErrorEmoji() {
    const { query } = this.props;
    if (this.isGotoQuery()) {
      return !/^:\d*$/.test(query);
    }
    return !this.getResultCount() && !!query;
  }

  getSummaryMessage() {
    let summaryMsg = "";
    if (this.isGotoQuery()) {
      summaryMsg = L10N.getStr("shortcuts.gotoLine");
    } else if (this.isFunctionQuery() && this.props.symbolsLoading) {
      summaryMsg = L10N.getStr("loadingText");
    }
    return summaryMsg;
  }

  render() {
    const { enabled, query } = this.props;
    const { selectedIndex, results } = this.state;

    if (!enabled) {
      return null;
    }
    const items = this.highlightMatching(query, results || []);
    const expanded = !!items && items.length > 0;

    return _react2.default.createElement(
      _Modal2.default,
      { "in": enabled, handleClose: this.closeModal },
      _react2.default.createElement(_SearchInput2.default, _extends({
        query: query,
        hasPrefix: true,
        count: this.getResultCount(),
        placeholder: L10N.getStr("sourceSearch.search2"),
        summaryMsg: this.getSummaryMessage(),
        showErrorEmoji: this.shouldShowErrorEmoji(),
        isLoading: false,
        onChange: this.onChange,
        onKeyDown: this.onKeyDown,
        handleClose: this.closeModal,
        expanded: expanded,
        showClose: false,
        selectedItemId: expanded && items[selectedIndex] ? items[selectedIndex].id : ""
      }, this.isSourceSearch() ? { size: "big" } : {})),
      results && _react2.default.createElement(_ResultList2.default, _extends({
        key: "results",
        items: items,
        selected: selectedIndex,
        selectItem: this.selectResultItem,
        ref: "resultList",
        expanded: expanded
      }, this.isSourceSearch() ? { size: "big" } : {}))
    );
  }
}

exports.QuickOpenModal = QuickOpenModal; /* istanbul ignore next: ignoring testing of redux connection stuff */

function mapStateToProps(state) {
  const selectedSource = (0, _selectors.getSelectedSource)(state);
  const displayedSources = (0, _selectors.getDisplayedSourcesList)(state);
  const tabs = (0, _selectors.getTabs)(state);

  return {
    cx: (0, _selectors.getContext)(state),
    enabled: (0, _selectors.getQuickOpenEnabled)(state),
    displayedSources,
    selectedSource,
    selectedContentLoaded: selectedSource ? !!(0, _selectors.getSourceContent)(state, selectedSource.id) : undefined,
    symbols: (0, _quickOpen.formatSymbols)((0, _selectors.getSymbols)(state, selectedSource)),
    symbolsLoading: (0, _selectors.isSymbolsLoading)(state, selectedSource),
    query: (0, _selectors.getQuickOpenQuery)(state),
    searchType: (0, _selectors.getQuickOpenType)(state),
    tabs
  };
}

/* istanbul ignore next: ignoring testing of redux connection stuff */
exports.default = (0, _connect.connect)(mapStateToProps, {
  selectSpecificLocation: _actions2.default.selectSpecificLocation,
  setQuickOpenQuery: _actions2.default.setQuickOpenQuery,
  highlightLineRange: _actions2.default.highlightLineRange,
  closeQuickOpen: _actions2.default.closeQuickOpen
})(QuickOpenModal);

/***/ }),
/* 782 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(67);

var _classnames2 = _interopRequireDefault(_classnames);

var _AccessibleImage = __webpack_require__(495);

var _AccessibleImage2 = _interopRequireDefault(_AccessibleImage);

__webpack_require__(783);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */

class ResultList extends _react.Component {
  constructor(...args) {
    var _temp;

    return _temp = super(...args), this.renderListItem = (item, index) => {
      if (item.value === "/" && item.title === "") {
        item.title = "(index)";
      }

      const { selectItem, selected } = this.props;
      const props = {
        onClick: event => selectItem(event, item, index),
        key: `${item.id}${item.value}${index}`,
        ref: String(index),
        title: item.value,
        "aria-labelledby": `${item.id}-title`,
        "aria-describedby": `${item.id}-subtitle`,
        role: "option",
        className: (0, _classnames2.default)("result-item", {
          selected: index === selected
        })
      };

      return _react2.default.createElement(
        "li",
        props,
        item.icon && _react2.default.createElement(
          "div",
          { className: "icon" },
          _react2.default.createElement(_AccessibleImage2.default, { className: item.icon })
        ),
        _react2.default.createElement(
          "div",
          { id: `${item.id}-title`, className: "title" },
          item.title
        ),
        item.subtitle != item.title ? _react2.default.createElement(
          "div",
          { id: `${item.id}-subtitle`, className: "subtitle" },
          item.subtitle
        ) : null
      );
    }, _temp;
  }

  render() {
    const { size, items, role } = this.props;

    return _react2.default.createElement(
      "ul",
      {
        className: (0, _classnames2.default)("result-list", size),
        id: "result-list",
        role: role,
        "aria-live": "polite"
      },
      items.map(this.renderListItem)
    );
  }
}
exports.default = ResultList;
ResultList.defaultProps = {
  size: "small",
  role: "listbox"
};

/***/ }),
/* 783 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 784 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ })
/******/ ]);
});